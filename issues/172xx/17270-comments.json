[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#12557](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/12557.html) ([WIP] 64 bit iOS device support by Sjors)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-10-27T02:24:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-546655782",
      "id" : 546655782,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NjY1NTc4Mg==",
      "updated_at" : "2019-11-09T02:56:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546655782",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r339333532"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/339333532"
         }
      },
      "author_association" : "MEMBER",
      "body" : "To also have CPU features bits for other architectures (on Linux) you could include `getauxval(AT_HWCAP)` and `getauxval(AT_HWCAP2)`.\r\n(maybe some other `getauxval` are relevant too, e.g. `AT_RANDOM` has 16 bytes of random data)",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-27T09:39:41Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/sha512.h>\n+#include <vector>\n+#include <support/cleanse.h>\n+#include <climits>\n+#include <thread>\n+#include <string.h>\n+\n+#include <util/time.h> // for GetTime()\n+\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#else\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+#include <sys/types.h>\n+#include <sys/utsname.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <ifaddrs.h>\n+#include <fcntl.h>\n+#include <netinet/ip.h>\n+#include <unistd.h>\n+#endif\n+\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+#include <cpuid.h>\n+#endif\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static int64_t nLastPerfmon;\n+    if (GetTime() < nLastPerfmon + 10 * 60)\n+        return;\n+    nLastPerfmon = GetTime();\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+void GetCPUID(uint32_t leaf, uint32_t subleaf, uint32_t& a, uint32_t& b, uint32_t& c, uint32_t& d)\n+{\n+    // We can't use __get_cpuid as it doesn't support subleafs.\n+#ifdef __GNUC__\n+    __cpuid_count(leaf, subleaf, a, b, c, d);\n+#else\n+    __asm__ (\"cpuid\" : \"=a\"(a), \"=b\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(leaf), \"2\"(subleaf));\n+#endif\n+}\n+\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf < max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << ts.tv_sec << ts.tv_nsec << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+#endif\n+\n+}\n+\n+void RandAddStaticEnv(CSHA512& hasher)\n+{\n+    // Some compile-time static properties\n+    uint32_t x;\n+    x = ((CHAR_MIN < 0) << 30) + (sizeof(void *) << 16) + (sizeof(long) << 8) + sizeof(int);\n+    hasher << x;\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n+    x = (__GNUC_PATCHLEVEL__ << 16) + (__GNUC_MINOR__ << 8) + __GNUC__;\n+    hasher << x;\n+#endif\n+#if defined(_MSC_VER)\n+    x = _MSC_VER;\n+    hasher << x;\n+#endif\n+#if defined(__STDC_VERSION__)\n+    x = __STDC_VERSION__;\n+    hasher << x;\n+#endif\n+#if defined(_XOPEN_VERSION)\n+    x = _XOPEN_VERSION;\n+    hasher << x;\n+#endif\n+\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+    AddCPUID(hasher);\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r339333532",
      "id" : 339333532,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzOTMzMzUzMg==",
      "original_commit_id" : "0c6d5cb1f7fcf00fb7a900e5f5a1f2e1e2a49978",
      "original_position" : 218,
      "path" : "src/randomenv.cpp",
      "position" : 361,
      "pull_request_review_id" : 307563127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/339333532",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Errors on MacOSX (looks like it doesn't have `environ` and `CLOCK_MONOTONIC`):\r\n```\r\nandomenv.cpp:177:19: error: use of undeclared identifier 'CLOCK_MONOTONIC'\r\n    clock_gettime(CLOCK_MONOTONIC, &ts);\r\nrandomenv.cpp:222:64: error: use of undeclared identifier 'environ'\r\n    hasher << &x << &RandAddStaticEnv << &malloc << &errno << &environ << addr;                                                \r\nrandomenv.cpp:282:9: error: use of undeclared identifier 'environ'\r\n    if (environ) {\r\nrandomenv.cpp:283:28: error: use of undeclared identifier 'environ'\r\n        for (size_t i = 0; environ[i]; ++i) {\r\nrandomenv.cpp:284:48: error: use of undeclared identifier 'environ'; did you mean 'union'?\r\n            hasher.Write((const unsigned char*)environ[i], strlen(environ[i]));\r\n                                               ^~~~~~~\r\n                                               union\r\nrandomenv.cpp:284:48: error: expected expression\r\nrandomenv.cpp:284:67: error: use of undeclared identifier 'environ'\r\n            hasher.Write((const unsigned char*)environ[i], strlen(environ[i]));\r\n                                                                 ^\r\n7 errors generated.\r\n```",
      "created_at" : "2019-10-27T10:19:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-546680696",
      "id" : 546680696,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NjY4MDY5Ng==",
      "updated_at" : "2019-10-27T10:19:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546680696",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r339361181"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/339361181"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, added!",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-27T20:05:19Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/sha512.h>\n+#include <vector>\n+#include <support/cleanse.h>\n+#include <climits>\n+#include <thread>\n+#include <string.h>\n+\n+#include <util/time.h> // for GetTime()\n+\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#else\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+#include <sys/types.h>\n+#include <sys/utsname.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <ifaddrs.h>\n+#include <fcntl.h>\n+#include <netinet/ip.h>\n+#include <unistd.h>\n+#endif\n+\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+#include <cpuid.h>\n+#endif\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static int64_t nLastPerfmon;\n+    if (GetTime() < nLastPerfmon + 10 * 60)\n+        return;\n+    nLastPerfmon = GetTime();\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+void GetCPUID(uint32_t leaf, uint32_t subleaf, uint32_t& a, uint32_t& b, uint32_t& c, uint32_t& d)\n+{\n+    // We can't use __get_cpuid as it doesn't support subleafs.\n+#ifdef __GNUC__\n+    __cpuid_count(leaf, subleaf, a, b, c, d);\n+#else\n+    __asm__ (\"cpuid\" : \"=a\"(a), \"=b\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(leaf), \"2\"(subleaf));\n+#endif\n+}\n+\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf < max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << ts.tv_sec << ts.tv_nsec << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+#endif\n+\n+}\n+\n+void RandAddStaticEnv(CSHA512& hasher)\n+{\n+    // Some compile-time static properties\n+    uint32_t x;\n+    x = ((CHAR_MIN < 0) << 30) + (sizeof(void *) << 16) + (sizeof(long) << 8) + sizeof(int);\n+    hasher << x;\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n+    x = (__GNUC_PATCHLEVEL__ << 16) + (__GNUC_MINOR__ << 8) + __GNUC__;\n+    hasher << x;\n+#endif\n+#if defined(_MSC_VER)\n+    x = _MSC_VER;\n+    hasher << x;\n+#endif\n+#if defined(__STDC_VERSION__)\n+    x = __STDC_VERSION__;\n+    hasher << x;\n+#endif\n+#if defined(_XOPEN_VERSION)\n+    x = _XOPEN_VERSION;\n+    hasher << x;\n+#endif\n+\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+    AddCPUID(hasher);\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r339361181",
      "id" : 339361181,
      "in_reply_to_id" : 339333532,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzOTM2MTE4MQ==",
      "original_commit_id" : "0c6d5cb1f7fcf00fb7a900e5f5a1f2e1e2a49978",
      "original_position" : 218,
      "path" : "src/randomenv.cpp",
      "position" : 361,
      "pull_request_review_id" : 307591830,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/339361181",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK: good idea",
      "created_at" : "2019-10-27T20:30:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-546731211",
      "id" : 546731211,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NjczMTIxMQ==",
      "updated_at" : "2019-10-27T20:30:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546731211",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I think I've addressed a compatibility/build issues. Can someone try this on OSX, and perhaps some BSD flavor?",
      "created_at" : "2019-10-27T21:34:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-546736892",
      "id" : 546736892,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NjczNjg5Mg==",
      "updated_at" : "2019-10-27T21:34:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546736892",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@sipa, \r\nIt runs....\r\nhttps://github.com/RandyMcMillan/bitcoin/blob/201910_seedrandom/debug.log\r\nhttps://github.com/RandyMcMillan/bitcoin/blob/201910_seedrandom/mojave10.14.6build.txt",
      "created_at" : "2019-10-27T22:43:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-546742728",
      "id" : 546742728,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0Njc0MjcyOA==",
      "updated_at" : "2019-10-27T22:43:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546742728",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/152159?v=4",
         "events_url" : "https://api.github.com/users/RandyMcMillan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/RandyMcMillan/followers",
         "following_url" : "https://api.github.com/users/RandyMcMillan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/RandyMcMillan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/RandyMcMillan",
         "id" : 152159,
         "login" : "RandyMcMillan",
         "node_id" : "MDQ6VXNlcjE1MjE1OQ==",
         "organizations_url" : "https://api.github.com/users/RandyMcMillan/orgs",
         "received_events_url" : "https://api.github.com/users/RandyMcMillan/received_events",
         "repos_url" : "https://api.github.com/users/RandyMcMillan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/RandyMcMillan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/RandyMcMillan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/RandyMcMillan"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "travis-ci > https://travis-ci.org/RandyMcMillan/bitcoin/jobs/603655433",
      "created_at" : "2019-10-27T22:56:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-546743659",
      "id" : 546743659,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0Njc0MzY1OQ==",
      "updated_at" : "2019-10-27T23:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546743659",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/152159?v=4",
         "events_url" : "https://api.github.com/users/RandyMcMillan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/RandyMcMillan/followers",
         "following_url" : "https://api.github.com/users/RandyMcMillan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/RandyMcMillan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/RandyMcMillan",
         "id" : 152159,
         "login" : "RandyMcMillan",
         "node_id" : "MDQ6VXNlcjE1MjE1OQ==",
         "organizations_url" : "https://api.github.com/users/RandyMcMillan/orgs",
         "received_events_url" : "https://api.github.com/users/RandyMcMillan/received_events",
         "repos_url" : "https://api.github.com/users/RandyMcMillan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/RandyMcMillan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/RandyMcMillan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/RandyMcMillan"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Can someone try this on OSX, and perhaps some BSD flavor?\r\n\r\nI get the following error when building eed8cfec452a538d644844fb96606e6bc24f47c8 on OpenBSD 6.6:\r\n```\r\n  CXX      libbitcoin_util_a-randomenv.o\r\nIn file included from randomenv.cpp:37:\r\n/usr/include/netinet/ip.h:67:19: error: field has incomplete type 'struct in_addr'\r\n        struct    in_addr ip_src, ip_dst; /* source and dest address */\r\n                          ^\r\n/usr/include/netinet/ip.h:67:11: note: forward declaration of 'in_addr'\r\n        struct    in_addr ip_src, ip_dst; /* source and dest address */\r\n                  ^\r\n/usr/include/netinet/ip.h:67:27: error: field has incomplete type 'struct in_addr'\r\n        struct    in_addr ip_src, ip_dst; /* source and dest address */\r\n                                  ^\r\n/usr/include/netinet/ip.h:67:11: note: forward declaration of 'in_addr'\r\n        struct    in_addr ip_src, ip_dst; /* source and dest address */\r\n                  ^\r\n/usr/include/netinet/ip.h:181:19: error: field has incomplete type 'struct in_addr'\r\n                        struct in_addr ipt_addr;\r\n                                       ^\r\n/usr/include/netinet/ip.h:67:11: note: forward declaration of 'in_addr'\r\n        struct    in_addr ip_src, ip_dst; /* source and dest address */\r\n                  ^\r\nrandomenv.cpp:101:57: error: unknown type name 'sockaddr_in'; did you mean 'sockaddr'?\r\n        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\r\n                                                        ^~~~~~~~~~~\r\n                                                        sockaddr\r\n/usr/include/sys/socket.h:207:8: note: 'sockaddr' declared here\r\nstruct sockaddr {\r\n       ^\r\nrandomenv.cpp:104:57: error: unknown type name 'sockaddr_in6'; did you mean 'sockaddr'?\r\n        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\r\n                                                        ^~~~~~~~~~~~\r\n                                                        sockaddr\r\n/usr/include/sys/socket.h:207:8: note: 'sockaddr' declared here\r\nstruct sockaddr {\r\n       ^\r\n5 errors generated.\r\n```",
      "created_at" : "2019-10-28T14:13:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-546964842",
      "id" : 546964842,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0Njk2NDg0Mg==",
      "updated_at" : "2019-10-28T14:13:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546964842",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Log on FreeBSD 12.0-RELEASE-p10 (same complaint, about `sockaddr`)\r\n<details>\r\n\r\n```\r\nMaking all in src\r\ngmake[1]: Entering directory '/usr/home/user/src/bitcoin/src'\r\ngmake[2]: Entering directory '/usr/home/user/src/bitcoin/src'\r\n  CXX      libbitcoin_util_a-randomenv.o\r\nIn file included from randomenv.cpp:37:\r\n/usr/include/netinet/ip.h:71:17: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                        ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:71:24: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                               ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:188:19: error: field has incomplete type 'struct in_addr'\r\n                        struct in_addr ipt_addr;\r\n                                       ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:223:17: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ippseudo_src;   /* source internet address */\r\n                        ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:224:17: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ippseudo_dst;   /* destination internet address */\r\n                        ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\nrandomenv.cpp:101:57: error: unknown type name 'sockaddr_in'; did you mean 'sockaddr'?\r\n        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\r\n                                                        ^~~~~~~~~~~\r\n                                                        sockaddr\r\n/usr/include/sys/socket.h:328:8: note: 'sockaddr' declared here\r\nstruct sockaddr {\r\n       ^\r\nrandomenv.cpp:104:57: error: unknown type name 'sockaddr_in6'; did you mean 'sockaddr'?\r\n        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\r\n                                                        ^~~~~~~~~~~~\r\n                                                        sockaddr\r\n/usr/include/sys/socket.h:328:8: note: 'sockaddr' declared here\r\nstruct sockaddr {\r\n       ^\r\n7 errors generated.\r\ngmake[2]: *** [Makefile:8866: libbitcoin_util_a-randomenv.o] Error 1\r\ngmake[2]: Leaving directory '/usr/home/user/src/bitcoin/src'\r\ngmake[1]: *** [Makefile:14135: all-recursive] Error 1\r\ngmake[1]: Leaving directory '/usr/home/user/src/bitcoin/src'\r\ngmake: *** [Makefile:774: all-recursive] Error 1\r\n```\r\n\r\n</details>\r\n",
      "created_at" : "2019-10-28T15:37:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547005320",
      "id" : 547005320,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzAwNTMyMA==",
      "updated_at" : "2019-10-28T15:37:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547005320",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Building freeBSD here: https://cirrus-ci.com/task/5690364417015808\r\n\r\n\r\nEdit: Same error: https://cirrus-ci.com/task/5690364417015808?command=make#L734",
      "created_at" : "2019-10-28T15:37:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547005637",
      "id" : 547005637,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzAwNTYzNw==",
      "updated_at" : "2019-10-28T16:06:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547005637",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Does the comment in `random.h` need to be updated?",
      "created_at" : "2019-10-28T15:50:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547011765",
      "id" : 547011765,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzAxMTc2NQ==",
      "updated_at" : "2019-10-28T15:50:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547011765",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Does the comment in random.h need to be updated?\r\n\r\nIf that is updated, you could also cherry-pick https://github.com/bitcoin/bitcoin/pull/17265/commits/770cd9640e8b38d3456527bdf3d84b589cbd3418 out of #17265 which contains some related corrections.",
      "created_at" : "2019-10-28T15:58:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547015568",
      "id" : 547015568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzAxNTU2OA==",
      "updated_at" : "2019-10-28T15:58:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547015568",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "New freeBSD build: https://cirrus-ci.com/task/4712584309112832",
      "created_at" : "2019-10-28T18:41:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547089920",
      "id" : 547089920,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzA4OTkyMA==",
      "updated_at" : "2019-10-28T18:45:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547089920",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "New freeBSD build failure: https://cirrus-ci.com/task/4712584309112832?command=make#L761\r\n\r\n<details><summary>log</summary>\r\n\r\n```\r\n/usr/local/bin/ccache c++ -std=c++11 -DHAVE_CONFIG_H -I. -I../src/config   -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 -I. -I/tmp/cirrus-ci-build/db4/include -DBOOST_SP_USE_STD_ATOMIC -DBOOST_AC_USE_STD_ATOMIC -pthread -I/usr/local/include -I./leveldb/include -I./leveldb/helpers/memenv -I/usr/local/include  -I./secp256k1/include -I./univalue/include -Qunused-arguments  -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS  -Wstack-protector -fstack-protector-all -Wall -Wextra -Wformat -Wvla -Wswitch -Wformat-security -Wthread-safety-analysis -Wrange-loop-analysis -Wredundant-decls -Wno-unused-parameter -Wno-self-assign -Wno-unused-local-typedef -Wno-deprecated-register -Wno-implicit-fallthrough    -fPIE -g -O2 -c -o libbitcoin_util_a-randomenv.o `test -f 'randomenv.cpp' || echo './'`randomenv.cpp\r\nIn file included from randomenv.cpp:29:\r\n/usr/include/netinet/ip.h:53:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ip_hl:4,                /* header length */\r\n        ^\r\n/usr/include/netinet/ip.h:60:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ip_tos;                 /* type of service */\r\n        ^\r\n/usr/include/netinet/ip.h:61:2: error: unknown type name 'u_short'; did you mean 'short'?\r\n        u_short ip_len;                 /* total length */\r\n        ^\r\n/usr/include/netinet/ip.h:62:2: error: unknown type name 'u_short'; did you mean 'short'?\r\n        u_short ip_id;                  /* identification */\r\n        ^\r\n/usr/include/netinet/ip.h:63:2: error: unknown type name 'u_short'; did you mean 'short'?\r\n        u_short ip_off;                 /* fragment offset field */\r\n        ^\r\n/usr/include/netinet/ip.h:68:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ip_ttl;                 /* time to live */\r\n        ^\r\n/usr/include/netinet/ip.h:69:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ip_p;                   /* protocol */\r\n        ^\r\n/usr/include/netinet/ip.h:70:2: error: unknown type name 'u_short'; did you mean 'short'?\r\n        u_short ip_sum;                 /* checksum */\r\n        ^\r\n/usr/include/netinet/ip.h:71:17: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                        ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:71:24: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                               ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:174:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ipt_code;               /* IPOPT_TS */\r\n        ^\r\n/usr/include/netinet/ip.h:175:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ipt_len;                /* size of structure (variable) */\r\n        ^\r\n/usr/include/netinet/ip.h:176:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ipt_ptr;                /* index of current entry */\r\n        ^\r\n/usr/include/netinet/ip.h:178:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char  ipt_flg:4,              /* flags, see below */\r\n        ^\r\n/usr/include/netinet/ip.h:188:19: error: field has incomplete type 'struct in_addr'\r\n                        struct in_addr ipt_addr;\r\n                                       ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:223:17: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ippseudo_src;   /* source internet address */\r\n                        ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:224:17: error: field has incomplete type 'struct in_addr'\r\n        struct  in_addr ippseudo_dst;   /* destination internet address */\r\n                        ^\r\n/usr/include/netinet/ip.h:71:9: note: forward declaration of 'in_addr'\r\n        struct  in_addr ip_src,ip_dst;  /* source and dest address */\r\n                ^\r\n/usr/include/netinet/ip.h:225:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char          ippseudo_pad;   /* pad, must be zero */\r\n        ^\r\n/usr/include/netinet/ip.h:226:2: error: unknown type name 'u_char'; did you mean 'char'?\r\n        u_char          ippseudo_p;     /* protocol */\r\n        ^\r\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\r\n20 errors generated.\r\ngmake[2]: *** [Makefile:8866: libbitcoin_util_a-randomenv.o] Error 1\r\ngmake[2]: Leaving directory '/tmp/cirrus-ci-build/src'\r\ngmake[1]: *** [Makefile:14135: install-recursive] Error 1\r\ngmake[1]: Leaving directory '/tmp/cirrus-ci-build/src'\r\ngmake: *** [Makefile:774: install-recursive] Error 1\r\nExit status: 2\r\n```\r\n\r\n</details>",
      "created_at" : "2019-10-28T19:28:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547108271",
      "id" : 547108271,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzEwODI3MQ==",
      "updated_at" : "2019-10-28T19:28:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547108271",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "new build :pray: https://cirrus-ci.com/task/6286311933083648",
      "created_at" : "2019-10-28T20:49:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547139733",
      "id" : 547139733,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzEzOTczMw==",
      "updated_at" : "2019-10-28T20:49:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547139733",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MarcoFalke Hmm, \"checking whether sysctlbyname is declared... no\". Does FreeBSD not have `sysctlbyname`?",
      "created_at" : "2019-10-28T21:09:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547146948",
      "id" : 547146948,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzE0Njk0OA==",
      "updated_at" : "2019-10-28T21:09:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547146948",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> MarcoFalke Hmm, \"checking whether sysctlbyname is declared... no\". Does FreeBSD not have sysctlbyname?\r\n\r\nIt does, looks like you'll just need to include `sys/types.h` as well. See the [sysctlbyname docs](http://nixdoc.net/man-pages/FreeBSD/man3/sysctlbyname.3.html).\r\n\r\nAfter including `sys/types.h`I've tested using `12.0-RELEASE-p6` and see `sysctlbyname is declared... yes`.",
      "created_at" : "2019-10-28T22:19:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547170020",
      "id" : 547170020,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzE3MDAyMA==",
      "updated_at" : "2019-10-28T22:19:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547170020",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "New build: https://cirrus-ci.com/task/5389706841292800",
      "created_at" : "2019-10-29T13:40:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547424674",
      "id" : 547424674,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzQyNDY3NA==",
      "updated_at" : "2019-10-29T13:40:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547424674",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. I have to review more closely, but how do we detect situations \"where system entropy is somehow broken\"? Are these sources now unconditionally rolled into our seeding process?",
      "created_at" : "2019-10-29T16:02:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547497557",
      "id" : 547497557,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzQ5NzU1Nw==",
      "updated_at" : "2019-10-29T16:02:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547497557",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jamesob They're undetectable in general.\n\nTo clarify: I mean situations where system entropy is broken, for example because /dev/urandum is initialized to just 2^32 possible states and nothing new is fed into it.  An attacker who knows this could predict the random numbers you're going to generate, by simply looping over all 2^32 possibilities and comparing them with your output.\n\nThis is generally not detectable, unless it's a very extreme case (with no entropy whatsoever, say, and all reads from /dev/urandom or similar produce the same output). There is also not anything we can do to fix it; it's a terrible bug if it happens, but fixing it requires discovering and fixing the root cause.\n\nWhat this PR does is add in a bunch of environment data (e.g. interrupt statistics, resource usage statistics, pids, ...) that would make the situation slightly less bad in such a case - perhaps enough to make it non-attackable. But it's not a fix.",
      "created_at" : "2019-10-29T16:05:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547499248",
      "id" : 547499248,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzQ5OTI0OA==",
      "updated_at" : "2019-10-29T17:05:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547499248",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340200295"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340200295"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Are you sure you don't need to keep `if defined(USE_ASM)` around for `void Transform(`?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-29T16:51:45Z",
      "diff_hunk" : "@@ -8,15 +8,14 @@\n #include <assert.h>\n #include <string.h>\n \n+#include <compat/cpuid.h>\n+\n #if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n-#if defined(USE_ASM)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340200295",
      "id" : 340200295,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDIwMDI5NQ==",
      "original_commit_id" : "35cfbf75871da0833c6bdd32a9ccc0114506de01",
      "original_position" : 7,
      "path" : "src/crypto/sha256.cpp",
      "position" : 7,
      "pull_request_review_id" : 308673063,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340200295",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "For obviously broken cases (e.g. the random number generator returns a constant) it is possible to detect it with automated tools that apply heuristics such as those described in https://web.archive.org/web/20110602194701/http://users.eecs.northwestern.edu/~nickle/310/2010/headRuns.pdf . However, these tools can only hint at potential problems and never certify correctness. See https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf for an example of such a tool. That tool only works for long sequences, so it doesn't seem applicable to the sources added here... Not to mention the randomness sources added in this pull request are non-cryptographic, so any slightly sane tool would immediately yell at them.",
      "created_at" : "2019-10-29T17:27:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547538883",
      "id" : 547538883,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzUzODg4Mw==",
      "updated_at" : "2019-10-29T17:27:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547538883",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340246307"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340246307"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-29T18:14:21Z",
      "diff_hunk" : "@@ -8,15 +8,14 @@\n #include <assert.h>\n #include <string.h>\n \n+#include <compat/cpuid.h>\n+\n #if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n-#if defined(USE_ASM)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340246307",
      "id" : 340246307,
      "in_reply_to_id" : 340200295,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDI0NjMwNw==",
      "original_commit_id" : "35cfbf75871da0833c6bdd32a9ccc0114506de01",
      "original_position" : 7,
      "path" : "src/crypto/sha256.cpp",
      "position" : 7,
      "pull_request_review_id" : 308731736,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340246307",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "A bunch of updates over the past days:\r\n* Cherry-picked https://github.com/bitcoin/bitcoin/commit/770cd9640e8b38d3456527bdf3d84b589cbd3418\r\n* Added a moveonly commit to merge the cpuid code in random and crypto/sha256, making it reusable for randomenv.\r\n* Added a commit to use `getauxval` on Linux.\r\n* Added a commit to use `sysctlbyname` on BSD/MacOS.\r\n* Added a commit to make sure dynamic env seeders do not run more than once per minute, and added a scheduled task to make sure they do get run occasionally.\r\n* Added a commit to fix a bug in the perfmon seeder (now that it can be called from multiple threads, it may need an atomic to track the previous run time).\r\n",
      "created_at" : "2019-10-29T19:42:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547596533",
      "id" : 547596533,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzU5NjUzMw==",
      "updated_at" : "2019-10-29T21:49:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547596533",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "A reminder that this sort of thing is important:  Some ryzen cpus rng returns a constant (and success), and in default configs linux relies on it for many purposes (I think, /dev/random in current default kernel configs mostly manages to dodge the over-reliance, but many other things do-- so it's a narrow miss.)\r\n\r\nhttps://arstechnica.com/gadgets/2019/10/how-a-months-old-amd-microcode-bug-destroyed-my-weekend/",
      "created_at" : "2019-10-29T20:40:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547619465",
      "id" : 547619465,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzYxOTQ2NQ==",
      "updated_at" : "2019-10-29T21:00:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547619465",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Travis error on mingw:\r\n```\r\nrandomenv.cpp: In function void {anonymous}::RandAddSeedPerfmon(CSHA512&):\r\nrandomenv.cpp:63:33: error: variable std::atomic<long long int> last_perfmon has initializer but incomplete type\r\n     static std::atomic<int64_t> last_perfmon{0};\r\n                                 ^~~~~~~~~~~~\r\n```",
      "created_at" : "2019-10-30T13:26:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-547901395",
      "id" : 547901395,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NzkwMTM5NQ==",
      "updated_at" : "2019-10-30T13:26:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/547901395",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340835357"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340835357"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in commit ad09ad707e0ed6e3a537e1a204843792e5d06108:\r\n\r\n`GetTime` is deprecated (see https://dev.visucore.com/bitcoin/doxygen/time_8cpp.html#a350f99e2a13df31f2afbd7f80ab21a5e). I guess you wanted to use `GetSystemTimeInSeconds`",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-30T20:15:25Z",
      "diff_hunk" : "@@ -60,10 +61,11 @@ void RandAddSeedPerfmon(CSHA512& hasher)\n     // Seed with the entire set of perfmon data\n \n     // This can take up to 2 seconds, so only do it every 10 minutes\n-    static int64_t nLastPerfmon;\n-    if (GetTime() < nLastPerfmon + 10 * 60)\n-        return;\n-    nLastPerfmon = GetTime();\n+    static std::atomic<int64_t> last_perfmon{0};\n+    int64_t last_time = last_perfmon.load();\n+    int64_t current_time = GetTime();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340835357",
      "id" : 340835357,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDgzNTM1Nw==",
      "original_commit_id" : "ad09ad707e0ed6e3a537e1a204843792e5d06108",
      "original_position" : 18,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 309491906,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340835357",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340835915"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340835915"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`GetTime<std::chrono::seconds>()` can't hurt here either, as far as I can tell",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-30T20:16:42Z",
      "diff_hunk" : "@@ -60,10 +61,11 @@ void RandAddSeedPerfmon(CSHA512& hasher)\n     // Seed with the entire set of perfmon data\n \n     // This can take up to 2 seconds, so only do it every 10 minutes\n-    static int64_t nLastPerfmon;\n-    if (GetTime() < nLastPerfmon + 10 * 60)\n-        return;\n-    nLastPerfmon = GetTime();\n+    static std::atomic<int64_t> last_perfmon{0};\n+    int64_t last_time = last_perfmon.load();\n+    int64_t current_time = GetTime();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340835915",
      "id" : 340835915,
      "in_reply_to_id" : 340835357,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDgzNTkxNQ==",
      "original_commit_id" : "ad09ad707e0ed6e3a537e1a204843792e5d06108",
      "original_position" : 18,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 309492636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340835915",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340898164"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340898164"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed. Also done elsewhere in the previous commit.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-30T23:03:50Z",
      "diff_hunk" : "@@ -60,10 +61,11 @@ void RandAddSeedPerfmon(CSHA512& hasher)\n     // Seed with the entire set of perfmon data\n \n     // This can take up to 2 seconds, so only do it every 10 minutes\n-    static int64_t nLastPerfmon;\n-    if (GetTime() < nLastPerfmon + 10 * 60)\n-        return;\n-    nLastPerfmon = GetTime();\n+    static std::atomic<int64_t> last_perfmon{0};\n+    int64_t last_time = last_perfmon.load();\n+    int64_t current_time = GetTime();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r340898164",
      "id" : 340898164,
      "in_reply_to_id" : 340835357,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDg5ODE2NA==",
      "original_commit_id" : "ad09ad707e0ed6e3a537e1a204843792e5d06108",
      "original_position" : 18,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 309571739,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/340898164",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341190312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341190312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this should be `/proc/self/schedstat`",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T15:02:46Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341190312",
      "id" : 341190312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTE5MDMxMg==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 223,
      "path" : "src/randomenv.cpp",
      "position" : 276,
      "pull_request_review_id" : 309949749,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341190312",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341199938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341199938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note `vm.swapusage` seems to be macOS only. I can't find it on OpenBSD or FreeBSD.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T15:18:59Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");\n+    AddFile(hasher, \"/proc/zoneinfo\");\n+    AddFile(hasher, \"/proc/meminfo\");\n+    AddFile(hasher, \"/proc/softirqs\");\n+    AddFile(hasher, \"/proc/stat\");\n+    AddFile(hasher, \"/proc/self/status\");\n+#endif\n+#endif\n+\n+    AddSysctl(hasher, \"vm.loadavg\");\n+    AddSysctl(hasher, \"vm.swapusage\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341199938",
      "id" : 341199938,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTE5OTkzOA==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 233,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 309949749,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341199938",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341202812"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341202812"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I couldn't find `/etc/hostconfig` on any of the platforms I tested (macOS, *BSD, Linux). Seems it used to exist on at least macOS, but was removed in `10.10`.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T15:23:34Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");\n+    AddFile(hasher, \"/proc/zoneinfo\");\n+    AddFile(hasher, \"/proc/meminfo\");\n+    AddFile(hasher, \"/proc/softirqs\");\n+    AddFile(hasher, \"/proc/stat\");\n+    AddFile(hasher, \"/proc/self/status\");\n+#endif\n+#endif\n+\n+    AddSysctl(hasher, \"vm.loadavg\");\n+    AddSysctl(hasher, \"vm.swapusage\");\n+\n+    // Stack and heap location\n+    void* addr = malloc(4097);\n+    hasher << &addr << addr;\n+    free(addr);\n+}\n+\n+void RandAddStaticEnv(CSHA512& hasher)\n+{\n+    // Some compile-time static properties\n+    uint32_t x;\n+    x = ((CHAR_MIN < 0) << 30) + (sizeof(void *) << 16) + (sizeof(long) << 8) + sizeof(int);\n+    hasher << x;\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n+    x = (__GNUC_PATCHLEVEL__ << 16) + (__GNUC_MINOR__ << 8) + __GNUC__;\n+    hasher << x;\n+#endif\n+#if defined(_MSC_VER)\n+    x = _MSC_VER;\n+    hasher << x;\n+#endif\n+#if defined(__STDC_VERSION__)\n+    x = __STDC_VERSION__;\n+    hasher << x;\n+#endif\n+#if defined(_XOPEN_VERSION)\n+    x = _XOPEN_VERSION;\n+    hasher << x;\n+#endif\n+\n+#ifdef __linux__\n+    // Information available through getauxval()\n+#  ifdef AT_HWCAP\n+    hasher << getauxval(AT_HWCAP);\n+#  endif\n+#  ifdef AT_HWCAP2\n+    hasher << getauxval(AT_HWCAP2);\n+#  endif\n+#  ifdef AT_RANDOM\n+    hasher << getauxval(AT_RANDOM);\n+#  endif\n+#  ifdef AT_PLATFORM\n+    const char* platform_str = (const char*)getauxval(AT_PLATFORM);\n+    if (platform_str) hasher.Write((const unsigned char*)platform_str, strlen(platform_str) + 1);\n+#  endif\n+#  ifdef AT_EXECFN\n+    const char* exec_str = (const char*)getauxval(AT_EXECFN);\n+    if (exec_str) hasher.Write((const unsigned char*)exec_str, strlen(exec_str) + 1);\n+#  endif\n+#endif // __linux__\n+\n+#ifdef HAVE_GETCPUID\n+    AddCPUID(hasher);\n+#endif\n+\n+    // Memory locations\n+    hasher << &x << &RandAddStaticEnv << &malloc << &errno << &environ;\n+\n+    // Hostname\n+    char hname[256];\n+    if (gethostname(hname, 256) == 0) {\n+        hasher.Write((const unsigned char*)hname, strnlen(hname, 256));\n+    }\n+\n+#if HAVE_DECL_GETIFADDRS\n+    // Network interfaces\n+    struct ifaddrs *ifad = NULL;\n+    getifaddrs(&ifad);\n+    struct ifaddrs *ifit = ifad;\n+    while (ifit != NULL) {\n+        hasher.Write((const unsigned char*)&ifit, sizeof(ifit));\n+        hasher.Write((const unsigned char*)ifit->ifa_name, strlen(ifit->ifa_name) + 1);\n+        hasher.Write((const unsigned char*)&ifit->ifa_flags, sizeof(ifit->ifa_flags));\n+        AddSockaddr(hasher, ifit->ifa_addr);\n+        AddSockaddr(hasher, ifit->ifa_netmask);\n+        AddSockaddr(hasher, ifit->ifa_dstaddr);\n+        ifit = ifit->ifa_next;\n+    }\n+    freeifaddrs(ifad);\n+#endif\n+\n+#ifndef WIN32\n+    // UNIX kernel information\n+    struct utsname name;\n+    if (uname(&name) != -1) {\n+        hasher.Write((const unsigned char*)&name.sysname, strlen(name.sysname) + 1);\n+        hasher.Write((const unsigned char*)&name.nodename, strlen(name.nodename) + 1);\n+        hasher.Write((const unsigned char*)&name.release, strlen(name.release) + 1);\n+        hasher.Write((const unsigned char*)&name.version, strlen(name.version) + 1);\n+        hasher.Write((const unsigned char*)&name.machine, strlen(name.machine) + 1);\n+    }\n+\n+    /* Path and filesystem provided data */\n+    AddPath(hasher, \"/\");\n+    AddPath(hasher, \".\");\n+    AddPath(hasher, \"/tmp\");\n+    AddPath(hasher, \"/home\");\n+    AddPath(hasher, \"/proc\");\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/cmdline\");\n+    AddFile(hasher, \"/proc/cpuinfo\");\n+    AddFile(hasher, \"/proc/version\");\n+#endif\n+    AddFile(hasher, \"/etc/passwd\");\n+    AddFile(hasher, \"/etc/group\");\n+    AddFile(hasher, \"/etc/hosts\");\n+    AddFile(hasher, \"/etc/resolv.conf\");\n+    AddFile(hasher, \"/etc/timezone\");\n+    AddFile(hasher, \"/etc/localtime\");\n+    AddFile(hasher, \"/etc/hostconfig\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341202812",
      "id" : 341202812,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTIwMjgxMg==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 343,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 309949749,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341202812",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341203400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341203400"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`getauxval(AT_RANDOM)`, if present, returns a pointer to 16 bytes of random data; it's not itself random data",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T15:24:34Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");\n+    AddFile(hasher, \"/proc/zoneinfo\");\n+    AddFile(hasher, \"/proc/meminfo\");\n+    AddFile(hasher, \"/proc/softirqs\");\n+    AddFile(hasher, \"/proc/stat\");\n+    AddFile(hasher, \"/proc/self/status\");\n+#endif\n+#endif\n+\n+    AddSysctl(hasher, \"vm.loadavg\");\n+    AddSysctl(hasher, \"vm.swapusage\");\n+\n+    // Stack and heap location\n+    void* addr = malloc(4097);\n+    hasher << &addr << addr;\n+    free(addr);\n+}\n+\n+void RandAddStaticEnv(CSHA512& hasher)\n+{\n+    // Some compile-time static properties\n+    uint32_t x;\n+    x = ((CHAR_MIN < 0) << 30) + (sizeof(void *) << 16) + (sizeof(long) << 8) + sizeof(int);\n+    hasher << x;\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n+    x = (__GNUC_PATCHLEVEL__ << 16) + (__GNUC_MINOR__ << 8) + __GNUC__;\n+    hasher << x;\n+#endif\n+#if defined(_MSC_VER)\n+    x = _MSC_VER;\n+    hasher << x;\n+#endif\n+#if defined(__STDC_VERSION__)\n+    x = __STDC_VERSION__;\n+    hasher << x;\n+#endif\n+#if defined(_XOPEN_VERSION)\n+    x = _XOPEN_VERSION;\n+    hasher << x;\n+#endif\n+\n+#ifdef __linux__\n+    // Information available through getauxval()\n+#  ifdef AT_HWCAP\n+    hasher << getauxval(AT_HWCAP);\n+#  endif\n+#  ifdef AT_HWCAP2\n+    hasher << getauxval(AT_HWCAP2);\n+#  endif\n+#  ifdef AT_RANDOM\n+    hasher << getauxval(AT_RANDOM);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341203400",
      "id" : 341203400,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTIwMzQwMA==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 273,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 309967223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341203400",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341216159"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341216159"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It looks like upstream OpenSSL uses `CLOCK_REALTIME` when generating a timestamp. Could you explain why `CLOCK_MONOTONIC` is the better choice for us? I assume it's TODO with it being less manipulable and kernel compatibility?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T15:45:46Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341216159",
      "id" : 341216159,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTIxNjE1OQ==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 205,
      "path" : "src/randomenv.cpp",
      "position" : 234,
      "pull_request_review_id" : 309949749,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341216159",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341217176"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341217176"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's not a heap of documentation on  `mach_absolute_time` and I can't find any calls to it in recent OpenSSL, however looks like it's available for macOS versions > 10.9. `/usr/include/mach/mach_time.h`.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T15:47:30Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341217176",
      "id" : 341217176,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTIxNzE3Ng==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 202,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 309949749,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341217176",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341304182"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341304182"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It seems both exist.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T18:34:01Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341304182",
      "id" : 341304182,
      "in_reply_to_id" : 341190312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTMwNDE4Mg==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 223,
      "path" : "src/randomenv.cpp",
      "position" : 276,
      "pull_request_review_id" : 310099648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341304182",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341304784"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341304784"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's ok; I combined lists of sysctls listed for various platforms. Not all will exist on each.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T18:35:15Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");\n+    AddFile(hasher, \"/proc/zoneinfo\");\n+    AddFile(hasher, \"/proc/meminfo\");\n+    AddFile(hasher, \"/proc/softirqs\");\n+    AddFile(hasher, \"/proc/stat\");\n+    AddFile(hasher, \"/proc/self/status\");\n+#endif\n+#endif\n+\n+    AddSysctl(hasher, \"vm.loadavg\");\n+    AddSysctl(hasher, \"vm.swapusage\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341304784",
      "id" : 341304784,
      "in_reply_to_id" : 341199938,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTMwNDc4NA==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 233,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 310100431,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341304784",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341305217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341305217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, removing.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T18:36:09Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");\n+    AddFile(hasher, \"/proc/zoneinfo\");\n+    AddFile(hasher, \"/proc/meminfo\");\n+    AddFile(hasher, \"/proc/softirqs\");\n+    AddFile(hasher, \"/proc/stat\");\n+    AddFile(hasher, \"/proc/self/status\");\n+#endif\n+#endif\n+\n+    AddSysctl(hasher, \"vm.loadavg\");\n+    AddSysctl(hasher, \"vm.swapusage\");\n+\n+    // Stack and heap location\n+    void* addr = malloc(4097);\n+    hasher << &addr << addr;\n+    free(addr);\n+}\n+\n+void RandAddStaticEnv(CSHA512& hasher)\n+{\n+    // Some compile-time static properties\n+    uint32_t x;\n+    x = ((CHAR_MIN < 0) << 30) + (sizeof(void *) << 16) + (sizeof(long) << 8) + sizeof(int);\n+    hasher << x;\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n+    x = (__GNUC_PATCHLEVEL__ << 16) + (__GNUC_MINOR__ << 8) + __GNUC__;\n+    hasher << x;\n+#endif\n+#if defined(_MSC_VER)\n+    x = _MSC_VER;\n+    hasher << x;\n+#endif\n+#if defined(__STDC_VERSION__)\n+    x = __STDC_VERSION__;\n+    hasher << x;\n+#endif\n+#if defined(_XOPEN_VERSION)\n+    x = _XOPEN_VERSION;\n+    hasher << x;\n+#endif\n+\n+#ifdef __linux__\n+    // Information available through getauxval()\n+#  ifdef AT_HWCAP\n+    hasher << getauxval(AT_HWCAP);\n+#  endif\n+#  ifdef AT_HWCAP2\n+    hasher << getauxval(AT_HWCAP2);\n+#  endif\n+#  ifdef AT_RANDOM\n+    hasher << getauxval(AT_RANDOM);\n+#  endif\n+#  ifdef AT_PLATFORM\n+    const char* platform_str = (const char*)getauxval(AT_PLATFORM);\n+    if (platform_str) hasher.Write((const unsigned char*)platform_str, strlen(platform_str) + 1);\n+#  endif\n+#  ifdef AT_EXECFN\n+    const char* exec_str = (const char*)getauxval(AT_EXECFN);\n+    if (exec_str) hasher.Write((const unsigned char*)exec_str, strlen(exec_str) + 1);\n+#  endif\n+#endif // __linux__\n+\n+#ifdef HAVE_GETCPUID\n+    AddCPUID(hasher);\n+#endif\n+\n+    // Memory locations\n+    hasher << &x << &RandAddStaticEnv << &malloc << &errno << &environ;\n+\n+    // Hostname\n+    char hname[256];\n+    if (gethostname(hname, 256) == 0) {\n+        hasher.Write((const unsigned char*)hname, strnlen(hname, 256));\n+    }\n+\n+#if HAVE_DECL_GETIFADDRS\n+    // Network interfaces\n+    struct ifaddrs *ifad = NULL;\n+    getifaddrs(&ifad);\n+    struct ifaddrs *ifit = ifad;\n+    while (ifit != NULL) {\n+        hasher.Write((const unsigned char*)&ifit, sizeof(ifit));\n+        hasher.Write((const unsigned char*)ifit->ifa_name, strlen(ifit->ifa_name) + 1);\n+        hasher.Write((const unsigned char*)&ifit->ifa_flags, sizeof(ifit->ifa_flags));\n+        AddSockaddr(hasher, ifit->ifa_addr);\n+        AddSockaddr(hasher, ifit->ifa_netmask);\n+        AddSockaddr(hasher, ifit->ifa_dstaddr);\n+        ifit = ifit->ifa_next;\n+    }\n+    freeifaddrs(ifad);\n+#endif\n+\n+#ifndef WIN32\n+    // UNIX kernel information\n+    struct utsname name;\n+    if (uname(&name) != -1) {\n+        hasher.Write((const unsigned char*)&name.sysname, strlen(name.sysname) + 1);\n+        hasher.Write((const unsigned char*)&name.nodename, strlen(name.nodename) + 1);\n+        hasher.Write((const unsigned char*)&name.release, strlen(name.release) + 1);\n+        hasher.Write((const unsigned char*)&name.version, strlen(name.version) + 1);\n+        hasher.Write((const unsigned char*)&name.machine, strlen(name.machine) + 1);\n+    }\n+\n+    /* Path and filesystem provided data */\n+    AddPath(hasher, \"/\");\n+    AddPath(hasher, \".\");\n+    AddPath(hasher, \"/tmp\");\n+    AddPath(hasher, \"/home\");\n+    AddPath(hasher, \"/proc\");\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/cmdline\");\n+    AddFile(hasher, \"/proc/cpuinfo\");\n+    AddFile(hasher, \"/proc/version\");\n+#endif\n+    AddFile(hasher, \"/etc/passwd\");\n+    AddFile(hasher, \"/etc/group\");\n+    AddFile(hasher, \"/etc/hosts\");\n+    AddFile(hasher, \"/etc/resolv.conf\");\n+    AddFile(hasher, \"/etc/timezone\");\n+    AddFile(hasher, \"/etc/localtime\");\n+    AddFile(hasher, \"/etc/hostconfig\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341305217",
      "id" : 341305217,
      "in_reply_to_id" : 341202812,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTMwNTIxNw==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 343,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 310100984,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341305217",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341305399"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341305399"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm expanding this piece of code to just use all clocks available.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T18:36:33Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341305399",
      "id" : 341305399,
      "in_reply_to_id" : 341216159,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTMwNTM5OQ==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 205,
      "path" : "src/randomenv.cpp",
      "position" : 234,
      "pull_request_review_id" : 310101248,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341305399",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341305714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341305714"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, I tried to find an equivalent to CLOCK_MONOTONIC on MacOS, and found this. It doesn't exactly match what OpenSSL did.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T18:37:13Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341305714",
      "id" : 341305714,
      "in_reply_to_id" : 341217176,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTMwNTcxNA==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 202,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 310101643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341305714",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> sysctlbyname isn't being picked up on OpenBSD (works on macOS and FreeBSD). Will investigate.\r\n\r\nLooks like it doesn't actually exist on OpenBSD. It only has [`sysctl`](https://man.openbsd.org/OpenBSD-6.6/sysctl.2). On OpenBSD 6.6:\r\n```bash\r\nbazinga# cat sysctl.h | grep sysctlbyname\r\nbazinga# cat sysctl.h | grep \"sysctl(\"\r\n * pairs to be used by sysctl(1) in manipulating the subsystem.\r\n * aggregated into an array in debug_sysctl(), so that it can\r\nint kern_sysctl(int *, u_int, void *, size_t *, void *, size_t,\r\nint hw_sysctl(int *, u_int, void *, size_t *, void *, size_t,\r\n< trimmed >\r\nint mpls_sysctl(int *, u_int, void *, size_t *, void *, size_t);\r\nint\tsysctl(const int *, u_int, void *, size_t *, void *, size_t);\r\n```",
      "created_at" : "2019-10-31T18:38:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-548513791",
      "id" : 548513791,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODUxMzc5MQ==",
      "updated_at" : "2019-10-31T18:38:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548513791",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Addressed the comments above (AT_RANDOM gives a pointer, removed /etc/hostconfig, added a comment that not all sysctls are available on every system).\r\n\r\nAlso added:\r\n* Added more clocks (they're gathered once a minute, some redundancy won't hurt).\r\n* Improved the CPUID code (also adds extended leaves now)\r\n* Added compiler version string (`__VERSION__`).\r\n* Added Bitcoin Core version information (`CLIENT_VERSION`, `CLIENT_NAME`, `CLIENT_BUILD`).",
      "created_at" : "2019-10-31T18:48:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-548517871",
      "id" : 548517871,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODUxNzg3MQ==",
      "updated_at" : "2019-10-31T18:50:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548517871",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@fanquake Ok, annoying. Perhaps that means we should use sysctl instead of sysctlbyname.",
      "created_at" : "2019-10-31T18:49:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-548518085",
      "id" : 548518085,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODUxODA4NQ==",
      "updated_at" : "2019-10-31T18:49:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548518085",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341310902"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341310902"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-10-31T18:49:14Z",
      "diff_hunk" : "@@ -0,0 +1,389 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTLBYNAME\n+#include <sys/sysctl.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+void AddSysctl(CSHA512& hasher, const char* path)\n+{\n+#if HAVE_DECL_SYSCTLBYNAME\n+    unsigned char buffer[4096];\n+    size_t siz = 4096;\n+    int ret = sysctlbyname(path, buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void AddCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    GetCPUID(0, 0, ax, bx, cx, dx);\n+    hasher << ax << bx << cx << dx;\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+            hasher << leaf << subleaf << ax << bx << cx << dx;\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifdef __MACH__\n+    hasher << mach_absolute_time();\n+#  else\n+    struct timespec ts;\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#  endif\n+    struct timeval tv;\n+    gettimeofday(&tv, nullptr);\n+    hasher << tv.tv_sec << tv.tv_usec;\n+\n+    // Current resource usage.\n+    struct rusage usage;\n+    if (getrusage(RUSAGE_SELF, &usage) == 0) {\n+        hasher << usage.ru_utime.tv_sec << usage.ru_utime.tv_usec << usage.ru_stime.tv_sec << usage.ru_stime.tv_usec;\n+        hasher << usage.ru_maxrss << usage.ru_minflt << usage.ru_majflt << usage.ru_inblock << usage.ru_oublock;\n+        hasher << usage.ru_nvcsw << usage.ru_nivcsw;\n+    }\n+\n+#ifdef __linux__\n+    AddFile(hasher, \"/proc/diskstats\");\n+    AddFile(hasher, \"/proc/vmstat\");\n+    AddFile(hasher, \"/proc/schedstat\");\n+    AddFile(hasher, \"/proc/zoneinfo\");\n+    AddFile(hasher, \"/proc/meminfo\");\n+    AddFile(hasher, \"/proc/softirqs\");\n+    AddFile(hasher, \"/proc/stat\");\n+    AddFile(hasher, \"/proc/self/status\");\n+#endif\n+#endif\n+\n+    AddSysctl(hasher, \"vm.loadavg\");\n+    AddSysctl(hasher, \"vm.swapusage\");\n+\n+    // Stack and heap location\n+    void* addr = malloc(4097);\n+    hasher << &addr << addr;\n+    free(addr);\n+}\n+\n+void RandAddStaticEnv(CSHA512& hasher)\n+{\n+    // Some compile-time static properties\n+    uint32_t x;\n+    x = ((CHAR_MIN < 0) << 30) + (sizeof(void *) << 16) + (sizeof(long) << 8) + sizeof(int);\n+    hasher << x;\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n+    x = (__GNUC_PATCHLEVEL__ << 16) + (__GNUC_MINOR__ << 8) + __GNUC__;\n+    hasher << x;\n+#endif\n+#if defined(_MSC_VER)\n+    x = _MSC_VER;\n+    hasher << x;\n+#endif\n+#if defined(__STDC_VERSION__)\n+    x = __STDC_VERSION__;\n+    hasher << x;\n+#endif\n+#if defined(_XOPEN_VERSION)\n+    x = _XOPEN_VERSION;\n+    hasher << x;\n+#endif\n+\n+#ifdef __linux__\n+    // Information available through getauxval()\n+#  ifdef AT_HWCAP\n+    hasher << getauxval(AT_HWCAP);\n+#  endif\n+#  ifdef AT_HWCAP2\n+    hasher << getauxval(AT_HWCAP2);\n+#  endif\n+#  ifdef AT_RANDOM\n+    hasher << getauxval(AT_RANDOM);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r341310902",
      "id" : 341310902,
      "in_reply_to_id" : 341203400,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTMxMDkwMg==",
      "original_commit_id" : "8a27be0fb0065d897d4e55a4f7367d54f8914d77",
      "original_position" : 273,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 310108722,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/341310902",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Changes now look good to me. Tested on Linux RISC-V 64 bit w/ no issues.",
      "created_at" : "2019-11-01T10:59:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-548749200",
      "id" : 548749200,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODc0OTIwMA==",
      "updated_at" : "2019-11-01T11:00:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548749200",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Replaced the use of `sysctlbyname` by `sysctl`; it's less extensive and needs more code, but likely supports more systems.",
      "created_at" : "2019-11-01T22:51:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-548976525",
      "id" : 548976525,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODk3NjUyNQ==",
      "updated_at" : "2019-11-01T22:51:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548976525",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342455629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342455629"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Shouldn't this ifdef be outside the function instead of outside it? I mean, I don't think it should be possible to call `AddSysctl` on systems without sysctl?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T09:26:12Z",
      "diff_hunk" : "@@ -0,0 +1,507 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+template<int... S>\n+void AddSysctl(CSHA512& hasher)\n+{\n+#if HAVE_DECL_SYSCTL",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342455629",
      "id" : 342455629,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MjQ1NTYyOQ==",
      "original_commit_id" : "d78a49906f39688b41bc36869fc91665cfbf8a21",
      "original_position" : 174,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 311595893,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342455629",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342456219"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342456219"
         }
      },
      "author_association" : "MEMBER",
      "body" : "could creating the service fail? is there a return value to handle here?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T09:27:31Z",
      "diff_hunk" : "@@ -0,0 +1,507 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+template<int... S>\n+void AddSysctl(CSHA512& hasher)\n+{\n+#if HAVE_DECL_SYSCTL\n+    int CTL[sizeof...(S)] = {S...};\n+    unsigned char buffer[65536];\n+    size_t siz = 65536;\n+    int ret = sysctl(CTL, sizeof...(S), buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher << sizeof(CTL);\n+        hasher.Write((const unsigned char*)CTL, sizeof(CTL));\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void inline AddCPUID(CSHA512& hasher, uint32_t leaf, uint32_t subleaf, uint32_t& ax, uint32_t& bx, uint32_t& cx, uint32_t& dx)\n+{\n+    GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+    hasher << leaf << subleaf << ax << bx << cx << dx;\n+}\n+\n+void AddAllCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    // Iterate over all standard leaves\n+    AddCPUID(hasher, 0, 0, ax, bx, cx, dx); // Returns max leaf in ax\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            AddCPUID(hasher, leaf, subleaf, ax, bx, cx, dx);\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+    // Iterate over all extended leaves\n+    AddCPUID(hasher, 0x80000000, 0, ax, bx, cx, dx); // Returns max extended leaf in ax\n+    uint32_t ext_max = ax;\n+    for (uint32_t leaf = 0x80000001; leaf <= ext_max; ++leaf) {\n+        AddCPUID(hasher, leaf, 0, ax, bx, cx, dx);\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+    // Various clocks\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifndef __MACH__\n+    // On non-MacOS systems, use various clock_gettime() calls.\n+    struct timespec ts;\n+#    ifdef CLOCK_MONOTONIC\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#    endif\n+#    ifdef CLOCK_REALTIME\n+    clock_gettime(CLOCK_REALTIME, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#    endif\n+#    ifdef CLOCK_BOOTTIME\n+    clock_gettime(CLOCK_BOOTTIME, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#    endif\n+#  else\n+    // On MacOS use mach_absolute_time (number of CPU ticks since boot) as a replacement for CLOCK_MONOTONIC,\n+    // and clock_get_time for CALENDAR_CLOCK as a replacement for CLOCK_REALTIME.\n+    hasher << mach_absolute_time();\n+    // From https://gist.github.com/jbenet/1087739\n+    clock_serv_t cclock;\n+    mach_timespec_t mts;\n+    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342456219",
      "id" : 342456219,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MjQ1NjIxOQ==",
      "original_commit_id" : "d78a49906f39688b41bc36869fc91665cfbf8a21",
      "original_position" : 251,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 311596721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342456219",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "it's pretty hard to verify that this is doing anything, at runtime; it would be too much hassle to keep track of everything that is hashed, but it would be nice to have (optionally enabled. category RAND?) summarizing debug log messages like;\r\n`N bytes of static environment data added to random state`\r\n`N bytes of dynamic environment data added to random state`",
      "created_at" : "2019-11-05T09:32:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-549740513",
      "id" : 549740513,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0OTc0MDUxMw==",
      "updated_at" : "2019-11-05T09:34:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/549740513",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342845005"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342845005"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T23:09:58Z",
      "diff_hunk" : "@@ -0,0 +1,507 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+template<int... S>\n+void AddSysctl(CSHA512& hasher)\n+{\n+#if HAVE_DECL_SYSCTL\n+    int CTL[sizeof...(S)] = {S...};\n+    unsigned char buffer[65536];\n+    size_t siz = 65536;\n+    int ret = sysctl(CTL, sizeof...(S), buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher << sizeof(CTL);\n+        hasher.Write((const unsigned char*)CTL, sizeof(CTL));\n+        hasher.Write(buffer, std::min<size_t>(siz, 4096));\n+    }\n+#endif\n+}\n+\n+#ifdef HAVE_GETCPUID\n+void inline AddCPUID(CSHA512& hasher, uint32_t leaf, uint32_t subleaf, uint32_t& ax, uint32_t& bx, uint32_t& cx, uint32_t& dx)\n+{\n+    GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+    hasher << leaf << subleaf << ax << bx << cx << dx;\n+}\n+\n+void AddAllCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    // Iterate over all standard leaves\n+    AddCPUID(hasher, 0, 0, ax, bx, cx, dx); // Returns max leaf in ax\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            AddCPUID(hasher, leaf, subleaf, ax, bx, cx, dx);\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+    // Iterate over all extended leaves\n+    AddCPUID(hasher, 0x80000000, 0, ax, bx, cx, dx); // Returns max extended leaf in ax\n+    uint32_t ext_max = ax;\n+    for (uint32_t leaf = 0x80000001; leaf <= ext_max; ++leaf) {\n+        AddCPUID(hasher, leaf, 0, ax, bx, cx, dx);\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+    // Various clocks\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifndef __MACH__\n+    // On non-MacOS systems, use various clock_gettime() calls.\n+    struct timespec ts;\n+#    ifdef CLOCK_MONOTONIC\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#    endif\n+#    ifdef CLOCK_REALTIME\n+    clock_gettime(CLOCK_REALTIME, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#    endif\n+#    ifdef CLOCK_BOOTTIME\n+    clock_gettime(CLOCK_BOOTTIME, &ts);\n+    hasher << ts.tv_sec << ts.tv_nsec;\n+#    endif\n+#  else\n+    // On MacOS use mach_absolute_time (number of CPU ticks since boot) as a replacement for CLOCK_MONOTONIC,\n+    // and clock_get_time for CALENDAR_CLOCK as a replacement for CLOCK_REALTIME.\n+    hasher << mach_absolute_time();\n+    // From https://gist.github.com/jbenet/1087739\n+    clock_serv_t cclock;\n+    mach_timespec_t mts;\n+    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342845005",
      "id" : 342845005,
      "in_reply_to_id" : 342456219,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg0NTAwNQ==",
      "original_commit_id" : "d78a49906f39688b41bc36869fc91665cfbf8a21",
      "original_position" : 251,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 312105071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342845005",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342845049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342845049"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T23:10:05Z",
      "diff_hunk" : "@@ -0,0 +1,507 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        AddStat(hasher, sb);\n+    }\n+}\n+#endif\n+\n+template<int... S>\n+void AddSysctl(CSHA512& hasher)\n+{\n+#if HAVE_DECL_SYSCTL",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342845049",
      "id" : 342845049,
      "in_reply_to_id" : 342455629,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg0NTA0OQ==",
      "original_commit_id" : "d78a49906f39688b41bc36869fc91665cfbf8a21",
      "original_position" : 174,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 312105122,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342845049",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342845055"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342845055"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Might you consider only reading up to a certain number of bytes? I'm not sure you're guaranteed that some of these files won't be enormous.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T23:10:07Z",
      "diff_hunk" : "@@ -81,6 +99,58 @@ CSHA512& operator<<(CSHA512& hasher, const T& data) {\n     return hasher;\n }\n \n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342845055",
      "id" : 342845055,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg0NTA1NQ==",
      "original_commit_id" : "95f1642930b0fe1156bc9c7bf9ecadceef9426af",
      "original_position" : 90,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 312105131,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342845055",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/177646?v=4",
         "events_url" : "https://api.github.com/users/narula/events{/privacy}",
         "followers_url" : "https://api.github.com/users/narula/followers",
         "following_url" : "https://api.github.com/users/narula/following{/other_user}",
         "gists_url" : "https://api.github.com/users/narula/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/narula",
         "id" : 177646,
         "login" : "narula",
         "node_id" : "MDQ6VXNlcjE3NzY0Ng==",
         "organizations_url" : "https://api.github.com/users/narula/orgs",
         "received_events_url" : "https://api.github.com/users/narula/received_events",
         "repos_url" : "https://api.github.com/users/narula/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/narula/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/narula/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/narula"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342847638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342847638"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T23:18:38Z",
      "diff_hunk" : "@@ -81,6 +99,58 @@ CSHA512& operator<<(CSHA512& hasher, const T& data) {\n     return hasher;\n }\n \n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb;\n+    int f = open(path, O_RDONLY);\n+    if (f != -1) {\n+        unsigned char fbuf[1024];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) {\n+            AddStat(hasher, sb);\n+        }\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342847638",
      "id" : 342847638,
      "in_reply_to_id" : 342845055,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg0NzYzOA==",
      "original_commit_id" : "95f1642930b0fe1156bc9c7bf9ecadceef9426af",
      "original_position" : 90,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 312108299,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342847638",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@laanwj I've added a commit that logs the number of bytes gathered.",
      "created_at" : "2019-11-05T23:19:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-550067759",
      "id" : 550067759,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1MDA2Nzc1OQ==",
      "updated_at" : "2019-11-05T23:19:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/550067759",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342856120"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342856120"
         }
      },
      "author_association" : "NONE",
      "body" : "Should we make this comment explicitly enforced, e.g. having `static_assert(!std::is_same<T, char*>::value, \"calling hasher.operator<< on char* probably won't do what you want\");` or similar?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T23:49:37Z",
      "diff_hunk" : "@@ -0,0 +1,515 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342856120",
      "id" : 342856120,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg1NjEyMA==",
      "original_commit_id" : "f14cd4197677729491bb5fe6110904531605092b",
      "original_position" : 112,
      "path" : "src/randomenv.cpp",
      "position" : 112,
      "pull_request_review_id" : 312119100,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342856120",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1747924?v=4",
         "events_url" : "https://api.github.com/users/madars/events{/privacy}",
         "followers_url" : "https://api.github.com/users/madars/followers",
         "following_url" : "https://api.github.com/users/madars/following{/other_user}",
         "gists_url" : "https://api.github.com/users/madars/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/madars",
         "id" : 1747924,
         "login" : "madars",
         "node_id" : "MDQ6VXNlcjE3NDc5MjQ=",
         "organizations_url" : "https://api.github.com/users/madars/orgs",
         "received_events_url" : "https://api.github.com/users/madars/received_events",
         "repos_url" : "https://api.github.com/users/madars/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/madars/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/madars/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/madars"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342857493"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342857493"
         }
      },
      "author_association" : "MEMBER",
      "body" : "it's only defined in this cpp file, where the hasher is only used for one thing, so the scope for potential accidental misuse is very little (and who knows, maybe you'd *want* to hash a pointer here, if it's random enough due to ASLR)",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-05T23:54:29Z",
      "diff_hunk" : "@@ -0,0 +1,515 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342857493",
      "id" : 342857493,
      "in_reply_to_id" : 342856120,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg1NzQ5Mw==",
      "original_commit_id" : "f14cd4197677729491bb5fe6110904531605092b",
      "original_position" : 112,
      "path" : "src/randomenv.cpp",
      "position" : 112,
      "pull_request_review_id" : 312120742,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342857493",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342859263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342859263"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There are plenty of internal pointers being fed to the RNG here (stack locations, standard library locations, ...).",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-06T00:01:03Z",
      "diff_hunk" : "@@ -0,0 +1,515 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342859263",
      "id" : 342859263,
      "in_reply_to_id" : 342856120,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg1OTI2Mw==",
      "original_commit_id" : "f14cd4197677729491bb5fe6110904531605092b",
      "original_position" : 112,
      "path" : "src/randomenv.cpp",
      "position" : 112,
      "pull_request_review_id" : 312122849,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342859263",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342861048"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342861048"
         }
      },
      "author_association" : "NONE",
      "body" : "They don't appear to be `char*` pointers (e.g. `environ` is `char**`, result of a temp malloc below is `void*`, etc) but potential for misuse is a judgement call.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-06T00:08:02Z",
      "diff_hunk" : "@@ -0,0 +1,515 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342861048",
      "id" : 342861048,
      "in_reply_to_id" : 342856120,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg2MTA0OA==",
      "original_commit_id" : "f14cd4197677729491bb5fe6110904531605092b",
      "original_position" : 112,
      "path" : "src/randomenv.cpp",
      "position" : 112,
      "pull_request_review_id" : 312125022,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342861048",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1747924?v=4",
         "events_url" : "https://api.github.com/users/madars/events{/privacy}",
         "followers_url" : "https://api.github.com/users/madars/followers",
         "following_url" : "https://api.github.com/users/madars/following{/other_user}",
         "gists_url" : "https://api.github.com/users/madars/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/madars",
         "id" : 1747924,
         "login" : "madars",
         "node_id" : "MDQ6VXNlcjE3NDc5MjQ=",
         "organizations_url" : "https://api.github.com/users/madars/orgs",
         "received_events_url" : "https://api.github.com/users/madars/received_events",
         "repos_url" : "https://api.github.com/users/madars/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/madars/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/madars/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/madars"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342861634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342861634"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, good point. Let's see if that compiles.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-06T00:10:24Z",
      "diff_hunk" : "@@ -0,0 +1,515 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342861634",
      "id" : 342861634,
      "in_reply_to_id" : 342856120,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg2MTYzNA==",
      "original_commit_id" : "f14cd4197677729491bb5fe6110904531605092b",
      "original_position" : 112,
      "path" : "src/randomenv.cpp",
      "position" : 112,
      "pull_request_review_id" : 312125786,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342861634",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342863159"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342863159"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. I added `std::decay<T>` so that it also catches const char* and char arrays.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-06T00:16:40Z",
      "diff_hunk" : "@@ -0,0 +1,515 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r342863159",
      "id" : 342863159,
      "in_reply_to_id" : 342856120,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0Mjg2MzE1OQ==",
      "original_commit_id" : "f14cd4197677729491bb5fe6110904531605092b",
      "original_position" : 112,
      "path" : "src/randomenv.cpp",
      "position" : 112,
      "pull_request_review_id" : 312127697,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/342863159",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Tested on a few different platforms;\r\n\r\nFreeBSD x86_64:\r\n```\r\n2019-11-10T13:02:15Z Feeding 66012 of dynamic environment data into RNG\r\n2019-11-10T13:02:15Z Feeding 10350 bytes of static environment data into RNG\r\n```\r\nLinux x86_64 VM:\r\n```\r\n2019-11-10T15:33:02Z Feeding 16094 of dynamic environment data into RNG\r\n2019-11-10T15:33:02Z Feeding 14944 bytes of static environment data into RNG\r\n```\r\nLinux aarch64:\r\n```\r\n2019-11-10T16:18:13Z Feeding 11043 of dynamic environment data into RNG\r\n2019-11-10T16:18:13Z Feeding 7073 bytes of static environment data into RNG\r\n```\r\nLinux arm32:\r\n```\r\n2019-11-10T15:52:06Z Feeding 10921 of dynamic environment data into RNG\r\n2019-11-10T15:52:06Z Feeding 8906 bytes of static environment data into RNG\r\n```\r\nLinux riscv64:\r\n```\r\n2019-11-10T16:50:38Z Feeding 10389 of dynamic environment data into RNG\r\n2019-11-10T16:50:38Z Feeding 6833 bytes of static environment data into RNG\r\n```\r\n\r\nNew compile warning (gcc Linux):\r\n```\r\nIn file included from randomenv.cpp:50:\r\n/usr/include/sys/sysctl.h:21:2: warning: #warning \"The <sys/sysctl.h> header is deprecated and will be removed.\" [-Wcpp]\r\n   21 | #warning \"The <sys/sysctl.h> header is deprecated and will be removed.\"\r\n      |  ^~~~~~~\r\n```\r\nLooks this was a recent libc/kernel change (http://patches-tcwg.linaro.org/patch/19443/). I don't think the intent is to use sysctl on Linux (it already reads `/proc` directly, which is what they suggest instead), so we might want to prevent its detection there somehow.\r\n\r\n(omeone might want to check on a musl-libc based system, all of these Linux is glibc based)",
      "created_at" : "2019-11-10T16:52:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-552212368",
      "id" : 552212368,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1MjIxMjM2OA==",
      "updated_at" : "2019-11-10T16:54:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/552212368",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Added a commit to always avoids sysctl on Linux.",
      "created_at" : "2019-11-10T19:29:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-552225553",
      "id" : 552225553,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1MjIyNTU1Mw==",
      "updated_at" : "2019-11-10T19:29:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/552225553",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345140294"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345140294"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks!\r\nThough, I'd slightly prefer to handle this in the build system, so that the symbol `HAVE_DECL_SYSCTL` doesn't get set in the first place in Linux. This avoids having to handle it on a case by case basis on all caller sites.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-12T10:58:28Z",
      "diff_hunk" : "@@ -46,6 +46,7 @@\n #if HAVE_DECL_GETIFADDRS\n #include <ifaddrs.h>\n #endif\n+#ifndef __linux__",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345140294",
      "id" : 345140294,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTE0MDI5NA==",
      "original_commit_id" : "1d1200f6b2174896f55ed4509eb7e412cacd4e7d",
      "original_position" : 4,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 315449831,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345140294",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345339937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345339937"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm, we here write a struct timeval directly into the hasher, but in other places we avoid it by writing the fields. I presume the avoiding it cases are to avoid writing padding bytes into the hasher (otherwise why both)?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-12T17:23:28Z",
      "diff_hunk" : "@@ -0,0 +1,522 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#ifndef __linux__\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#else\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    static_assert(!std::is_same<typename std::decay<T>::type, char*>::value, \"Calling operator<<(CSHA512, char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, unsigned char*>::value, \"Calling operator<<(CSHA512, unsigned char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const char*>::value, \"Calling operator<<(CSHA512, const char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const unsigned char*>::value, \"Calling operator<<(CSHA512, const unsigned char*) is probably not what you want\");\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345339937",
      "id" : 345339937,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTMzOTkzNw==",
      "original_commit_id" : "1d1200f6b2174896f55ed4509eb7e412cacd4e7d",
      "original_position" : 143,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 315707820,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345339937",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345374202"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345374202"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't get the point of this commit.\r\nYou're avoiding doing something that sleeps 1ms but runs in a tight loop for 10ms.\r\nThe real meat of the function gets called on a timer every minute, but also my be called at other times, but only runs if its been 10 minutes since the last run.\r\n\r\nMaybe we should just skip the SeedInfrequent call in SeedSleep and then we can drop all the once-per-minute checking in this file wholesale and use the scheduler?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-12T18:34:34Z",
      "diff_hunk" : "@@ -585,6 +603,9 @@ static void ProcRand(unsigned char* out, int num, RNGLevel level)\n     case RNGLevel::SLEEP:\n         SeedSleep(hasher, rng);\n         break;\n+    case RNGLevel::PERIODIC:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345374202",
      "id" : 345374202,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTM3NDIwMg==",
      "original_commit_id" : "2f4aaf13270b96541f711b79735a6f71b51fe67f",
      "original_position" : 94,
      "path" : "src/random.cpp",
      "position" : 195,
      "pull_request_review_id" : 315707820,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345374202",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345488583"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345488583"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point, fixed.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-12T22:51:42Z",
      "diff_hunk" : "@@ -46,6 +46,7 @@\n #if HAVE_DECL_GETIFADDRS\n #include <ifaddrs.h>\n #endif\n+#ifndef __linux__",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345488583",
      "id" : 345488583,
      "in_reply_to_id" : 345140294,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTQ4ODU4Mw==",
      "original_commit_id" : "1d1200f6b2174896f55ed4509eb7e412cacd4e7d",
      "original_position" : 4,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 315899614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345488583",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345490375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345490375"
         }
      },
      "author_association" : "MEMBER",
      "body" : "One reason to writing the fields directly is because these structures may have implementation-defined other fields, which are perhaps left uninitialized. Feeding them into the hasher would then trip up valgrind & co. Perhaps this is not a real concern and we should just feed the struct in until someone notices a problem?",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-12T22:56:30Z",
      "diff_hunk" : "@@ -0,0 +1,522 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#ifndef __linux__\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#else\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    static_assert(!std::is_same<typename std::decay<T>::type, char*>::value, \"Calling operator<<(CSHA512, char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, unsigned char*>::value, \"Calling operator<<(CSHA512, unsigned char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const char*>::value, \"Calling operator<<(CSHA512, const char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const unsigned char*>::value, \"Calling operator<<(CSHA512, const unsigned char*) is probably not what you want\");\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345490375",
      "id" : 345490375,
      "in_reply_to_id" : 345339937,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTQ5MDM3NQ==",
      "original_commit_id" : "1d1200f6b2174896f55ed4509eb7e412cacd4e7d",
      "original_position" : 143,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 315901730,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345490375",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345490911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345490911"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you're right, there is fairly little advantage to having both RandAddSeedSleep and RandAddPeriodic. I've redone this PR to instead just have a RandAddPeriodic, which indeed simplifies a bunch of things including not keeping track of when the last run of the expensive stuff was (there is a still a counter in the perfmon data for windows, which only runs once every 10 minutes instead of every minute).",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-12T22:58:06Z",
      "diff_hunk" : "@@ -585,6 +603,9 @@ static void ProcRand(unsigned char* out, int num, RNGLevel level)\n     case RNGLevel::SLEEP:\n         SeedSleep(hasher, rng);\n         break;\n+    case RNGLevel::PERIODIC:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345490911",
      "id" : 345490911,
      "in_reply_to_id" : 345374202,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTQ5MDkxMQ==",
      "original_commit_id" : "2f4aaf13270b96541f711b79735a6f71b51fe67f",
      "original_position" : 94,
      "path" : "src/random.cpp",
      "position" : 195,
      "pull_request_review_id" : 315902440,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345490911",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345505151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345505151"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, fixed: I'm zero initializing all the structs, and then just feeding them directly into the hasher.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-12T23:43:50Z",
      "diff_hunk" : "@@ -0,0 +1,522 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#ifndef __linux__\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#else\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    static_assert(!std::is_same<typename std::decay<T>::type, char*>::value, \"Calling operator<<(CSHA512, char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, unsigned char*>::value, \"Calling operator<<(CSHA512, unsigned char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const char*>::value, \"Calling operator<<(CSHA512, const char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const unsigned char*>::value, \"Calling operator<<(CSHA512, const unsigned char*) is probably not what you want\");\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345505151",
      "id" : 345505151,
      "in_reply_to_id" : 345339937,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTUwNTE1MQ==",
      "original_commit_id" : "1d1200f6b2174896f55ed4509eb7e412cacd4e7d",
      "original_position" : 143,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 315919708,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-12T23:43:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345505151",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345533727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345533727"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I can't say I feel strongly. I see reasons to do it both ways, and as long as valgrind doesn't complain and we hash in the higher-entropy bits, it doesn't matter either way. Just figured I'd flag it since you appeared to be very careful about it in all places but here.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-13T01:42:29Z",
      "diff_hunk" : "@@ -0,0 +1,522 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#ifndef __linux__\n+#if HAVE_DECL_SYSCTL\n+#include <sys/sysctl.h>\n+#endif\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#else\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    static_assert(!std::is_same<typename std::decay<T>::type, char*>::value, \"Calling operator<<(CSHA512, char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, unsigned char*>::value, \"Calling operator<<(CSHA512, unsigned char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const char*>::value, \"Calling operator<<(CSHA512, const char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const unsigned char*>::value, \"Calling operator<<(CSHA512, const unsigned char*) is probably not what you want\");\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddStat(CSHA512& hasher, const struct stat& sb)\n+{\n+    hasher << sb.st_dev << sb.st_ino << sb.st_mode << sb.st_nlink << sb.st_uid << sb.st_gid << sb.st_size << sb.st_blksize << sb.st_blocks << sb.st_atime << sb.st_mtime << sb.st_ctime;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r345533727",
      "id" : 345533727,
      "in_reply_to_id" : 345339937,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NTUzMzcyNw==",
      "original_commit_id" : "1d1200f6b2174896f55ed4509eb7e412cacd4e7d",
      "original_position" : 143,
      "path" : "src/randomenv.cpp",
      "position" : null,
      "pull_request_review_id" : 315955443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-13T01:42:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/345533727",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "utACK d1c02775aa74a0610809ac54bb241ddad61d2d8c. Certainly no longer measuring the time elapsed between a 1ms sleep (which got removed in the latest change) is a fair tradeoff for adding about 2 million other actually-higher-entropy bits :).",
      "created_at" : "2019-11-13T01:44:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-553198817",
      "id" : 553198817,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1MzE5ODgxNw==",
      "updated_at" : "2019-11-13T01:44:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/553198817",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've been testing d1c02775aa74a0610809ac54bb241ddad61d2d8c across various operating systems. Few logs for anyone who's interested. Will post a final review shortly.\r\n\r\n#### macOS 10.14.6\r\n```bash\r\n2019-11-13T18:24:03Z Feeding 1066350 bytes of environment data into RNG\r\n2019-11-13T18:25:03Z Feeding 216 bytes of dynamic environment data into RNG\r\n2019-11-13T18:26:03Z Feeding 216 bytes of dynamic environment data into RNG\r\n```\r\n\r\n#### OpenBSD 6.6\r\n```bash\r\n2019-11-13T19:21:17Z Feeding 9334 bytes of environment data into RNG\r\n2019-11-13T19:22:18Z Feeding 504 bytes of dynamic environment data into RNG\r\n2019-11-13T19:23:18Z Feeding 504 bytes of dynamic environment data into RNG\r\n```\r\n\r\n#### FreeBSD 12\r\n```bash\r\n2019-11-13T21:04:50Z Feeding 74253 bytes of environment data into RNG\r\n2019-11-13T21:05:51Z Feeding 66068 bytes of dynamic environment data into RNG\r\n2019-11-13T21:06:51Z Feeding 66068 bytes of dynamic environment data into RNG\r\n```\r\n\r\n#### Windows 10 WSL\r\n```bash\r\n2019-11-13T23:05:00Z Feeding 435111 bytes of environment data into RNG\r\n2019-11-13T23:06:00Z Feeding 48 bytes of dynamic environment data into RNG\r\n2019-11-13T23:07:00Z Feeding 48 bytes of dynamic environment data into RNG\r\n```\r\n\r\n#### Windows 10 MSVC\r\n```bash\r\n2019-11-13T23:16:08Z Feeding 378764 bytes of environment data into RNG\r\n2019-11-13T23:17:08Z Feeding 48 bytes of dynamic environment data into RNG\r\n2019-11-13T23:18:08Z Feeding 48 bytes of dynamic environment data into RNG\r\n```\r\n\r\n#### NetBSD 8.1\r\n```bash\r\n2019-11-13T23:50:05Z Feeding 35503 bytes of environment data into RNG\r\n2019-11-13T23:51:05Z Feeding 28268 bytes of dynamic environment data into RNG\r\n2019-11-13T23:52:05Z Feeding 28268 bytes of dynamic environment data into RNG\r\n```\r\n\r\n#### Alpine\r\n```bash\r\n2019-11-14T00:45:33Z Feeding 23631 bytes of environment data into RNG\r\n2019-11-14T00:46:33Z Feeding 14196 bytes of dynamic environment data into RNG\r\n2019-11-14T00:47:33Z Feeding 14206 bytes of dynamic environment data into RNG\r\n2019-11-14T00:48:33Z Feeding 14208 bytes of dynamic environment data into RNG\r\n2019-11-14T00:49:33Z Feeding 14211 bytes of dynamic environment data into RNG\r\n```\r\n\r\n#### Debian 10\r\n```bash\r\n2019-11-14T00:21:13Z Feeding 23714 bytes of environment data into RNG\r\n2019-11-14T00:22:13Z Feeding 13980 bytes of dynamic environment data into RNG\r\n2019-11-14T00:23:13Z Feeding 13983 bytes of dynamic environment data into RNG\r\n2019-11-14T00:24:13Z Feeding 13991 bytes of dynamic environment data into RNG\r\n2019-11-14T00:25:13Z Feeding 13988 bytes of dynamic environment data into RNG\r\n2019-11-14T00:26:13Z Feeding 13993 bytes of dynamic environment data into RNG\r\n2019-11-14T00:27:13Z Feeding 14024 bytes of dynamic environment data into RNG\r\n```",
      "created_at" : "2019-11-14T01:10:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#issuecomment-553677392",
      "id" : 553677392,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17270",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1MzY3NzM5Mg==",
      "updated_at" : "2019-11-14T01:10:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/553677392",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r346088506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/346088506"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Using `__MACH__` here and above is unusual for a our codebase, we use `MAC_OSX` throughout. Also `__MACH__` by itself isn't necessarily macOS, looks like if you were to use it you'd want to couple it with `__APPLE__`.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-14T01:30:12Z",
      "diff_hunk" : "@@ -0,0 +1,508 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_SYSCTL\n+#include <sys/sysctl.h>\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    static_assert(!std::is_same<typename std::decay<T>::type, char*>::value, \"Calling operator<<(CSHA512, char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, unsigned char*>::value, \"Calling operator<<(CSHA512, unsigned char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const char*>::value, \"Calling operator<<(CSHA512, const char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const unsigned char*>::value, \"Calling operator<<(CSHA512, const unsigned char*) is probably not what you want\");\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb = {};\n+    int f = open(path, O_RDONLY);\n+    size_t total = 0;\n+    if (f != -1) {\n+        unsigned char fbuf[4096];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) hasher << sb;\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            total += n;\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf) && total < 1048576); // Read only the first 1 Mbyte\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb = {};\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher << sb;\n+    }\n+}\n+#endif\n+\n+#if HAVE_SYSCTL\n+template<int... S>\n+void AddSysctl(CSHA512& hasher)\n+{\n+    int CTL[sizeof...(S)] = {S...};\n+    unsigned char buffer[65536];\n+    size_t siz = 65536;\n+    int ret = sysctl(CTL, sizeof...(S), buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher << sizeof(CTL);\n+        hasher.Write((const unsigned char*)CTL, sizeof(CTL));\n+        if (siz > sizeof(buffer)) siz = sizeof(buffer);\n+        hasher << siz;\n+        hasher.Write(buffer, siz);\n+    }\n+}\n+#endif\n+\n+#ifdef HAVE_GETCPUID\n+void inline AddCPUID(CSHA512& hasher, uint32_t leaf, uint32_t subleaf, uint32_t& ax, uint32_t& bx, uint32_t& cx, uint32_t& dx)\n+{\n+    GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+    hasher << leaf << subleaf << ax << bx << cx << dx;\n+}\n+\n+void AddAllCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    // Iterate over all standard leaves\n+    AddCPUID(hasher, 0, 0, ax, bx, cx, dx); // Returns max leaf in ax\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            AddCPUID(hasher, leaf, subleaf, ax, bx, cx, dx);\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+    // Iterate over all extended leaves\n+    AddCPUID(hasher, 0x80000000, 0, ax, bx, cx, dx); // Returns max extended leaf in ax\n+    uint32_t ext_max = ax;\n+    for (uint32_t leaf = 0x80000001; leaf <= ext_max; ++leaf) {\n+        AddCPUID(hasher, leaf, 0, ax, bx, cx, dx);\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+    // Various clocks\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifndef __MACH__",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r346088506",
      "id" : 346088506,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NjA4ODUwNg==",
      "original_commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "original_position" : 230,
      "path" : "src/randomenv.cpp",
      "position" : 230,
      "pull_request_review_id" : 316664778,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-14T01:58:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/346088506",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r346090606"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/346090606"
         }
      },
      "author_association" : "MEMBER",
      "body" : "After #16392 (bumping our SDK and minimum required macOS to 10.12), `clock_gettime`, `CLOCK_REALTIME` and `CLOCK_MONOTONIC` will be available to use on macOS. Not necessarily anything that needs to change here now, but the potential to simplify this later.",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2019-11-14T01:39:52Z",
      "diff_hunk" : "@@ -0,0 +1,508 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_SYSCTL\n+#include <sys/sysctl.h>\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;\n+\n+namespace {\n+\n+void RandAddSeedPerfmon(CSHA512& hasher)\n+{\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static std::atomic<std::chrono::seconds> last_perfmon{std::chrono::seconds{0}};\n+    auto last_time = last_perfmon.load();\n+    auto current_time = GetTime<std::chrono::seconds>();\n+    if (current_time < last_time + std::chrono::minutes{10}) return;\n+    last_perfmon = current_time;\n+\n+    std::vector<unsigned char> vData(250000, 0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true) {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS) {\n+        hasher.Write(vData.data(), nSize);\n+        memory_cleanse(vData.data(), nSize);\n+    } else {\n+        // Performance data is only a best-effort attempt at improving the\n+        // situation when the OS randomness (and other sources) aren't\n+        // adequate. As a result, failure to read it is isn't considered critical,\n+        // so we don't call RandFailure().\n+        // TODO: Add logging when the logger is made functional before global\n+        // constructors have been invoked.\n+    }\n+#endif\n+}\n+\n+/** Helper to easily feed data into a CSHA512.\n+ *\n+ * Note that this does not serialize the passed object (like stream.h's << operators do).\n+ * Its raw memory representation is used directly.\n+ */\n+template<typename T>\n+CSHA512& operator<<(CSHA512& hasher, const T& data) {\n+    static_assert(!std::is_same<typename std::decay<T>::type, char*>::value, \"Calling operator<<(CSHA512, char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, unsigned char*>::value, \"Calling operator<<(CSHA512, unsigned char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const char*>::value, \"Calling operator<<(CSHA512, const char*) is probably not what you want\");\n+    static_assert(!std::is_same<typename std::decay<T>::type, const unsigned char*>::value, \"Calling operator<<(CSHA512, const unsigned char*) is probably not what you want\");\n+    hasher.Write((const unsigned char*)&data, sizeof(data));\n+    return hasher;\n+}\n+\n+#ifndef WIN32\n+void AddSockaddr(CSHA512& hasher, const struct sockaddr *addr)\n+{\n+    if (addr == nullptr) return;\n+    switch (addr->sa_family) {\n+    case AF_INET:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in));\n+        break;\n+    case AF_INET6:\n+        hasher.Write((const unsigned char*)addr, sizeof(sockaddr_in6));\n+        break;\n+    default:\n+        hasher.Write((const unsigned char*)&addr->sa_family, sizeof(addr->sa_family));\n+    }\n+}\n+\n+void AddFile(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb = {};\n+    int f = open(path, O_RDONLY);\n+    size_t total = 0;\n+    if (f != -1) {\n+        unsigned char fbuf[4096];\n+        int n;\n+        hasher.Write((const unsigned char*)&f, sizeof(f));\n+        if (fstat(f, &sb) == 0) hasher << sb;\n+        do {\n+            n = read(f, fbuf, sizeof(fbuf));\n+            if (n > 0) hasher.Write(fbuf, n);\n+            total += n;\n+            /* not bothering with EINTR handling. */\n+        } while (n == sizeof(fbuf) && total < 1048576); // Read only the first 1 Mbyte\n+        close(f);\n+    }\n+}\n+\n+void AddPath(CSHA512& hasher, const char *path)\n+{\n+    struct stat sb = {};\n+    if (stat(path, &sb) == 0) {\n+        hasher.Write((const unsigned char*)path, strlen(path) + 1);\n+        hasher << sb;\n+    }\n+}\n+#endif\n+\n+#if HAVE_SYSCTL\n+template<int... S>\n+void AddSysctl(CSHA512& hasher)\n+{\n+    int CTL[sizeof...(S)] = {S...};\n+    unsigned char buffer[65536];\n+    size_t siz = 65536;\n+    int ret = sysctl(CTL, sizeof...(S), buffer, &siz, nullptr, 0);\n+    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {\n+        hasher << sizeof(CTL);\n+        hasher.Write((const unsigned char*)CTL, sizeof(CTL));\n+        if (siz > sizeof(buffer)) siz = sizeof(buffer);\n+        hasher << siz;\n+        hasher.Write(buffer, siz);\n+    }\n+}\n+#endif\n+\n+#ifdef HAVE_GETCPUID\n+void inline AddCPUID(CSHA512& hasher, uint32_t leaf, uint32_t subleaf, uint32_t& ax, uint32_t& bx, uint32_t& cx, uint32_t& dx)\n+{\n+    GetCPUID(leaf, subleaf, ax, bx, cx, dx);\n+    hasher << leaf << subleaf << ax << bx << cx << dx;\n+}\n+\n+void AddAllCPUID(CSHA512& hasher)\n+{\n+    uint32_t ax, bx, cx, dx;\n+    // Iterate over all standard leaves\n+    AddCPUID(hasher, 0, 0, ax, bx, cx, dx); // Returns max leaf in ax\n+    uint32_t max = ax;\n+    for (uint32_t leaf = 1; leaf <= max; ++leaf) {\n+        for (uint32_t subleaf = 0;; ++subleaf) {\n+            AddCPUID(hasher, leaf, subleaf, ax, bx, cx, dx);\n+            // Iterate over subleaves for leaf 4, 11, 13\n+            if (leaf != 4 && leaf != 11 && leaf != 13) break;\n+            if ((leaf == 4 || leaf == 13) && ax == 0) break;\n+            if (leaf == 11 && (cx & 0xFF00) == 0) break;\n+        }\n+    }\n+    // Iterate over all extended leaves\n+    AddCPUID(hasher, 0x80000000, 0, ax, bx, cx, dx); // Returns max extended leaf in ax\n+    uint32_t ext_max = ax;\n+    for (uint32_t leaf = 0x80000001; leaf <= ext_max; ++leaf) {\n+        AddCPUID(hasher, leaf, 0, ax, bx, cx, dx);\n+    }\n+}\n+#endif\n+} // namespace\n+\n+void RandAddDynamicEnv(CSHA512& hasher)\n+{\n+    RandAddSeedPerfmon(hasher);\n+\n+    // Various clocks\n+#ifdef WIN32\n+    FILETIME ftime;\n+    GetSystemTimeAsFileTime(&ftime);\n+    hasher << ftime;\n+#else\n+#  ifndef __MACH__\n+    // On non-MacOS systems, use various clock_gettime() calls.\n+    struct timespec ts = {};\n+#    ifdef CLOCK_MONOTONIC\n+    clock_gettime(CLOCK_MONOTONIC, &ts);\n+    hasher << ts;\n+#    endif\n+#    ifdef CLOCK_REALTIME\n+    clock_gettime(CLOCK_REALTIME, &ts);\n+    hasher << ts;\n+#    endif\n+#    ifdef CLOCK_BOOTTIME\n+    clock_gettime(CLOCK_BOOTTIME, &ts);\n+    hasher << ts;\n+#    endif\n+#  else\n+    // On MacOS use mach_absolute_time (number of CPU ticks since boot) as a replacement for CLOCK_MONOTONIC,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r346090606",
      "id" : 346090606,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NjA5MDYwNg==",
      "original_commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "original_position" : 246,
      "path" : "src/randomenv.cpp",
      "position" : 246,
      "pull_request_review_id" : 316664778,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "updated_at" : "2019-11-14T01:58:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/346090606",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r946404577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/946404577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@sipa\r\nWhile compiling natively [on Windows with MSVC](https://github.com/bitcoin/bitcoin/pull/25797#issuecomment-1215983238), receiving [`C4273`](https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4273) warnings:\r\n```\r\n  randomenv.cpp\r\nC:\\Users\\hebasto\\bitcoin\\src\\randomenv.cpp(60,22): warning C4273: '__p__environ': inconsistent dll linkage [C:\\Users\\hebasto\\bitcoin\\build\\src\\util\\bitcoin_util.vcxproj]\r\nC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h(1158,29): message : see previous definition of '__p__environ' [C:\\Users\\hebasto\\bitcoin\\build\\src\\util\\bitcoin_util.\r\nvcxproj]\r\n```\r\n\r\n```\r\n  randomenv.cpp\r\nC:\\Users\\hebasto\\bitcoin\\src\\randomenv.cpp(60,22): warning C4273: '__p__environ': inconsistent dll linkage [C:\\Users\\hebasto\\bitcoin\\build\\src\\kernel\\bitcoinkernel.vcxproj]\r\nC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h(1158,29): message : see previous definition of '__p__environ' [C:\\Users\\hebasto\\bitcoin\\build\\src\\kernel\\bitcoinkern\r\nel.vcxproj]\r\n```\r\n\r\nConsidering https://docs.microsoft.com/en-us/cpp/c-runtime-library/environ-wenviron, is this code correct for MSVC? \r\n",
      "commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "created_at" : "2022-08-16T07:01:29Z",
      "diff_hunk" : "@@ -0,0 +1,508 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <randomenv.h>\n+\n+#include <clientversion.h>\n+#include <compat/cpuid.h>\n+#include <crypto/sha512.h>\n+#include <support/cleanse.h>\n+#include <util/time.h> // for GetTime()\n+#ifdef WIN32\n+#include <compat.h> // for Windows API\n+#endif\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <climits>\n+#include <thread>\n+#include <vector>\n+\n+#include <stdint.h>\n+#include <string.h>\n+#ifndef WIN32\n+#include <sys/types.h> // must go before a number of other headers\n+#include <fcntl.h>\n+#include <netinet/in.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+#endif\n+#ifdef __MACH__\n+#include <mach/clock.h>\n+#include <mach/mach.h>\n+#include <mach/mach_time.h>\n+#endif\n+#if HAVE_DECL_GETIFADDRS\n+#include <ifaddrs.h>\n+#endif\n+#if HAVE_SYSCTL\n+#include <sys/sysctl.h>\n+#if HAVE_VM_VM_PARAM_H\n+#include <vm/vm_param.h>\n+#endif\n+#if HAVE_SYS_RESOURCES_H\n+#include <sys/resources.h>\n+#endif\n+#if HAVE_SYS_VMMETER_H\n+#include <sys/vmmeter.h>\n+#endif\n+#endif\n+#ifdef __linux__\n+#include <sys/auxv.h>\n+#endif\n+\n+//! Necessary on some platforms\n+extern char** environ;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17270#discussion_r946404577",
      "id" : 946404577,
      "line" : 66,
      "node_id" : "PRRC_kwDOABII5844aPzh",
      "original_commit_id" : "d1c02775aa74a0610809ac54bb241ddad61d2d8c",
      "original_line" : 66,
      "original_position" : 66,
      "original_start_line" : 65,
      "path" : "src/randomenv.cpp",
      "position" : 66,
      "pull_request_review_id" : 1073591053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17270",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/946404577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 65,
      "start_side" : "RIGHT",
      "updated_at" : "2022-08-16T07:01:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/946404577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   }
]
