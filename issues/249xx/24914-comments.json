[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#25991](https://github.com/bitcoin/bitcoin/pull/25991) (Wallet: Add foreign_outputs metadata to support CoinJoin transactions by luke-jr)\n* [#25909](https://github.com/bitcoin/bitcoin/pull/25909) (wallet: coverage for receiving txes with same id but different witness data by furszy)\n* [#25907](https://github.com/bitcoin/bitcoin/pull/25907) (wallet: rpc to add automatically generated descriptors by achow101)\n* [#25766](https://github.com/bitcoin/bitcoin/pull/25766) (wallet: Include a signature with encrypted keys to mitigate a wallet scam by achow101)\n* [#25722](https://github.com/bitcoin/bitcoin/pull/25722) (refactor: Use util::Result class for wallet loading by ryanofsky)\n* [#25620](https://github.com/bitcoin/bitcoin/pull/25620) (wallet: Introduce AddressBookManager by furszy)\n* [#25296](https://github.com/bitcoin/bitcoin/pull/25296) (Add DataStream without ser-type and ser-version and use it where possible by MarcoFalke)\n* [#23417](https://github.com/bitcoin/bitcoin/pull/23417) (wallet, spkm: Move key management from DescriptorScriptPubKeyMan to wallet level KeyManager by achow101)\n* [#22341](https://github.com/bitcoin/bitcoin/pull/22341) (rpc: add getxpub by Sjors)\n* [#20205](https://github.com/bitcoin/bitcoin/pull/20205) (wallet: Properly support a wallet id by achow101)\n* [#16545](https://github.com/bitcoin/bitcoin/pull/16545) (refactor: Implement missing error checking for ArgsManager flags by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-04-19T01:59:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1101917684",
      "id" : 1101917684,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585Bre30",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1101917684/reactions"
      },
      "updated_at" : "2022-09-23T12:29:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1101917684",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-04-26T16:33:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1110007668",
      "id" : 1110007668,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585CKV90",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1110007668/reactions"
      },
      "updated_at" : "2022-04-26T16:33:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1110007668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-05-02T08:13:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1114604312",
      "id" : 1114604312,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585Cb4MY",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1114604312/reactions"
      },
      "updated_at" : "2022-05-02T08:13:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1114604312",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Concept ACK",
      "created_at" : "2022-05-06T20:52:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1119999984",
      "id" : 1119999984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585Cwdfw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1119999984/reactions"
      },
      "updated_at" : "2022-05-06T20:52:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1119999984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91447896?v=4",
         "events_url" : "https://api.github.com/users/pk-b2/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pk-b2/followers",
         "following_url" : "https://api.github.com/users/pk-b2/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pk-b2/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pk-b2",
         "id" : 91447896,
         "login" : "pk-b2",
         "node_id" : "MDQ6VXNlcjkxNDQ3ODk2",
         "organizations_url" : "https://api.github.com/users/pk-b2/orgs",
         "received_events_url" : "https://api.github.com/users/pk-b2/received_events",
         "repos_url" : "https://api.github.com/users/pk-b2/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pk-b2/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pk-b2/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pk-b2"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r867213509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867213509"
         }
      },
      "author_association" : "NONE",
      "body" : "```\r\n> explain query plan SELECT key, value FROM main WHERE key >= ? AND key < ?\r\n```\r\n\r\nVerified that this uses an index avoiding a table scan\r\n\r\n```\r\nSEARCH TABLE main USING INDEX sqlite_autoindex_main_1 (key>? AND key<?)`\r\n```",
      "commit_id" : "3a27791244e75dd9836f18d58ffd2355e5ea4f88",
      "created_at" : "2022-05-06T21:00:55Z",
      "diff_hunk" : "@@ -506,10 +494,70 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+    if (!cursor) return nullptr;\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"SQLiteDatabase: Failed to setup cursor SQL statement: %s\\n\", sqlite3_errstr(res)));\n+    }\n+\n+    return cursor;\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));\n+    }\n+\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>(start_range, end_range);\n+    if (!cursor) return nullptr;\n+\n+    const char* stmt_text = \"SELECT key, value FROM main WHERE key >= ? AND key < ?\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r867213509",
      "id" : 867213509,
      "line" : 550,
      "node_id" : "PRRC_kwDOABII584zsKDF",
      "original_commit_id" : "3a27791244e75dd9836f18d58ffd2355e5ea4f88",
      "original_line" : 550,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 105,
      "pull_request_review_id" : 965184731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867213509/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-06T21:00:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867213509",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91447896?v=4",
         "events_url" : "https://api.github.com/users/pk-b2/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pk-b2/followers",
         "following_url" : "https://api.github.com/users/pk-b2/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pk-b2/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pk-b2",
         "id" : 91447896,
         "login" : "pk-b2",
         "node_id" : "MDQ6VXNlcjkxNDQ3ODk2",
         "organizations_url" : "https://api.github.com/users/pk-b2/orgs",
         "received_events_url" : "https://api.github.com/users/pk-b2/received_events",
         "repos_url" : "https://api.github.com/users/pk-b2/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pk-b2/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pk-b2/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pk-b2"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r867214239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867214239"
         }
      },
      "author_association" : "NONE",
      "body" : "ð Like that approach",
      "commit_id" : "3a27791244e75dd9836f18d58ffd2355e5ea4f88",
      "created_at" : "2022-05-06T21:02:23Z",
      "diff_hunk" : "@@ -506,10 +494,70 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+    if (!cursor) return nullptr;\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"SQLiteDatabase: Failed to setup cursor SQL statement: %s\\n\", sqlite3_errstr(res)));\n+    }\n+\n+    return cursor;\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r867214239",
      "id" : 867214239,
      "line" : 545,
      "node_id" : "PRRC_kwDOABII584zsKOf",
      "original_commit_id" : "3a27791244e75dd9836f18d58ffd2355e5ea4f88",
      "original_line" : 545,
      "original_position" : 100,
      "original_start_line" : 529,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 100,
      "pull_request_review_id" : 965185719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867214239/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 529,
      "start_side" : "RIGHT",
      "updated_at" : "2022-05-06T21:02:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867214239",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91447896?v=4",
         "events_url" : "https://api.github.com/users/pk-b2/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pk-b2/followers",
         "following_url" : "https://api.github.com/users/pk-b2/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pk-b2/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pk-b2",
         "id" : 91447896,
         "login" : "pk-b2",
         "node_id" : "MDQ6VXNlcjkxNDQ3ODk2",
         "organizations_url" : "https://api.github.com/users/pk-b2/orgs",
         "received_events_url" : "https://api.github.com/users/pk-b2/received_events",
         "repos_url" : "https://api.github.com/users/pk-b2/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pk-b2/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pk-b2/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pk-b2"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-05-12T21:16:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1125430536",
      "id" : 1125430536,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585DFLUI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1125430536/reactions"
      },
      "updated_at" : "2022-05-12T21:16:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1125430536",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-05-18T17:38:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1130301902",
      "id" : 1130301902,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585DXwnO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1130301902/reactions"
      },
      "updated_at" : "2022-05-18T17:38:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1130301902",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK on querying specifically what is needed from the database when loading. Maybe some day we don't even have to read all records into memory.",
      "created_at" : "2022-05-31T16:51:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1142381108",
      "id" : 1142381108,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585EF1o0",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1142381108/reactions"
      },
      "updated_at" : "2022-05-31T16:51:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1142381108",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r893727842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893727842"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "tiny nit: maybe `GetNewCursor()`?",
      "commit_id" : "c23dfc2dbe030c941b8c60fc7e3c91ee3565c247",
      "created_at" : "2022-06-09T16:34:00Z",
      "diff_hunk" : "@@ -696,13 +694,19 @@ bool BerkeleyBatch::ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool&\n     return true;\n }\n \n-void BerkeleyBatch::CloseCursor()\n+BerkeleyCursor::~BerkeleyCursor()\n {\n     if (!m_cursor) return;\n     m_cursor->close();\n     m_cursor = nullptr;\n }\n \n+std::unique_ptr<DatabaseCursor> BerkeleyBatch::GetCursor()\n+{\n+    if (!pdb) return nullptr;\n+    return std::make_unique<BerkeleyCursor>(m_database);\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r893727842",
      "id" : 893727842,
      "line" : 720,
      "node_id" : "PRRC_kwDOABII5841RTRi",
      "original_commit_id" : "950c94f5ccc024c633410d624e11f874f857543d",
      "original_line" : 708,
      "original_position" : 47,
      "original_start_line" : 704,
      "path" : "src/wallet/bdb.cpp",
      "position" : 47,
      "pull_request_review_id" : 1001663726,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893727842/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 716,
      "start_side" : "RIGHT",
      "updated_at" : "2022-06-09T17:52:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893727842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r893736353"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893736353"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in 950c94f5:\r\n\r\nProbably better an exception instead of an assertion (similar to what is being done in the SQLite method).",
      "commit_id" : "c23dfc2dbe030c941b8c60fc7e3c91ee3565c247",
      "created_at" : "2022-06-09T16:43:31Z",
      "diff_hunk" : "@@ -661,16 +661,14 @@ void BerkeleyDatabase::ReloadDbEnv()\n     env->ReloadDbEnv();\n }\n \n-bool BerkeleyBatch::StartCursor()\n+BerkeleyCursor::BerkeleyCursor(BerkeleyDatabase& database)\n {\n-    assert(!m_cursor);\n-    if (!pdb)\n-        return false;\n-    int ret = pdb->cursor(nullptr, &m_cursor, 0);\n-    return ret == 0;\n+    assert(database.m_db.get());\n+    int ret = database.m_db->cursor(nullptr, &m_cursor, 0);\n+    assert(ret == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r893736353",
      "id" : 893736353,
      "line" : 669,
      "node_id" : "PRRC_kwDOABII5841RVWh",
      "original_commit_id" : "950c94f5ccc024c633410d624e11f874f857543d",
      "original_line" : 668,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : 23,
      "pull_request_review_id" : 1001663726,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893736353/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-09T17:54:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893736353",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r893783634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893783634"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In 040fa33f:\r\n\r\nBad copy here, error is `DBErrors::CORRUPT`.",
      "commit_id" : "c23dfc2dbe030c941b8c60fc7e3c91ee3565c247",
      "created_at" : "2022-06-09T17:33:52Z",
      "diff_hunk" : "@@ -770,6 +770,19 @@ static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r893783634",
      "id" : 893783634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5841Rg5S",
      "original_commit_id" : "040fa33fcce7cb0ec00405ca750de01880c19b8a",
      "original_line" : 780,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 11,
      "pull_request_review_id" : 1001663726,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893783634/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-09T17:52:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/893783634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r900448270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/900448270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The original error is incorrect, it's supposed to be `TOO_NEW`.",
      "commit_id" : "c23dfc2dbe030c941b8c60fc7e3c91ee3565c247",
      "created_at" : "2022-06-17T19:22:41Z",
      "diff_hunk" : "@@ -770,6 +770,19 @@ static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r900448270",
      "id" : 900448270,
      "in_reply_to_id" : 893783634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5841q8AO",
      "original_commit_id" : "040fa33fcce7cb0ec00405ca750de01880c19b8a",
      "original_line" : 780,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 11,
      "pull_request_review_id" : 1010939699,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/900448270/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-17T19:22:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/900448270",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902769522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902769522"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In a1d8d563:\r\n\r\nShouldn't this be a direct `return DBErrors::CORRUPT` as it was before?\r\n(same for the other one at line 807)",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T15:31:01Z",
      "diff_hunk" : "@@ -828,12 +741,330 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+    std::string err;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    // Load unencrypted keys\n+    std::unique_ptr<DatabaseCursor> cursor = GetTypeCursor(batch, DBKeys::KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for unencrypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_keys = 0;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next unencrypted key record for wallet database\\n\");\n+            return DBErrors::CORRUPT;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == DBKeys::KEY);\n+        if (!LoadKey(pwallet, ssKey, ssValue, err)) {\n+            result = DBErrors::CORRUPT;\n+            pwallet->WalletLogPrintf(\"%s\\n\", err);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902769522",
      "id" : 902769522,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5841zyty",
      "original_commit_id" : "a1d8d563d0f2ae12889bcc9002f1a532fadc9acc",
      "original_line" : 516,
      "original_position" : 184,
      "original_start_line" : 780,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1013820695,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902769522/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-06-21T16:01:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902769522",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902777349"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902777349"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`num_keys` isn't being increased.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T15:38:06Z",
      "diff_hunk" : "@@ -828,12 +741,330 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+    std::string err;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    // Load unencrypted keys\n+    std::unique_ptr<DatabaseCursor> cursor = GetTypeCursor(batch, DBKeys::KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for unencrypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_keys = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902777349",
      "id" : 902777349,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5841z0oF",
      "original_commit_id" : "a1d8d563d0f2ae12889bcc9002f1a532fadc9acc",
      "original_line" : 501,
      "original_position" : 169,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1013820695,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902777349/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-21T16:01:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902777349",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902777939"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902777939"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`num_ckeys` isn't being increased.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T15:38:39Z",
      "diff_hunk" : "@@ -828,12 +741,330 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+    std::string err;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    // Load unencrypted keys\n+    std::unique_ptr<DatabaseCursor> cursor = GetTypeCursor(batch, DBKeys::KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for unencrypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_keys = 0;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next unencrypted key record for wallet database\\n\");\n+            return DBErrors::CORRUPT;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == DBKeys::KEY);\n+        if (!LoadKey(pwallet, ssKey, ssValue, err)) {\n+            result = DBErrors::CORRUPT;\n+            pwallet->WalletLogPrintf(\"%s\\n\", err);\n+        }\n+    }\n+    cursor.reset();\n+\n+    // Load encrypted keys\n+    cursor = GetTypeCursor(batch, DBKeys::CRYPTED_KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for crypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_ckeys = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902777939",
      "id" : 902777939,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5841z0xT",
      "original_commit_id" : "a1d8d563d0f2ae12889bcc9002f1a532fadc9acc",
      "original_line" : 529,
      "original_position" : 196,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1013820695,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902777939/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-21T16:01:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902777939",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902999240"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902999240"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, If you trace the code, it doesn't actually immediately return `DBErrors::CORRPUT`. Instead it does `result = DBErrors::CORRUPT`, continues with reading the rest of the records, and returns `result` towards the end.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T19:38:56Z",
      "diff_hunk" : "@@ -828,12 +741,330 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+    std::string err;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    // Load unencrypted keys\n+    std::unique_ptr<DatabaseCursor> cursor = GetTypeCursor(batch, DBKeys::KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for unencrypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_keys = 0;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next unencrypted key record for wallet database\\n\");\n+            return DBErrors::CORRUPT;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == DBKeys::KEY);\n+        if (!LoadKey(pwallet, ssKey, ssValue, err)) {\n+            result = DBErrors::CORRUPT;\n+            pwallet->WalletLogPrintf(\"%s\\n\", err);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r902999240",
      "id" : 902999240,
      "in_reply_to_id" : 902769522,
      "line" : null,
      "node_id" : "PRRC_kwDOABII58410qzI",
      "original_commit_id" : "a1d8d563d0f2ae12889bcc9002f1a532fadc9acc",
      "original_line" : 516,
      "original_position" : 184,
      "original_start_line" : 780,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1014147885,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902999240/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-06-21T19:38:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/902999240",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Also renamed `GetPrefixCursor` to `GetNewPrefixCursor`.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T19:47:13Z",
      "diff_hunk" : "@@ -696,13 +694,19 @@ bool BerkeleyBatch::ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool&\n     return true;\n }\n \n-void BerkeleyBatch::CloseCursor()\n+BerkeleyCursor::~BerkeleyCursor()\n {\n     if (!m_cursor) return;\n     m_cursor->close();\n     m_cursor = nullptr;\n }\n \n+std::unique_ptr<DatabaseCursor> BerkeleyBatch::GetCursor()\n+{\n+    if (!pdb) return nullptr;\n+    return std::make_unique<BerkeleyCursor>(m_database);\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005613",
      "id" : 903005613,
      "in_reply_to_id" : 893727842,
      "line" : null,
      "node_id" : "PRRC_kwDOABII58410sWt",
      "original_commit_id" : "950c94f5ccc024c633410d624e11f874f857543d",
      "original_line" : 716,
      "original_position" : 47,
      "original_start_line" : 704,
      "path" : "src/wallet/bdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1014157057,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005613/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-06-21T19:47:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005613",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005674"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005674"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T19:47:18Z",
      "diff_hunk" : "@@ -661,16 +661,14 @@ void BerkeleyDatabase::ReloadDbEnv()\n     env->ReloadDbEnv();\n }\n \n-bool BerkeleyBatch::StartCursor()\n+BerkeleyCursor::BerkeleyCursor(BerkeleyDatabase& database)\n {\n-    assert(!m_cursor);\n-    if (!pdb)\n-        return false;\n-    int ret = pdb->cursor(nullptr, &m_cursor, 0);\n-    return ret == 0;\n+    assert(database.m_db.get());\n+    int ret = database.m_db->cursor(nullptr, &m_cursor, 0);\n+    assert(ret == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005674",
      "id" : 903005674,
      "in_reply_to_id" : 893736353,
      "line" : 663,
      "node_id" : "PRRC_kwDOABII58410sXq",
      "original_commit_id" : "950c94f5ccc024c633410d624e11f874f857543d",
      "original_line" : 663,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : 99,
      "pull_request_review_id" : 1014157131,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005674/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-21T19:47:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005674",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005771"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T19:47:25Z",
      "diff_hunk" : "@@ -828,12 +741,330 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+    std::string err;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    // Load unencrypted keys\n+    std::unique_ptr<DatabaseCursor> cursor = GetTypeCursor(batch, DBKeys::KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for unencrypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_keys = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005771",
      "id" : 903005771,
      "in_reply_to_id" : 902777349,
      "line" : null,
      "node_id" : "PRRC_kwDOABII58410sZL",
      "original_commit_id" : "a1d8d563d0f2ae12889bcc9002f1a532fadc9acc",
      "original_line" : 501,
      "original_position" : 169,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1014157266,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005771/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-21T19:47:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005815"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-06-21T19:47:28Z",
      "diff_hunk" : "@@ -828,12 +741,330 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+    std::string err;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    // Load unencrypted keys\n+    std::unique_ptr<DatabaseCursor> cursor = GetTypeCursor(batch, DBKeys::KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for unencrypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_keys = 0;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next unencrypted key record for wallet database\\n\");\n+            return DBErrors::CORRUPT;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == DBKeys::KEY);\n+        if (!LoadKey(pwallet, ssKey, ssValue, err)) {\n+            result = DBErrors::CORRUPT;\n+            pwallet->WalletLogPrintf(\"%s\\n\", err);\n+        }\n+    }\n+    cursor.reset();\n+\n+    // Load encrypted keys\n+    cursor = GetTypeCursor(batch, DBKeys::CRYPTED_KEY);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for crypted keys\\n\");\n+        return DBErrors::CORRUPT;\n+    }\n+\n+    int num_ckeys = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r903005815",
      "id" : 903005815,
      "in_reply_to_id" : 902777939,
      "line" : null,
      "node_id" : "PRRC_kwDOABII58410sZ3",
      "original_commit_id" : "a1d8d563d0f2ae12889bcc9002f1a532fadc9acc",
      "original_line" : 529,
      "original_position" : 196,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1014157337,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005815/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-06-21T19:47:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/903005815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> What about abstracting the cursor creation, looped read and error handling into a generic function so we can get rid-off most of the boilerplate code?\r\n> \r\n> Quick example that could be extended to most of the flows: [furszy@8526a87](https://github.com/furszy/bitcoin-core/commit/8526a87cae04a3704d86a5157894d42ecaca2ab9)\r\n\r\nLooking into it.",
      "created_at" : "2022-06-21T19:47:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1162259558",
      "id" : 1162259558,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585FRqxm",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1162259558/reactions"
      },
      "updated_at" : "2022-06-21T19:47:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1162259558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've refactored the loading loop boilerplate into its own function.",
      "created_at" : "2022-06-22T00:49:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1162502096",
      "id" : 1162502096,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585FSl_Q",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1162502096/reactions"
      },
      "updated_at" : "2022-06-22T00:49:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1162502096",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "```\r\nwallet/walletdb.cpp:912:18: error: reading variable 'm_address_book' requires holding mutex 'pwallet->cs_wallet' [-Werror,-Wthread-safety-analysis]\r\n        pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);",
      "created_at" : "2022-06-22T05:30:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1162659653",
      "id" : 1162659653,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585FTMdF",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1162659653/reactions"
      },
      "updated_at" : "2022-06-22T05:30:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1162659653",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-06-30T16:47:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1171454651",
      "id" : 1171454651,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585F0vq7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1171454651/reactions"
      },
      "updated_at" : "2022-06-30T16:47:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1171454651",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Patch for the [ci error](https://github.com/bitcoin/bitcoin/pull/24914/checks?check_run_id=7140018071) \"requires holding mutex 'pwallet->cs_wallet'\": https://github.com/furszy/bitcoin/commit/b3c51af13a04eaf3a374f778dd0858ad128aa512",
      "created_at" : "2022-07-06T03:06:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1175727634",
      "id" : 1175727634,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585GFC4S",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1175727634/reactions"
      },
      "updated_at" : "2022-07-06T03:06:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1175727634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915201717"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915201717"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "tiny nit:\r\n```suggestion\r\n        LogPrintf(\"%s: Unable to execute cursor step: %s\\n\", __func__, sqlite3_errstr(res));\r\n```",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-06T19:51:19Z",
      "diff_hunk" : "@@ -472,27 +470,17 @@ bool SQLiteBatch::HasKey(CDataStream&& key)\n     return res == SQLITE_ROW;\n }\n \n-bool SQLiteBatch::StartCursor()\n-{\n-    assert(!m_cursor_init);\n-    if (!m_database.m_db) return false;\n-    m_cursor_init = true;\n-    return true;\n-}\n-\n-bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& complete)\n+bool SQLiteCursor::Next(CDataStream& key, CDataStream& value, bool& complete)\n {\n     complete = false;\n \n-    if (!m_cursor_init) return false;\n-\n     int res = sqlite3_step(m_cursor_stmt);\n     if (res == SQLITE_DONE) {\n         complete = true;\n         return true;\n     }\n     if (res != SQLITE_ROW) {\n-        LogPrintf(\"SQLiteBatch::ReadAtCursor: Unable to execute cursor step: %s\\n\", sqlite3_errstr(res));\n+        LogPrintf(\"SQLiteCursor::Next: Unable to execute cursor step: %s\\n\", sqlite3_errstr(res));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915201717",
      "id" : 915201717,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842jN61",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 483,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915201717/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915201717",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915202937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915202937"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should log `SQLiteCursor` now, not `SQLiteBatch`.\r\n```suggestion\r\n        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\", __func__, sqlite3_errstr(res));\r\n```",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-06T19:52:57Z",
      "diff_hunk" : "@@ -506,10 +494,30 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915202937",
      "id" : 915202937,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842jON5",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 503,
      "original_position" : 58,
      "original_start_line" : 502,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915202937/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915202937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915204516"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915204516"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "could delete this line, `m_cursor` will never be null.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-06T19:55:07Z",
      "diff_hunk" : "@@ -690,13 +688,19 @@ bool BerkeleyBatch::ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool&\n     return true;\n }\n \n-void BerkeleyBatch::CloseCursor()\n+BerkeleyCursor::~BerkeleyCursor()\n {\n     if (!m_cursor) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915204516",
      "id" : 915204516,
      "line" : 707,
      "node_id" : "PRRC_kwDOABII5842jOmk",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 707,
      "original_position" : 38,
      "original_start_line" : 691,
      "path" : "src/wallet/bdb.cpp",
      "position" : 146,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915204516/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 705,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915204516",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915208527"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915208527"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: what about making the cursor private and passing a `sqlite3_stmt` pointer to the constructor?",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-06T20:00:37Z",
      "diff_hunk" : "@@ -14,19 +14,27 @@ struct bilingual_str;\n namespace wallet {\n class SQLiteDatabase;\n \n+class SQLiteCursor : public DatabaseCursor\n+{\n+public:\n+    sqlite3_stmt* m_cursor_stmt{nullptr};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915208527",
      "id" : 915208527,
      "line" : 21,
      "node_id" : "PRRC_kwDOABII5842jPlP",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 21,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 8,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915208527/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915208527",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915211634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915211634"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: this line can be removed.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-06T20:04:53Z",
      "diff_hunk" : "@@ -506,10 +494,30 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+    if (!cursor) return nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915211634",
      "id" : 915211634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842jQVy",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 511,
      "original_position" : 66,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915211634/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915211634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915214759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915214759"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n             \"%s: Failed to setup cursor SQL statement: %s\\n\", __func__ sqlite3_errstr(res)));\r\n```\r\n",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-06T20:09:24Z",
      "diff_hunk" : "@@ -506,10 +494,30 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+    if (!cursor) return nullptr;\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"SQLiteDatabase: Failed to setup cursor SQL statement: %s\\n\", sqlite3_errstr(res)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915214759",
      "id" : 915214759,
      "line" : 556,
      "node_id" : "PRRC_kwDOABII5842jRGn",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 556,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 115,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915214759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915214759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915838986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915838986"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\ncould default initialize `m_first` in the field declaration.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T12:54:35Z",
      "diff_hunk" : "@@ -655,7 +655,8 @@ void BerkeleyDatabase::ReloadDbEnv()\n     env->ReloadDbEnv();\n }\n \n-BerkeleyCursor::BerkeleyCursor(BerkeleyDatabase& database)\n+BerkeleyCursor::BerkeleyCursor(BerkeleyDatabase& database, Span<std::byte> prefix)\n+    : m_key_prefix(prefix.begin(), prefix.end()), m_first(true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915838986",
      "id" : 915838986,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842lpgK",
      "original_commit_id" : "72089765046bff6ade39f2c4f7763da9467b1494",
      "original_line" : 659,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915838986/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915838986",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915997364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915997364"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In 72089765:\r\n\r\nWith this code, at the end of the range, `Next` returns one extra element pair that is not part of the range set. So, if the `complete` flag is not checked by the caller first and the `ssValue` tries to be unserialized, a runtime error will be thrown (different value type).\r\n\r\nWould suggest to move this block above the `ssKey` and `ssValue` return values sets; so the function doesn't return elements that aren't in the filtered range, and directly return false:\r\n\r\n```c++\r\nSpan<const std::byte> raw_key = {AsBytePtr(datKey.get_data()), datKey.get_size()};\r\nif (!m_key_prefix.empty() && std::mismatch(raw_key.begin(), raw_key.end(), m_key_prefix.begin(), m_key_prefix.end()).second != m_key_prefix.end()) {\r\n    complete = true;\r\n    return false;\r\n}\r\n\r\nssKey.SetType(SER_DISK);\r\nssKey.clear();\r\nssKey.write(raw_key);\r\n// bla bla, all good..\r\nreturn true;\r\n```\r\n\r\nCommit here: https://github.com/furszy/bitcoin/commit/e4b37e82ed19ff103f295ac5897e33e80e2f0679",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T15:17:36Z",
      "diff_hunk" : "@@ -685,6 +692,11 @@ bool BerkeleyCursor::Next(CDataStream& ssKey, CDataStream& ssValue, bool& comple\n     ssValue.SetType(SER_DISK);\n     ssValue.clear();\n     ssValue.write({AsBytePtr(datValue.get_data()), datValue.get_size()});\n+\n+    if (!m_key_prefix.empty() && std::mismatch(ssKey.begin(), ssKey.end(), m_key_prefix.begin(), m_key_prefix.end()).second != m_key_prefix.end()) {\n+        complete = true;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r915997364",
      "id" : 915997364,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842mQK0",
      "original_commit_id" : "72089765046bff6ade39f2c4f7763da9467b1494",
      "original_line" : 698,
      "original_position" : 35,
      "original_start_line" : 696,
      "path" : "src/wallet/bdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1030621221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915997364/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-07T16:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/915997364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916120588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916120588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I tried doing that but kept running into issues with allocating the memory for it as the underlying object would have to survive the scope in which it was originally created. It was just easier to do it in the struct directly.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:30:28Z",
      "diff_hunk" : "@@ -14,19 +14,27 @@ struct bilingual_str;\n namespace wallet {\n class SQLiteDatabase;\n \n+class SQLiteCursor : public DatabaseCursor\n+{\n+public:\n+    sqlite3_stmt* m_cursor_stmt{nullptr};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916120588",
      "id" : 916120588,
      "in_reply_to_id" : 915208527,
      "line" : 21,
      "node_id" : "PRRC_kwDOABII5842muQM",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 21,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 8,
      "pull_request_review_id" : 1031933364,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916120588/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T17:32:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916120588",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916123506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916123506"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Leaving it as belt-and-suspenders in case something happens to it in the future.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:34:13Z",
      "diff_hunk" : "@@ -690,13 +688,19 @@ bool BerkeleyBatch::ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool&\n     return true;\n }\n \n-void BerkeleyBatch::CloseCursor()\n+BerkeleyCursor::~BerkeleyCursor()\n {\n     if (!m_cursor) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916123506",
      "id" : 916123506,
      "in_reply_to_id" : 915204516,
      "line" : 707,
      "node_id" : "PRRC_kwDOABII5842mu9y",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 707,
      "original_position" : 38,
      "original_start_line" : 691,
      "path" : "src/wallet/bdb.cpp",
      "position" : 146,
      "pull_request_review_id" : 1031937519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916123506/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 705,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-07T17:34:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916123506",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138045"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:52:12Z",
      "diff_hunk" : "@@ -472,27 +470,17 @@ bool SQLiteBatch::HasKey(CDataStream&& key)\n     return res == SQLITE_ROW;\n }\n \n-bool SQLiteBatch::StartCursor()\n-{\n-    assert(!m_cursor_init);\n-    if (!m_database.m_db) return false;\n-    m_cursor_init = true;\n-    return true;\n-}\n-\n-bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& complete)\n+bool SQLiteCursor::Next(CDataStream& key, CDataStream& value, bool& complete)\n {\n     complete = false;\n \n-    if (!m_cursor_init) return false;\n-\n     int res = sqlite3_step(m_cursor_stmt);\n     if (res == SQLITE_DONE) {\n         complete = true;\n         return true;\n     }\n     if (res != SQLITE_ROW) {\n-        LogPrintf(\"SQLiteBatch::ReadAtCursor: Unable to execute cursor step: %s\\n\", sqlite3_errstr(res));\n+        LogPrintf(\"SQLiteCursor::Next: Unable to execute cursor step: %s\\n\", sqlite3_errstr(res));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138045",
      "id" : 916138045,
      "in_reply_to_id" : 915201717,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842myg9",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 483,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1031959758,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138045/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T17:52:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138045",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138094"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138094"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:52:16Z",
      "diff_hunk" : "@@ -506,10 +494,30 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138094",
      "id" : 916138094,
      "in_reply_to_id" : 915202937,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842myhu",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 503,
      "original_position" : 58,
      "original_start_line" : 502,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1031959911,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138094/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-07T17:52:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138094",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138191"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138191"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:52:23Z",
      "diff_hunk" : "@@ -506,10 +494,30 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+    if (!cursor) return nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138191",
      "id" : 916138191,
      "in_reply_to_id" : 915211634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842myjP",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 511,
      "original_position" : 66,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1031960169,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138191/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T17:52:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138191",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138244"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138244"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:52:27Z",
      "diff_hunk" : "@@ -506,10 +494,30 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+    if (!cursor) return nullptr;\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"SQLiteDatabase: Failed to setup cursor SQL statement: %s\\n\", sqlite3_errstr(res)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138244",
      "id" : 916138244,
      "in_reply_to_id" : 915214759,
      "line" : 556,
      "node_id" : "PRRC_kwDOABII5842mykE",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 556,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 115,
      "pull_request_review_id" : 1031960327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138244/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T17:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138244",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:52:31Z",
      "diff_hunk" : "@@ -655,7 +655,8 @@ void BerkeleyDatabase::ReloadDbEnv()\n     env->ReloadDbEnv();\n }\n \n-BerkeleyCursor::BerkeleyCursor(BerkeleyDatabase& database)\n+BerkeleyCursor::BerkeleyCursor(BerkeleyDatabase& database, Span<std::byte> prefix)\n+    : m_key_prefix(prefix.begin(), prefix.end()), m_first(true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138289",
      "id" : 916138289,
      "in_reply_to_id" : 915838986,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842mykx",
      "original_commit_id" : "72089765046bff6ade39f2c4f7763da9467b1494",
      "original_line" : 659,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1031960489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138289/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-07T17:52:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138289",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138519"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138519"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-07T17:52:48Z",
      "diff_hunk" : "@@ -685,6 +692,11 @@ bool BerkeleyCursor::Next(CDataStream& ssKey, CDataStream& ssValue, bool& comple\n     ssValue.SetType(SER_DISK);\n     ssValue.clear();\n     ssValue.write({AsBytePtr(datValue.get_data()), datValue.get_size()});\n+\n+    if (!m_key_prefix.empty() && std::mismatch(ssKey.begin(), ssKey.end(), m_key_prefix.begin(), m_key_prefix.end()).second != m_key_prefix.end()) {\n+        complete = true;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r916138519",
      "id" : 916138519,
      "in_reply_to_id" : 915997364,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842myoX",
      "original_commit_id" : "72089765046bff6ade39f2c4f7763da9467b1494",
      "original_line" : 698,
      "original_position" : 35,
      "original_start_line" : 696,
      "path" : "src/wallet/bdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1031961177,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138519/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-07T17:52:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/916138519",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@furszy Thanks for the review. I've pulled in your test commit.\r\n\r\nOn the topic of the return values for `Next`, I'm not a fan of the current interface and I think it could be improved/rewritten with optionals. Mainly the problem is distinguishing between an error and being done.",
      "created_at" : "2022-07-07T17:54:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1178002305",
      "id" : 1178002305,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585GNuOB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1178002305/reactions"
      },
      "updated_at" : "2022-07-07T17:54:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1178002305",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> On the topic of the return values for Next, I'm not a fan of the current interface and I think it could be improved/rewritten with optionals. Mainly the problem is distinguishing between an error and being done.\r\n\r\nProbably we could return a three states enum instead. So we can get rid of that ugly `complete` ref arg.\r\n(but yeah, no need to add it here)",
      "created_at" : "2022-07-08T12:38:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1178941634",
      "id" : 1178941634,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585GRTjC",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1178941634/reactions"
      },
      "updated_at" : "2022-07-08T12:39:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1178941634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922170911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922170911"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n    ssKey.write(raw_key);\r\n```",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T13:33:48Z",
      "diff_hunk" : "@@ -678,13 +685,20 @@ bool BerkeleyCursor::Next(CDataStream& ssKey, CDataStream& ssValue, bool& comple\n     else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n         return false;\n \n+    Span<const std::byte> raw_key = {AsBytePtr(datKey.get_data()), datKey.get_size()};\n+    if (!m_key_prefix.empty() && std::mismatch(raw_key.begin(), raw_key.end(), m_key_prefix.begin(), m_key_prefix.end()).second != m_key_prefix.end()) {\n+        complete = true;\n+        return false;\n+    }\n+\n     // Convert to streams\n     ssKey.SetType(SER_DISK);\n     ssKey.clear();\n     ssKey.write({AsBytePtr(datKey.get_data()), datKey.get_size()});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922170911",
      "id" : 922170911,
      "line" : 697,
      "node_id" : "PRRC_kwDOABII58429zYf",
      "original_commit_id" : "c704f8348820eeabf8e1230d81e026a14fd8b3fc",
      "original_line" : 697,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : 41,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922170911/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T19:19:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922170911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922172352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922172352"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "this change shouldn't be needed.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T13:35:30Z",
      "diff_hunk" : "@@ -187,11 +187,16 @@ class SafeDbt final\n \n class BerkeleyCursor : public DatabaseCursor\n {\n-private:\n+protected:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922172352",
      "id" : 922172352,
      "line" : 190,
      "node_id" : "PRRC_kwDOABII58429zvA",
      "original_commit_id" : "c704f8348820eeabf8e1230d81e026a14fd8b3fc",
      "original_line" : 190,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.h",
      "position" : 5,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922172352/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T19:19:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922172352",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922394666"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922394666"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: unnecessary set. `m_result` member is default initialized to `LOAD_OK`.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T17:49:17Z",
      "diff_hunk" : "@@ -828,12 +733,255 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    result.m_result = DBErrors::LOAD_OK;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922394666",
      "id" : 922394666,
      "line" : 492,
      "node_id" : "PRRC_kwDOABII5842-qAq",
      "original_commit_id" : "ba1d48a2939570ea369554ff790c12300e9fd7b1",
      "original_line" : 759,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 155,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922394666/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T19:19:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922394666",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922401748"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922401748"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`LoadRecords` now is logging this:\r\n```suggestion\r\n            err = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\";\r\n```",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T17:59:05Z",
      "diff_hunk" : "@@ -828,12 +733,255 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    result.m_result = DBErrors::LOAD_OK;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922401748",
      "id" : 922401748,
      "line" : 561,
      "node_id" : "PRRC_kwDOABII5842-rvU",
      "original_commit_id" : "ba1d48a2939570ea369554ff790c12300e9fd7b1",
      "original_line" : 821,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 217,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922401748/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T19:19:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922401748",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922403557"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922403557"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why not return early here?:\r\n```c++\r\nif (key_res.m_result != DBErrors::LOAD_OK) {\r\n    return key_res.m_result;\r\n}\r\n```\r\n\r\n(Same for the crypted keys)",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T18:01:54Z",
      "diff_hunk" : "@@ -828,12 +733,255 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    result.m_result = DBErrors::LOAD_OK;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922403557",
      "id" : 922403557,
      "line" : 540,
      "node_id" : "PRRC_kwDOABII5842-sLl",
      "original_commit_id" : "ba1d48a2939570ea369554ff790c12300e9fd7b1",
      "original_line" : 800,
      "original_position" : 196,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 196,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922403557/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T19:19:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922403557",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922436250"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922436250"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`LoadRecords` logs the corrupt errors.\r\n```suggestion\r\n                err = \"Error reading wallet database: descriptor unencrypted key CPubKey corrupt\\n\";\r\n```\r\n\r\n(Same for the other ones below)",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T18:46:46Z",
      "diff_hunk" : "@@ -974,6 +887,171 @@ static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch,\n     return result;\n }\n \n+template<typename... Args>\n+static CDataStream PrefixStream(const Args&... args)\n+{\n+    CDataStream prefix(0, 0);\n+    SerializeMany(prefix, args...);\n+    return prefix;\n+}\n+\n+static DBErrors LoadDescriptorWalletRecords(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load descriptor record\n+    int num_keys = 0;\n+    int num_ckeys= 0;\n+    LoadResult desc_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTOR,\n+        [&batch, &num_keys, &num_ckeys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint256 id;\n+        key >> id;\n+        WalletDescriptor desc;\n+        value >> desc;\n+        pwallet->LoadDescriptorScriptPubKeyMan(id, desc);\n+\n+        DescriptorCache cache;\n+\n+        // Get key cache for this descriptor\n+        CDataStream prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCACHE, id);\n+        LoadResult key_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            bool parent = true;\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            uint32_t der_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            // if the der_index exists, it's a derived xpub\n+            try\n+            {\n+                key >> der_index;\n+                parent = false;\n+            }\n+            catch (...) {}\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            if (parent) {\n+                cache.CacheParentExtPubKey(key_exp_index, xpub);\n+            } else {\n+                cache.CacheDerivedExtPubKey(key_exp_index, der_index, xpub);\n+            }\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Get last hardened cache for this descriptor\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORLHCACHE, id);\n+        LoadResult lh_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORLHCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            cache.CacheLastHardenedExtPubKey(key_exp_index, xpub);\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Set the cache for this descriptor\n+        auto spk_man = (DescriptorScriptPubKeyMan*)pwallet->GetScriptPubKeyMan(id);\n+        assert(spk_man);\n+        spk_man->SetCache(cache);\n+\n+        // Get unencrypted keys\n+        std::map<CKeyID, CKey> descriptor_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORKEY, id);\n+        LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORKEY, prefix,\n+            [&id, &num_keys, &descriptor_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey corrupt\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922436250",
      "id" : 922436250,
      "line" : 828,
      "node_id" : "PRRC_kwDOABII5842-0Ka",
      "original_commit_id" : "369a042c738f71c88038584ff392f4ac8121b087",
      "original_line" : 982,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 229,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922436250/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T19:19:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922436250",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922440904"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922440904"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Same as above here:\r\n```c++\r\nspk_man->AddCryptedKey(pubkey.GetID(), pubkey, privkey);\r\n```",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T18:54:01Z",
      "diff_hunk" : "@@ -974,6 +887,171 @@ static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch,\n     return result;\n }\n \n+template<typename... Args>\n+static CDataStream PrefixStream(const Args&... args)\n+{\n+    CDataStream prefix(0, 0);\n+    SerializeMany(prefix, args...);\n+    return prefix;\n+}\n+\n+static DBErrors LoadDescriptorWalletRecords(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load descriptor record\n+    int num_keys = 0;\n+    int num_ckeys= 0;\n+    LoadResult desc_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTOR,\n+        [&batch, &num_keys, &num_ckeys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint256 id;\n+        key >> id;\n+        WalletDescriptor desc;\n+        value >> desc;\n+        pwallet->LoadDescriptorScriptPubKeyMan(id, desc);\n+\n+        DescriptorCache cache;\n+\n+        // Get key cache for this descriptor\n+        CDataStream prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCACHE, id);\n+        LoadResult key_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            bool parent = true;\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            uint32_t der_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            // if the der_index exists, it's a derived xpub\n+            try\n+            {\n+                key >> der_index;\n+                parent = false;\n+            }\n+            catch (...) {}\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            if (parent) {\n+                cache.CacheParentExtPubKey(key_exp_index, xpub);\n+            } else {\n+                cache.CacheDerivedExtPubKey(key_exp_index, der_index, xpub);\n+            }\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Get last hardened cache for this descriptor\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORLHCACHE, id);\n+        LoadResult lh_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORLHCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            cache.CacheLastHardenedExtPubKey(key_exp_index, xpub);\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Set the cache for this descriptor\n+        auto spk_man = (DescriptorScriptPubKeyMan*)pwallet->GetScriptPubKeyMan(id);\n+        assert(spk_man);\n+        spk_man->SetCache(cache);\n+\n+        // Get unencrypted keys\n+        std::map<CKeyID, CKey> descriptor_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORKEY, id);\n+        LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORKEY, prefix,\n+            [&id, &num_keys, &descriptor_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            CKey privkey;\n+            CPrivKey pkey;\n+            uint256 hash;\n+\n+            num_keys++;\n+            value >> pkey;\n+            value >> hash;\n+\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> to_hash;\n+            to_hash.reserve(pubkey.size() + pkey.size());\n+            to_hash.insert(to_hash.end(), pubkey.begin(), pubkey.end());\n+            to_hash.insert(to_hash.end(), pkey.begin(), pkey.end());\n+\n+            if (Hash(to_hash) != hash)\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey/CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+\n+            if (!privkey.Load(pkey, pubkey, true))\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            descriptor_keys.insert(std::make_pair(pubkey.GetID(), privkey));\n+            return DBErrors::LOAD_OK;\n+        });\n+        num_keys = key_res.m_records;\n+\n+        // Get encrypted keys\n+        std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char>>> descriptor_crypt_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCKEY, id);\n+        LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCKEY, prefix,\n+            [&id, &num_ckeys, &descriptor_crypt_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor encrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            std::vector<unsigned char> privkey;\n+            value >> privkey;\n+            num_ckeys++;\n+\n+            descriptor_crypt_keys.insert(std::make_pair(pubkey.GetID(), std::make_pair(pubkey, privkey)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922440904",
      "id" : 922440904,
      "line" : 880,
      "node_id" : "PRRC_kwDOABII5842-1TI",
      "original_commit_id" : "369a042c738f71c88038584ff392f4ac8121b087",
      "original_line" : 1034,
      "original_position" : 281,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 281,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922440904/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T19:19:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922440904",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922442482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922442482"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "could remove this two loops, the map and vector need If the keys are added to the spkm inside each `LoadRecords` (check above, left a comment there).",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T18:56:25Z",
      "diff_hunk" : "@@ -974,6 +887,171 @@ static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch,\n     return result;\n }\n \n+template<typename... Args>\n+static CDataStream PrefixStream(const Args&... args)\n+{\n+    CDataStream prefix(0, 0);\n+    SerializeMany(prefix, args...);\n+    return prefix;\n+}\n+\n+static DBErrors LoadDescriptorWalletRecords(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load descriptor record\n+    int num_keys = 0;\n+    int num_ckeys= 0;\n+    LoadResult desc_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTOR,\n+        [&batch, &num_keys, &num_ckeys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint256 id;\n+        key >> id;\n+        WalletDescriptor desc;\n+        value >> desc;\n+        pwallet->LoadDescriptorScriptPubKeyMan(id, desc);\n+\n+        DescriptorCache cache;\n+\n+        // Get key cache for this descriptor\n+        CDataStream prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCACHE, id);\n+        LoadResult key_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            bool parent = true;\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            uint32_t der_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            // if the der_index exists, it's a derived xpub\n+            try\n+            {\n+                key >> der_index;\n+                parent = false;\n+            }\n+            catch (...) {}\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            if (parent) {\n+                cache.CacheParentExtPubKey(key_exp_index, xpub);\n+            } else {\n+                cache.CacheDerivedExtPubKey(key_exp_index, der_index, xpub);\n+            }\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Get last hardened cache for this descriptor\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORLHCACHE, id);\n+        LoadResult lh_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORLHCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            cache.CacheLastHardenedExtPubKey(key_exp_index, xpub);\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Set the cache for this descriptor\n+        auto spk_man = (DescriptorScriptPubKeyMan*)pwallet->GetScriptPubKeyMan(id);\n+        assert(spk_man);\n+        spk_man->SetCache(cache);\n+\n+        // Get unencrypted keys\n+        std::map<CKeyID, CKey> descriptor_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORKEY, id);\n+        LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORKEY, prefix,\n+            [&id, &num_keys, &descriptor_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            CKey privkey;\n+            CPrivKey pkey;\n+            uint256 hash;\n+\n+            num_keys++;\n+            value >> pkey;\n+            value >> hash;\n+\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> to_hash;\n+            to_hash.reserve(pubkey.size() + pkey.size());\n+            to_hash.insert(to_hash.end(), pubkey.begin(), pubkey.end());\n+            to_hash.insert(to_hash.end(), pkey.begin(), pkey.end());\n+\n+            if (Hash(to_hash) != hash)\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey/CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+\n+            if (!privkey.Load(pkey, pubkey, true))\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            descriptor_keys.insert(std::make_pair(pubkey.GetID(), privkey));\n+            return DBErrors::LOAD_OK;\n+        });\n+        num_keys = key_res.m_records;\n+\n+        // Get encrypted keys\n+        std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char>>> descriptor_crypt_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCKEY, id);\n+        LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCKEY, prefix,\n+            [&id, &num_ckeys, &descriptor_crypt_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor encrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            std::vector<unsigned char> privkey;\n+            value >> privkey;\n+            num_ckeys++;\n+\n+            descriptor_crypt_keys.insert(std::make_pair(pubkey.GetID(), std::make_pair(pubkey, privkey)));\n+            return DBErrors::LOAD_OK;\n+        });\n+        num_ckeys = ckey_res.m_records;\n+\n+        // Set the descriptor keys\n+        for (auto desc_key_pair : descriptor_keys) {\n+            spk_man->AddKey(desc_key_pair.first, desc_key_pair.second);\n+        }\n+        for (auto desc_key_pair : descriptor_crypt_keys) {\n+            spk_man->AddCryptedKey(desc_key_pair.first, desc_key_pair.second.first, desc_key_pair.second.second);\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922442482",
      "id" : 922442482,
      "line" : 891,
      "node_id" : "PRRC_kwDOABII5842-1ry",
      "original_commit_id" : "369a042c738f71c88038584ff392f4ac8121b087",
      "original_line" : 1045,
      "original_position" : 292,
      "original_start_line" : 1039,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 292,
      "pull_request_review_id" : 1040304045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922442482/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-15T19:19:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922442482",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922475618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922475618"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing `corrupted_tx = true` set here.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T19:51:45Z",
      "diff_hunk" : "@@ -1080,6 +1029,90 @@ static DBErrors LoadAddressBookRecords(CWallet* pwallet, DatabaseBatch& batch) E\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadTxRecords(CWallet* pwallet, DatabaseBatch& batch, std::vector<uint256> upgraded_txs, bool& any_unordered) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load tx record\n+    bool corrupted_tx = false;\n+    any_unordered = false;\n+    LoadResult tx_res = LoadRecords(pwallet, batch, DBKeys::TX,\n+        [&corrupted_tx, &any_unordered, &upgraded_txs] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        DBErrors result = DBErrors::LOAD_OK;\n+        uint256 hash;\n+        key >> hash;\n+        // LoadToWallet call below creates a new CWalletTx that fill_wtx\n+        // callback fills with transaction metadata.\n+        auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n+            if(!new_tx) {\n+                // There's some corruption here since the tx we just tried to load was already in the wallet.\n+                // We don't consider this type of corruption critical, and can fix it by removing tx data and\n+                // rescanning.\n+                pwallet->WalletLogPrintf(\"Error: Corrupt transaction found. This can be fixed by removing transactions from wallet and rescanning.\\n\");\n+                result = DBErrors::CORRUPT;\n+                return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922475618",
      "id" : 922475618,
      "line" : 964,
      "node_id" : "PRRC_kwDOABII5842-9xi",
      "original_commit_id" : "7ed39f6d344516cef2023fbfaeb99444b8c5c6d0",
      "original_line" : 1054,
      "original_position" : 98,
      "original_start_line" : 1052,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 98,
      "pull_request_review_id" : 1040744754,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922475618/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 962,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-15T19:52:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922475618",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922492905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922492905"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It is the retain the current behavior where we generally go through all the records in the wallet regardless of whether they are corrupt, and just report the worst result at the end. This allows us to check all of the records for corruption.",
      "commit_id" : "431904b5c317917fad4c5171bebb14620fd1edec",
      "created_at" : "2022-07-15T20:22:52Z",
      "diff_hunk" : "@@ -828,12 +733,255 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    result.m_result = DBErrors::LOAD_OK;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922492905",
      "id" : 922492905,
      "in_reply_to_id" : 922403557,
      "line" : 540,
      "node_id" : "PRRC_kwDOABII5842_B_p",
      "original_commit_id" : "ba1d48a2939570ea369554ff790c12300e9fd7b1",
      "original_line" : 800,
      "original_position" : 196,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 196,
      "pull_request_review_id" : 1040769618,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922492905/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T20:22:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922492905",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922570997"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922570997"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-07-15T23:12:01Z",
      "diff_hunk" : "@@ -678,13 +685,20 @@ bool BerkeleyCursor::Next(CDataStream& ssKey, CDataStream& ssValue, bool& comple\n     else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n         return false;\n \n+    Span<const std::byte> raw_key = {AsBytePtr(datKey.get_data()), datKey.get_size()};\n+    if (!m_key_prefix.empty() && std::mismatch(raw_key.begin(), raw_key.end(), m_key_prefix.begin(), m_key_prefix.end()).second != m_key_prefix.end()) {\n+        complete = true;\n+        return false;\n+    }\n+\n     // Convert to streams\n     ssKey.SetType(SER_DISK);\n     ssKey.clear();\n     ssKey.write({AsBytePtr(datKey.get_data()), datKey.get_size()});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922570997",
      "id" : 922570997,
      "in_reply_to_id" : 922170911,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842_VD1",
      "original_commit_id" : "c704f8348820eeabf8e1230d81e026a14fd8b3fc",
      "original_line" : 697,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1040880432,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922570997/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T23:12:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922570997",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571016"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571016"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-07-15T23:12:06Z",
      "diff_hunk" : "@@ -187,11 +187,16 @@ class SafeDbt final\n \n class BerkeleyCursor : public DatabaseCursor\n {\n-private:\n+protected:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571016",
      "id" : 922571016,
      "in_reply_to_id" : 922172352,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842_VEI",
      "original_commit_id" : "c704f8348820eeabf8e1230d81e026a14fd8b3fc",
      "original_line" : 190,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.h",
      "position" : null,
      "pull_request_review_id" : 1040880459,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571016/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T23:12:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571016",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571042"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571042"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-07-15T23:12:12Z",
      "diff_hunk" : "@@ -828,12 +733,255 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    result.m_result = DBErrors::LOAD_OK;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571042",
      "id" : 922571042,
      "in_reply_to_id" : 922394666,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842_VEi",
      "original_commit_id" : "ba1d48a2939570ea369554ff790c12300e9fd7b1",
      "original_line" : 759,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1040880495,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571042/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T23:12:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571042",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571322"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done here and elsewhere.",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-07-15T23:13:04Z",
      "diff_hunk" : "@@ -828,12 +733,255 @@ static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIV\n     return DBErrors::LOAD_OK;\n }\n \n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    result.m_result = DBErrors::LOAD_OK;\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571322",
      "id" : 922571322,
      "in_reply_to_id" : 922401748,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842_VI6",
      "original_commit_id" : "ba1d48a2939570ea369554ff790c12300e9fd7b1",
      "original_line" : 821,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1040880827,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571322/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T23:13:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571426"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-07-15T23:13:22Z",
      "diff_hunk" : "@@ -974,6 +887,171 @@ static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch,\n     return result;\n }\n \n+template<typename... Args>\n+static CDataStream PrefixStream(const Args&... args)\n+{\n+    CDataStream prefix(0, 0);\n+    SerializeMany(prefix, args...);\n+    return prefix;\n+}\n+\n+static DBErrors LoadDescriptorWalletRecords(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load descriptor record\n+    int num_keys = 0;\n+    int num_ckeys= 0;\n+    LoadResult desc_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTOR,\n+        [&batch, &num_keys, &num_ckeys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint256 id;\n+        key >> id;\n+        WalletDescriptor desc;\n+        value >> desc;\n+        pwallet->LoadDescriptorScriptPubKeyMan(id, desc);\n+\n+        DescriptorCache cache;\n+\n+        // Get key cache for this descriptor\n+        CDataStream prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCACHE, id);\n+        LoadResult key_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            bool parent = true;\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            uint32_t der_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            // if the der_index exists, it's a derived xpub\n+            try\n+            {\n+                key >> der_index;\n+                parent = false;\n+            }\n+            catch (...) {}\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            if (parent) {\n+                cache.CacheParentExtPubKey(key_exp_index, xpub);\n+            } else {\n+                cache.CacheDerivedExtPubKey(key_exp_index, der_index, xpub);\n+            }\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Get last hardened cache for this descriptor\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORLHCACHE, id);\n+        LoadResult lh_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORLHCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            cache.CacheLastHardenedExtPubKey(key_exp_index, xpub);\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Set the cache for this descriptor\n+        auto spk_man = (DescriptorScriptPubKeyMan*)pwallet->GetScriptPubKeyMan(id);\n+        assert(spk_man);\n+        spk_man->SetCache(cache);\n+\n+        // Get unencrypted keys\n+        std::map<CKeyID, CKey> descriptor_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORKEY, id);\n+        LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORKEY, prefix,\n+            [&id, &num_keys, &descriptor_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            CKey privkey;\n+            CPrivKey pkey;\n+            uint256 hash;\n+\n+            num_keys++;\n+            value >> pkey;\n+            value >> hash;\n+\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> to_hash;\n+            to_hash.reserve(pubkey.size() + pkey.size());\n+            to_hash.insert(to_hash.end(), pubkey.begin(), pubkey.end());\n+            to_hash.insert(to_hash.end(), pkey.begin(), pkey.end());\n+\n+            if (Hash(to_hash) != hash)\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey/CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+\n+            if (!privkey.Load(pkey, pubkey, true))\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            descriptor_keys.insert(std::make_pair(pubkey.GetID(), privkey));\n+            return DBErrors::LOAD_OK;\n+        });\n+        num_keys = key_res.m_records;\n+\n+        // Get encrypted keys\n+        std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char>>> descriptor_crypt_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCKEY, id);\n+        LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCKEY, prefix,\n+            [&id, &num_ckeys, &descriptor_crypt_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor encrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            std::vector<unsigned char> privkey;\n+            value >> privkey;\n+            num_ckeys++;\n+\n+            descriptor_crypt_keys.insert(std::make_pair(pubkey.GetID(), std::make_pair(pubkey, privkey)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571426",
      "id" : 922571426,
      "in_reply_to_id" : 922440904,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842_VKi",
      "original_commit_id" : "369a042c738f71c88038584ff392f4ac8121b087",
      "original_line" : 1034,
      "original_position" : 281,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1040880957,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571426/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-15T23:13:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571426",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571458"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571458"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-07-15T23:13:28Z",
      "diff_hunk" : "@@ -974,6 +887,171 @@ static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch,\n     return result;\n }\n \n+template<typename... Args>\n+static CDataStream PrefixStream(const Args&... args)\n+{\n+    CDataStream prefix(0, 0);\n+    SerializeMany(prefix, args...);\n+    return prefix;\n+}\n+\n+static DBErrors LoadDescriptorWalletRecords(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load descriptor record\n+    int num_keys = 0;\n+    int num_ckeys= 0;\n+    LoadResult desc_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTOR,\n+        [&batch, &num_keys, &num_ckeys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint256 id;\n+        key >> id;\n+        WalletDescriptor desc;\n+        value >> desc;\n+        pwallet->LoadDescriptorScriptPubKeyMan(id, desc);\n+\n+        DescriptorCache cache;\n+\n+        // Get key cache for this descriptor\n+        CDataStream prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCACHE, id);\n+        LoadResult key_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            bool parent = true;\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            uint32_t der_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            // if the der_index exists, it's a derived xpub\n+            try\n+            {\n+                key >> der_index;\n+                parent = false;\n+            }\n+            catch (...) {}\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            if (parent) {\n+                cache.CacheParentExtPubKey(key_exp_index, xpub);\n+            } else {\n+                cache.CacheDerivedExtPubKey(key_exp_index, der_index, xpub);\n+            }\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Get last hardened cache for this descriptor\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORLHCACHE, id);\n+        LoadResult lh_cache_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORLHCACHE, prefix,\n+            [&id, &cache] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            uint32_t key_exp_index;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> key_exp_index;\n+\n+            std::vector<unsigned char> ser_xpub(BIP32_EXTKEY_SIZE);\n+            value >> ser_xpub;\n+            CExtPubKey xpub;\n+            xpub.Decode(ser_xpub.data());\n+            cache.CacheLastHardenedExtPubKey(key_exp_index, xpub);\n+            return DBErrors::LOAD_OK;\n+        });\n+\n+        // Set the cache for this descriptor\n+        auto spk_man = (DescriptorScriptPubKeyMan*)pwallet->GetScriptPubKeyMan(id);\n+        assert(spk_man);\n+        spk_man->SetCache(cache);\n+\n+        // Get unencrypted keys\n+        std::map<CKeyID, CKey> descriptor_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORKEY, id);\n+        LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORKEY, prefix,\n+            [&id, &num_keys, &descriptor_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            CKey privkey;\n+            CPrivKey pkey;\n+            uint256 hash;\n+\n+            num_keys++;\n+            value >> pkey;\n+            value >> hash;\n+\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> to_hash;\n+            to_hash.reserve(pubkey.size() + pkey.size());\n+            to_hash.insert(to_hash.end(), pubkey.begin(), pubkey.end());\n+            to_hash.insert(to_hash.end(), pkey.begin(), pkey.end());\n+\n+            if (Hash(to_hash) != hash)\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPubKey/CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+\n+            if (!privkey.Load(pkey, pubkey, true))\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor unencrypted key CPrivKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            descriptor_keys.insert(std::make_pair(pubkey.GetID(), privkey));\n+            return DBErrors::LOAD_OK;\n+        });\n+        num_keys = key_res.m_records;\n+\n+        // Get encrypted keys\n+        std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char>>> descriptor_crypt_keys;\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCKEY, id);\n+        LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCKEY, prefix,\n+            [&id, &num_ckeys, &descriptor_crypt_keys] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint256 desc_id;\n+            CPubKey pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n+            if (!pubkey.IsValid())\n+            {\n+                pwallet->WalletLogPrintf(\"Error reading wallet database: descriptor encrypted key CPubKey corrupt\\n\");\n+                return DBErrors::CORRUPT;\n+            }\n+            std::vector<unsigned char> privkey;\n+            value >> privkey;\n+            num_ckeys++;\n+\n+            descriptor_crypt_keys.insert(std::make_pair(pubkey.GetID(), std::make_pair(pubkey, privkey)));\n+            return DBErrors::LOAD_OK;\n+        });\n+        num_ckeys = ckey_res.m_records;\n+\n+        // Set the descriptor keys\n+        for (auto desc_key_pair : descriptor_keys) {\n+            spk_man->AddKey(desc_key_pair.first, desc_key_pair.second);\n+        }\n+        for (auto desc_key_pair : descriptor_crypt_keys) {\n+            spk_man->AddCryptedKey(desc_key_pair.first, desc_key_pair.second.first, desc_key_pair.second.second);\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571458",
      "id" : 922571458,
      "in_reply_to_id" : 922442482,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842_VLC",
      "original_commit_id" : "369a042c738f71c88038584ff392f4ac8121b087",
      "original_line" : 1045,
      "original_position" : 292,
      "original_start_line" : 1039,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1040880997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571458/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-15T23:13:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571458",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571481"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-07-15T23:13:32Z",
      "diff_hunk" : "@@ -1080,6 +1029,90 @@ static DBErrors LoadAddressBookRecords(CWallet* pwallet, DatabaseBatch& batch) E\n     return DBErrors::LOAD_OK;\n }\n \n+static DBErrors LoadTxRecords(CWallet* pwallet, DatabaseBatch& batch, std::vector<uint256> upgraded_txs, bool& any_unordered) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load tx record\n+    bool corrupted_tx = false;\n+    any_unordered = false;\n+    LoadResult tx_res = LoadRecords(pwallet, batch, DBKeys::TX,\n+        [&corrupted_tx, &any_unordered, &upgraded_txs] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        DBErrors result = DBErrors::LOAD_OK;\n+        uint256 hash;\n+        key >> hash;\n+        // LoadToWallet call below creates a new CWalletTx that fill_wtx\n+        // callback fills with transaction metadata.\n+        auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n+            if(!new_tx) {\n+                // There's some corruption here since the tx we just tried to load was already in the wallet.\n+                // We don't consider this type of corruption critical, and can fix it by removing tx data and\n+                // rescanning.\n+                pwallet->WalletLogPrintf(\"Error: Corrupt transaction found. This can be fixed by removing transactions from wallet and rescanning.\\n\");\n+                result = DBErrors::CORRUPT;\n+                return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r922571481",
      "id" : 922571481,
      "in_reply_to_id" : 922475618,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842_VLZ",
      "original_commit_id" : "7ed39f6d344516cef2023fbfaeb99444b8c5c6d0",
      "original_line" : 961,
      "original_position" : 98,
      "original_start_line" : 1052,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1040881028,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571481/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-07-15T23:13:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/922571481",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> The `LoadRecords` of the `WALLETDESCRIPTOR` prefix is always returning `LOAD_OK` result even if the load internally failed (corrupted db).\r\n\r\nGood catch. I've added `result = std::max(result, res.m_result);` for each of these.",
      "created_at" : "2022-07-15T23:14:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1186015747",
      "id" : 1186015747,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585GsSoD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1186015747/reactions"
      },
      "updated_at" : "2022-07-15T23:14:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1186015747",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r946727807"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/946727807"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        m_cursor = GetNewCursor();\r\n```\r\nI think this `std::move` on a temporary isn't needed? The compiler says (commit 94584601f12c51b3a781c84536f6b56be1ea8077)\r\n```\r\nIn file included from ./wallet/walletdb.h:10:\r\n./wallet/db.h:109:20: warning: moving a temporary object prevents copy elision [-Wpessimizing-move]\r\n        m_cursor = std::move(GetNewCursor());\r\n                   ^\r\n./wallet/db.h:109:20: note: remove std::move call here\r\n        m_cursor = std::move(GetNewCursor());\r\n                   ^~~~~~~~~~              ~\r\n```",
      "commit_id" : "0ca1efcd748b5e6dd2c1fc286440e5a8ff5757d5",
      "created_at" : "2022-08-16T12:42:43Z",
      "diff_hunk" : "@@ -92,9 +103,21 @@ class DatabaseBatch\n         return HasKey(std::move(ssKey));\n     }\n \n-    virtual bool StartCursor() = 0;\n-    virtual bool ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool& complete) = 0;\n-    virtual void CloseCursor() = 0;\n+    virtual std::unique_ptr<DatabaseCursor> GetNewCursor() = 0;\n+    bool StartCursor()\n+    {\n+        m_cursor = std::move(GetNewCursor());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r946727807",
      "id" : 946727807,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5844bet_",
      "original_commit_id" : "94584601f12c51b3a781c84536f6b56be1ea8077",
      "original_line" : 109,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/wallet/db.h",
      "position" : 32,
      "pull_request_review_id" : 1074043688,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/946727807/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-16T13:37:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/946727807",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-09-13T16:35:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1245664275",
      "id" : 1245664275,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585KP1QT",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1245664275/reactions"
      },
      "updated_at" : "2022-09-13T16:35:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1245664275",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980023946"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980023946"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in 10cf25c112ff4ac7bcece87a821996004cec2b24, less verbose\r\n```suggestion\r\n    auto cursor = std::make_unique<SQLiteCursor>();\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:16:48Z",
      "diff_hunk" : "@@ -506,10 +497,69 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  __func__, sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980023946",
      "id" : 980023946,
      "line" : 514,
      "node_id" : "PRRC_kwDOABII5846afqK",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 514,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 73,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980023946/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980023946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980025026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980025026"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be, less verbose\r\n```suggestion\r\n    auto cursor = std::make_unique<SQLiteCursor>(start_range, end_range);\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:17:46Z",
      "diff_hunk" : "@@ -506,10 +497,69 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  __func__, sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"%s: Failed to setup cursor SQL statement: %s\\n\", __func__, sqlite3_errstr(res)));\n+    }\n+\n+    return cursor;\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));\n+    }\n+\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>(start_range, end_range);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980025026",
      "id" : 980025026,
      "line" : 549,
      "node_id" : "PRRC_kwDOABII5846af7C",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 549,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 108,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980025026/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980025026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980028053"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980028053"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in 10cf25c112ff4ac7bcece87a821996004cec2b24: I know this hasn't been done in other RAII classes but wouldn't it be better to delete copy and copy assignment operators to avoid potential double frees?",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:20:36Z",
      "diff_hunk" : "@@ -14,19 +14,36 @@ struct bilingual_str;\n namespace wallet {\n class SQLiteDatabase;\n \n+/** RAII class that provides a database cursor */\n+class SQLiteCursor : public DatabaseCursor",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980028053",
      "id" : 980028053,
      "line" : 18,
      "node_id" : "PRRC_kwDOABII5846agqV",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 18,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 5,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980028053/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980028053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980029822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980029822"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be\r\n```suggestion\r\n    explicit SQLiteCursor(const std::vector<std::byte>& start_range, const std::vector<std::byte>& end_range)\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:22:11Z",
      "diff_hunk" : "@@ -14,19 +14,36 @@ struct bilingual_str;\n namespace wallet {\n class SQLiteDatabase;\n \n+/** RAII class that provides a database cursor */\n+class SQLiteCursor : public DatabaseCursor\n+{\n+public:\n+    sqlite3_stmt* m_cursor_stmt{nullptr};\n+    // Copies of the prefix things for the prefix cursor.\n+    // Prevents SQLite from accessing temp variables for the prefix things.\n+    std::vector<std::byte> m_prefix_range_start;\n+    std::vector<std::byte> m_prefix_range_end;\n+\n+    explicit SQLiteCursor() {}\n+    explicit SQLiteCursor(std::vector<std::byte> start_range, std::vector<std::byte> end_range)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980029822",
      "id" : 980029822,
      "line" : 28,
      "node_id" : "PRRC_kwDOABII5846ahF-",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 28,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 15,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980029822/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980029822",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980030921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980030921"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in c3181a344c7e80ca233be47e7b44a1074c382498\r\n`ssKey` and `strErr` are now unused",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:23:04Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980030921",
      "id" : 980030921,
      "line" : 432,
      "node_id" : "PRRC_kwDOABII5846ahXJ",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 432,
      "original_position" : 264,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 264,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980030921/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980030921",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980034855"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980034855"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in 5444f78824c8b44776acb3523c8a591d2abb570d\r\n```suggestion\r\n            auto [ins, inserted] = hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\r\n            CHDChain& chain = ins->second;\r\n            if (inserted) {\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:26:27Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    CHDChain chain;\n+    ssValue >> chain;\n+    pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    return true;\n+}\n \n-            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n-            {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n-            }\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::MASTER_KEY) {\n-            // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n-            unsigned int nID;\n-            ssKey >> nID;\n-            CMasterKey kMasterKey;\n-            ssValue >> kMasterKey;\n-            if(pwallet->mapMasterKeys.count(nID) != 0)\n-            {\n-                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n-                return false;\n-            }\n-            pwallet->mapMasterKeys[nID] = kMasterKey;\n-            if (pwallet->nMasterKeyMaxID < nID)\n-                pwallet->nMasterKeyMaxID = nID;\n-        } else if (strType == DBKeys::CRYPTED_KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n-            {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n-            }\n-            std::vector<unsigned char> vchPrivKey;\n-            ssValue >> vchPrivKey;\n-\n-            // Get the checksum and check it\n-            bool checksum_valid = false;\n-            if (!ssValue.eof()) {\n-                uint256 checksum;\n-                ssValue >> checksum;\n-                if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n-                    strErr = \"Error reading wallet database: Encrypted key corrupt\";\n-                    return false;\n-                }\n-            }\n+bool WalletBatch::IsKeyType(const std::string& strType)\n+{\n+    return (strType == DBKeys::KEY ||\n+            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+}\n \n-            wss.nCKeys++;\n+static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    int nMinVersion = 0;\n+    if (batch.Read(DBKeys::MINVERSION, nMinVersion)) {\n+        if (nMinVersion > FEATURE_LATEST)\n+            return DBErrors::TOO_NEW;\n+        pwallet->LoadMinVersion(nMinVersion);\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n-                return false;\n-            }\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::KEYMETA) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n-\n-            // Extract some CHDChain info from this metadata if it has any\n-            if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n-                // Get the path from the key origin or from the path string\n-                // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n-                // See https://github.com/bitcoin/bitcoin/pull/12924\n-                bool internal = false;\n-                uint32_t index = 0;\n-                if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n-                    std::vector<uint32_t> path;\n-                    if (keyMeta.has_key_origin) {\n-                        // We have a key origin, so pull it from its path vector\n-                        path = keyMeta.key_origin.path;\n-                    } else {\n-                        // No key origin, have to parse the string\n-                        if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n-                            strErr = \"Error reading wallet database: keymeta with invalid HD keypath\";\n-                            return false;\n-                        }\n-                    }\n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;\n+        }\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-                    // Extract the index and internal from the path\n-                    // Path string is m/0'/k'/i'\n-                    // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n-                    // k == 0 for external, 1 for internal. i is the index\n-                    if (path.size() != 3) {\n-                        strErr = \"Error reading wallet database: keymeta found with unexpected path\";\n-                        return false;\n-                    }\n-                    if (path[0] != 0x80000000) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\", path[0]);\n-                        return false;\n-                    }\n-                    if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\", path[1]);\n-                        return false;\n-                    }\n-                    if ((path[2] & 0x80000000) == 0) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\", path[2]);\n-                        return false;\n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, CDataStream& prefix, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    return LoadRecords(pwallet, batch, key, prefix, load_func);\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            err = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\";\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (script_res.m_result != DBErrors::LOAD_OK) {\n+        return script_res.m_result;\n+    }\n+    result = std::max(result, script_res.m_result);\n+\n+    // Check whether rewrite is needed\n+    if (ckey_res.m_records > 0) {\n+        // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n+        if (last_client == 40000 || last_client == 50000) return DBErrors::NEED_REWRITE;\n+    }\n+\n+    // Load keymeta\n+    std::map<uint160, CHDChain> hd_chains;\n+    LoadResult keymeta_res = LoadRecords(pwallet, batch, DBKeys::KEYMETA,\n+        [&hd_chains] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        CPubKey vchPubKey;\n+        key >> vchPubKey;\n+        CKeyMetadata keyMeta;\n+        value >> keyMeta;\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n+\n+        // Extract some CHDChain info from this metadata if it has any\n+        if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n+            // Get the path from the key origin or from the path string\n+            // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n+            // See https://github.com/bitcoin/bitcoin/pull/12924\n+            bool internal = false;\n+            uint32_t index = 0;\n+            if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n+                std::vector<uint32_t> path;\n+                if (keyMeta.has_key_origin) {\n+                    // We have a key origin, so pull it from its path vector\n+                    path = keyMeta.key_origin.path;\n+                } else {\n+                    // No key origin, have to parse the string\n+                    if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n+                        err = \"Error reading wallet database: keymeta with invalid HD keypath\\n\";\n+                        return DBErrors::NONCRITICAL_ERROR;\n                     }\n-                    internal = path[1] == (1 | 0x80000000);\n-                    index = path[2] & ~0x80000000;\n                 }\n \n-                // Insert a new CHDChain, or get the one that already exists\n-                auto ins = wss.m_hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n-                CHDChain& chain = ins.first->second;\n-                if (ins.second) {\n-                    // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n-                    chain.nVersion = CHDChain::VERSION_HD_BASE;\n-                    chain.seed_id = keyMeta.hd_seed_id;\n+                // Extract the index and internal from the path\n+                // Path string is m/0'/k'/i'\n+                // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n+                // k == 0 for external, 1 for internal. i is the index\n+                if (path.size() != 3) {\n+                    err = \"Error reading wallet database: keymeta found with unexpected path\\n\";\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n-                if (internal) {\n-                    chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n-                    chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n-                } else {\n-                    chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n+                if (path[0] != 0x80000000) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\\n\", path[0]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n+                if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\\n\", path[1]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                if ((path[2] & 0x80000000) == 0) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\\n\", path[2]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                internal = path[1] == (1 | 0x80000000);\n+                index = path[2] & ~0x80000000;\n             }\n-        } else if (strType == DBKeys::WATCHMETA) {\n-            CScript script;\n-            ssKey >> script;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadScriptMetadata(CScriptID(script), keyMeta);\n-        } else if (strType == DBKeys::DEFAULTKEY) {\n-            // We don't want or need the default key, but if there is one set,\n-            // we want to make sure that it is valid so that we can detect corruption\n-            CPubKey vchPubKey;\n-            ssValue >> vchPubKey;\n-            if (!vchPubKey.IsValid()) {\n-                strErr = \"Error reading wallet database: Default Key corrupt\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::POOL) {\n-            int64_t nIndex;\n-            ssKey >> nIndex;\n-            CKeyPool keypool;\n-            ssValue >> keypool;\n-\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyPool(nIndex, keypool);\n-        } else if (strType == DBKeys::CSCRIPT) {\n-            uint160 hash;\n-            ssKey >> hash;\n-            CScript script;\n-            ssValue >> script;\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::ORDERPOSNEXT) {\n-            ssValue >> pwallet->nOrderPosNext;\n-        } else if (strType == DBKeys::DESTDATA) {\n-            std::string strAddress, strKey, strValue;\n-            ssKey >> strAddress;\n-            ssKey >> strKey;\n-            ssValue >> strValue;\n-            pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n-        } else if (strType == DBKeys::HDCHAIN) {\n-            CHDChain chain;\n-            ssValue >> chain;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n-        } else if (strType == DBKeys::OLD_KEY) {\n-            strErr = \"Found unsupported 'wkey' record, try loading with version 0.18\";\n-            return false;\n-        } else if (strType == DBKeys::ACTIVEEXTERNALSPK || strType == DBKeys::ACTIVEINTERNALSPK) {\n-            uint8_t type;\n-            ssKey >> type;\n-            uint256 id;\n-            ssValue >> id;\n \n-            bool internal = strType == DBKeys::ACTIVEINTERNALSPK;\n-            auto& spk_mans = internal ? wss.m_active_internal_spks : wss.m_active_external_spks;\n-            if (spk_mans.count(static_cast<OutputType>(type)) > 0) {\n-                strErr = \"Multiple ScriptPubKeyMans specified for a single type\";\n-                return false;\n+            // Insert a new CHDChain, or get the one that already exists\n+            auto ins = hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n+            CHDChain& chain = ins.first->second;\n+            if (ins.second) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980034855",
      "id" : 980034855,
      "line" : 634,
      "node_id" : "PRRC_kwDOABII5846aiUn",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 634,
      "original_position" : 636,
      "original_start_line" : 632,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 636,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980034855/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 632,
      "start_side" : "RIGHT",
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980034855",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980036012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980036012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in 5444f78824c8b44776acb3523c8a591d2abb570d\r\n```suggestion\r\n    if (!hd_chains.empty()) {\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:27:13Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    CHDChain chain;\n+    ssValue >> chain;\n+    pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    return true;\n+}\n \n-            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n-            {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n-            }\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::MASTER_KEY) {\n-            // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n-            unsigned int nID;\n-            ssKey >> nID;\n-            CMasterKey kMasterKey;\n-            ssValue >> kMasterKey;\n-            if(pwallet->mapMasterKeys.count(nID) != 0)\n-            {\n-                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n-                return false;\n-            }\n-            pwallet->mapMasterKeys[nID] = kMasterKey;\n-            if (pwallet->nMasterKeyMaxID < nID)\n-                pwallet->nMasterKeyMaxID = nID;\n-        } else if (strType == DBKeys::CRYPTED_KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n-            {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n-            }\n-            std::vector<unsigned char> vchPrivKey;\n-            ssValue >> vchPrivKey;\n-\n-            // Get the checksum and check it\n-            bool checksum_valid = false;\n-            if (!ssValue.eof()) {\n-                uint256 checksum;\n-                ssValue >> checksum;\n-                if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n-                    strErr = \"Error reading wallet database: Encrypted key corrupt\";\n-                    return false;\n-                }\n-            }\n+bool WalletBatch::IsKeyType(const std::string& strType)\n+{\n+    return (strType == DBKeys::KEY ||\n+            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+}\n \n-            wss.nCKeys++;\n+static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    int nMinVersion = 0;\n+    if (batch.Read(DBKeys::MINVERSION, nMinVersion)) {\n+        if (nMinVersion > FEATURE_LATEST)\n+            return DBErrors::TOO_NEW;\n+        pwallet->LoadMinVersion(nMinVersion);\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n-                return false;\n-            }\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::KEYMETA) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n-\n-            // Extract some CHDChain info from this metadata if it has any\n-            if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n-                // Get the path from the key origin or from the path string\n-                // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n-                // See https://github.com/bitcoin/bitcoin/pull/12924\n-                bool internal = false;\n-                uint32_t index = 0;\n-                if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n-                    std::vector<uint32_t> path;\n-                    if (keyMeta.has_key_origin) {\n-                        // We have a key origin, so pull it from its path vector\n-                        path = keyMeta.key_origin.path;\n-                    } else {\n-                        // No key origin, have to parse the string\n-                        if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n-                            strErr = \"Error reading wallet database: keymeta with invalid HD keypath\";\n-                            return false;\n-                        }\n-                    }\n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;\n+        }\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-                    // Extract the index and internal from the path\n-                    // Path string is m/0'/k'/i'\n-                    // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n-                    // k == 0 for external, 1 for internal. i is the index\n-                    if (path.size() != 3) {\n-                        strErr = \"Error reading wallet database: keymeta found with unexpected path\";\n-                        return false;\n-                    }\n-                    if (path[0] != 0x80000000) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\", path[0]);\n-                        return false;\n-                    }\n-                    if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\", path[1]);\n-                        return false;\n-                    }\n-                    if ((path[2] & 0x80000000) == 0) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\", path[2]);\n-                        return false;\n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, CDataStream& prefix, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    return LoadRecords(pwallet, batch, key, prefix, load_func);\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            err = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\";\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (script_res.m_result != DBErrors::LOAD_OK) {\n+        return script_res.m_result;\n+    }\n+    result = std::max(result, script_res.m_result);\n+\n+    // Check whether rewrite is needed\n+    if (ckey_res.m_records > 0) {\n+        // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n+        if (last_client == 40000 || last_client == 50000) return DBErrors::NEED_REWRITE;\n+    }\n+\n+    // Load keymeta\n+    std::map<uint160, CHDChain> hd_chains;\n+    LoadResult keymeta_res = LoadRecords(pwallet, batch, DBKeys::KEYMETA,\n+        [&hd_chains] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        CPubKey vchPubKey;\n+        key >> vchPubKey;\n+        CKeyMetadata keyMeta;\n+        value >> keyMeta;\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n+\n+        // Extract some CHDChain info from this metadata if it has any\n+        if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n+            // Get the path from the key origin or from the path string\n+            // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n+            // See https://github.com/bitcoin/bitcoin/pull/12924\n+            bool internal = false;\n+            uint32_t index = 0;\n+            if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n+                std::vector<uint32_t> path;\n+                if (keyMeta.has_key_origin) {\n+                    // We have a key origin, so pull it from its path vector\n+                    path = keyMeta.key_origin.path;\n+                } else {\n+                    // No key origin, have to parse the string\n+                    if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n+                        err = \"Error reading wallet database: keymeta with invalid HD keypath\\n\";\n+                        return DBErrors::NONCRITICAL_ERROR;\n                     }\n-                    internal = path[1] == (1 | 0x80000000);\n-                    index = path[2] & ~0x80000000;\n                 }\n \n-                // Insert a new CHDChain, or get the one that already exists\n-                auto ins = wss.m_hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n-                CHDChain& chain = ins.first->second;\n-                if (ins.second) {\n-                    // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n-                    chain.nVersion = CHDChain::VERSION_HD_BASE;\n-                    chain.seed_id = keyMeta.hd_seed_id;\n+                // Extract the index and internal from the path\n+                // Path string is m/0'/k'/i'\n+                // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n+                // k == 0 for external, 1 for internal. i is the index\n+                if (path.size() != 3) {\n+                    err = \"Error reading wallet database: keymeta found with unexpected path\\n\";\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n-                if (internal) {\n-                    chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n-                    chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n-                } else {\n-                    chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n+                if (path[0] != 0x80000000) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\\n\", path[0]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n+                if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\\n\", path[1]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                if ((path[2] & 0x80000000) == 0) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\\n\", path[2]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                internal = path[1] == (1 | 0x80000000);\n+                index = path[2] & ~0x80000000;\n             }\n-        } else if (strType == DBKeys::WATCHMETA) {\n-            CScript script;\n-            ssKey >> script;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadScriptMetadata(CScriptID(script), keyMeta);\n-        } else if (strType == DBKeys::DEFAULTKEY) {\n-            // We don't want or need the default key, but if there is one set,\n-            // we want to make sure that it is valid so that we can detect corruption\n-            CPubKey vchPubKey;\n-            ssValue >> vchPubKey;\n-            if (!vchPubKey.IsValid()) {\n-                strErr = \"Error reading wallet database: Default Key corrupt\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::POOL) {\n-            int64_t nIndex;\n-            ssKey >> nIndex;\n-            CKeyPool keypool;\n-            ssValue >> keypool;\n-\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyPool(nIndex, keypool);\n-        } else if (strType == DBKeys::CSCRIPT) {\n-            uint160 hash;\n-            ssKey >> hash;\n-            CScript script;\n-            ssValue >> script;\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::ORDERPOSNEXT) {\n-            ssValue >> pwallet->nOrderPosNext;\n-        } else if (strType == DBKeys::DESTDATA) {\n-            std::string strAddress, strKey, strValue;\n-            ssKey >> strAddress;\n-            ssKey >> strKey;\n-            ssValue >> strValue;\n-            pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n-        } else if (strType == DBKeys::HDCHAIN) {\n-            CHDChain chain;\n-            ssValue >> chain;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n-        } else if (strType == DBKeys::OLD_KEY) {\n-            strErr = \"Found unsupported 'wkey' record, try loading with version 0.18\";\n-            return false;\n-        } else if (strType == DBKeys::ACTIVEEXTERNALSPK || strType == DBKeys::ACTIVEINTERNALSPK) {\n-            uint8_t type;\n-            ssKey >> type;\n-            uint256 id;\n-            ssValue >> id;\n \n-            bool internal = strType == DBKeys::ACTIVEINTERNALSPK;\n-            auto& spk_mans = internal ? wss.m_active_internal_spks : wss.m_active_external_spks;\n-            if (spk_mans.count(static_cast<OutputType>(type)) > 0) {\n-                strErr = \"Multiple ScriptPubKeyMans specified for a single type\";\n-                return false;\n+            // Insert a new CHDChain, or get the one that already exists\n+            auto ins = hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n+            CHDChain& chain = ins.first->second;\n+            if (ins.second) {\n+                // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n+                chain.nVersion = CHDChain::VERSION_HD_BASE;\n+                chain.seed_id = keyMeta.hd_seed_id;\n             }\n-            spk_mans[static_cast<OutputType>(type)] = id;\n-        } else if (strType == DBKeys::WALLETDESCRIPTOR) {\n-            uint256 id;\n-            ssKey >> id;\n-            WalletDescriptor desc;\n-            try {\n-                ssValue >> desc;\n-            } catch (const std::ios_base::failure& e) {\n-                strErr = e.what();\n-                wss.descriptor_unknown = true;\n-                return false;\n+            if (internal) {\n+                chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n+                chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n+            } else {\n+                chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n             }\n-            if (wss.m_descriptor_caches.count(id) == 0) {\n-                wss.m_descriptor_caches[id] = DescriptorCache();\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, script_res.m_result);\n+\n+    // Set inactive chains\n+    if (hd_chains.size() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980036012",
      "id" : 980036012,
      "line" : 651,
      "node_id" : "PRRC_kwDOABII5846aims",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 651,
      "original_position" : 666,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 666,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980036012/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980036012",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980038494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980038494"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in 5444f78824c8b44776acb3523c8a591d2abb570d\r\n```suggestion\r\n        for (const auto& [hd_seed_id, chain] : hd_chains) {\r\n            if (hd_seed_id != pwallet->GetLegacyScriptPubKeyMan()->GetHDChain().seed_id) {\r\n                pwallet->GetLegacyScriptPubKeyMan()->AddInactiveHDChain(chain);\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:29:02Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    CHDChain chain;\n+    ssValue >> chain;\n+    pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    return true;\n+}\n \n-            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n-            {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n-            }\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::MASTER_KEY) {\n-            // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n-            unsigned int nID;\n-            ssKey >> nID;\n-            CMasterKey kMasterKey;\n-            ssValue >> kMasterKey;\n-            if(pwallet->mapMasterKeys.count(nID) != 0)\n-            {\n-                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n-                return false;\n-            }\n-            pwallet->mapMasterKeys[nID] = kMasterKey;\n-            if (pwallet->nMasterKeyMaxID < nID)\n-                pwallet->nMasterKeyMaxID = nID;\n-        } else if (strType == DBKeys::CRYPTED_KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n-            {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n-            }\n-            std::vector<unsigned char> vchPrivKey;\n-            ssValue >> vchPrivKey;\n-\n-            // Get the checksum and check it\n-            bool checksum_valid = false;\n-            if (!ssValue.eof()) {\n-                uint256 checksum;\n-                ssValue >> checksum;\n-                if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n-                    strErr = \"Error reading wallet database: Encrypted key corrupt\";\n-                    return false;\n-                }\n-            }\n+bool WalletBatch::IsKeyType(const std::string& strType)\n+{\n+    return (strType == DBKeys::KEY ||\n+            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+}\n \n-            wss.nCKeys++;\n+static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    int nMinVersion = 0;\n+    if (batch.Read(DBKeys::MINVERSION, nMinVersion)) {\n+        if (nMinVersion > FEATURE_LATEST)\n+            return DBErrors::TOO_NEW;\n+        pwallet->LoadMinVersion(nMinVersion);\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n-                return false;\n-            }\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::KEYMETA) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n-\n-            // Extract some CHDChain info from this metadata if it has any\n-            if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n-                // Get the path from the key origin or from the path string\n-                // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n-                // See https://github.com/bitcoin/bitcoin/pull/12924\n-                bool internal = false;\n-                uint32_t index = 0;\n-                if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n-                    std::vector<uint32_t> path;\n-                    if (keyMeta.has_key_origin) {\n-                        // We have a key origin, so pull it from its path vector\n-                        path = keyMeta.key_origin.path;\n-                    } else {\n-                        // No key origin, have to parse the string\n-                        if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n-                            strErr = \"Error reading wallet database: keymeta with invalid HD keypath\";\n-                            return false;\n-                        }\n-                    }\n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;\n+        }\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-                    // Extract the index and internal from the path\n-                    // Path string is m/0'/k'/i'\n-                    // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n-                    // k == 0 for external, 1 for internal. i is the index\n-                    if (path.size() != 3) {\n-                        strErr = \"Error reading wallet database: keymeta found with unexpected path\";\n-                        return false;\n-                    }\n-                    if (path[0] != 0x80000000) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\", path[0]);\n-                        return false;\n-                    }\n-                    if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\", path[1]);\n-                        return false;\n-                    }\n-                    if ((path[2] & 0x80000000) == 0) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\", path[2]);\n-                        return false;\n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, CDataStream& prefix, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    return LoadRecords(pwallet, batch, key, prefix, load_func);\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            err = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\";\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (script_res.m_result != DBErrors::LOAD_OK) {\n+        return script_res.m_result;\n+    }\n+    result = std::max(result, script_res.m_result);\n+\n+    // Check whether rewrite is needed\n+    if (ckey_res.m_records > 0) {\n+        // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n+        if (last_client == 40000 || last_client == 50000) return DBErrors::NEED_REWRITE;\n+    }\n+\n+    // Load keymeta\n+    std::map<uint160, CHDChain> hd_chains;\n+    LoadResult keymeta_res = LoadRecords(pwallet, batch, DBKeys::KEYMETA,\n+        [&hd_chains] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        CPubKey vchPubKey;\n+        key >> vchPubKey;\n+        CKeyMetadata keyMeta;\n+        value >> keyMeta;\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n+\n+        // Extract some CHDChain info from this metadata if it has any\n+        if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n+            // Get the path from the key origin or from the path string\n+            // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n+            // See https://github.com/bitcoin/bitcoin/pull/12924\n+            bool internal = false;\n+            uint32_t index = 0;\n+            if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n+                std::vector<uint32_t> path;\n+                if (keyMeta.has_key_origin) {\n+                    // We have a key origin, so pull it from its path vector\n+                    path = keyMeta.key_origin.path;\n+                } else {\n+                    // No key origin, have to parse the string\n+                    if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n+                        err = \"Error reading wallet database: keymeta with invalid HD keypath\\n\";\n+                        return DBErrors::NONCRITICAL_ERROR;\n                     }\n-                    internal = path[1] == (1 | 0x80000000);\n-                    index = path[2] & ~0x80000000;\n                 }\n \n-                // Insert a new CHDChain, or get the one that already exists\n-                auto ins = wss.m_hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n-                CHDChain& chain = ins.first->second;\n-                if (ins.second) {\n-                    // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n-                    chain.nVersion = CHDChain::VERSION_HD_BASE;\n-                    chain.seed_id = keyMeta.hd_seed_id;\n+                // Extract the index and internal from the path\n+                // Path string is m/0'/k'/i'\n+                // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n+                // k == 0 for external, 1 for internal. i is the index\n+                if (path.size() != 3) {\n+                    err = \"Error reading wallet database: keymeta found with unexpected path\\n\";\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n-                if (internal) {\n-                    chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n-                    chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n-                } else {\n-                    chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n+                if (path[0] != 0x80000000) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\\n\", path[0]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n+                if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\\n\", path[1]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                if ((path[2] & 0x80000000) == 0) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\\n\", path[2]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                internal = path[1] == (1 | 0x80000000);\n+                index = path[2] & ~0x80000000;\n             }\n-        } else if (strType == DBKeys::WATCHMETA) {\n-            CScript script;\n-            ssKey >> script;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadScriptMetadata(CScriptID(script), keyMeta);\n-        } else if (strType == DBKeys::DEFAULTKEY) {\n-            // We don't want or need the default key, but if there is one set,\n-            // we want to make sure that it is valid so that we can detect corruption\n-            CPubKey vchPubKey;\n-            ssValue >> vchPubKey;\n-            if (!vchPubKey.IsValid()) {\n-                strErr = \"Error reading wallet database: Default Key corrupt\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::POOL) {\n-            int64_t nIndex;\n-            ssKey >> nIndex;\n-            CKeyPool keypool;\n-            ssValue >> keypool;\n-\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyPool(nIndex, keypool);\n-        } else if (strType == DBKeys::CSCRIPT) {\n-            uint160 hash;\n-            ssKey >> hash;\n-            CScript script;\n-            ssValue >> script;\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::ORDERPOSNEXT) {\n-            ssValue >> pwallet->nOrderPosNext;\n-        } else if (strType == DBKeys::DESTDATA) {\n-            std::string strAddress, strKey, strValue;\n-            ssKey >> strAddress;\n-            ssKey >> strKey;\n-            ssValue >> strValue;\n-            pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n-        } else if (strType == DBKeys::HDCHAIN) {\n-            CHDChain chain;\n-            ssValue >> chain;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n-        } else if (strType == DBKeys::OLD_KEY) {\n-            strErr = \"Found unsupported 'wkey' record, try loading with version 0.18\";\n-            return false;\n-        } else if (strType == DBKeys::ACTIVEEXTERNALSPK || strType == DBKeys::ACTIVEINTERNALSPK) {\n-            uint8_t type;\n-            ssKey >> type;\n-            uint256 id;\n-            ssValue >> id;\n \n-            bool internal = strType == DBKeys::ACTIVEINTERNALSPK;\n-            auto& spk_mans = internal ? wss.m_active_internal_spks : wss.m_active_external_spks;\n-            if (spk_mans.count(static_cast<OutputType>(type)) > 0) {\n-                strErr = \"Multiple ScriptPubKeyMans specified for a single type\";\n-                return false;\n+            // Insert a new CHDChain, or get the one that already exists\n+            auto ins = hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n+            CHDChain& chain = ins.first->second;\n+            if (ins.second) {\n+                // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n+                chain.nVersion = CHDChain::VERSION_HD_BASE;\n+                chain.seed_id = keyMeta.hd_seed_id;\n             }\n-            spk_mans[static_cast<OutputType>(type)] = id;\n-        } else if (strType == DBKeys::WALLETDESCRIPTOR) {\n-            uint256 id;\n-            ssKey >> id;\n-            WalletDescriptor desc;\n-            try {\n-                ssValue >> desc;\n-            } catch (const std::ios_base::failure& e) {\n-                strErr = e.what();\n-                wss.descriptor_unknown = true;\n-                return false;\n+            if (internal) {\n+                chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n+                chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n+            } else {\n+                chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n             }\n-            if (wss.m_descriptor_caches.count(id) == 0) {\n-                wss.m_descriptor_caches[id] = DescriptorCache();\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, script_res.m_result);\n+\n+    // Set inactive chains\n+    if (hd_chains.size() > 0) {\n+        LegacyScriptPubKeyMan* legacy_spkm = pwallet->GetLegacyScriptPubKeyMan();\n+        if (!legacy_spkm) {\n+            pwallet->WalletLogPrintf(\"Inactive HD Chains found but no Legacy ScriptPubKeyMan\\n\");\n+            return DBErrors::CORRUPT;\n+        }\n+        for (const auto& chain_pair : hd_chains) {\n+            if (chain_pair.first != pwallet->GetLegacyScriptPubKeyMan()->GetHDChain().seed_id) {\n+                pwallet->GetLegacyScriptPubKeyMan()->AddInactiveHDChain(chain_pair.second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980038494",
      "id" : 980038494,
      "line" : 659,
      "node_id" : "PRRC_kwDOABII5846ajNe",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 659,
      "original_position" : 674,
      "original_start_line" : 657,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 674,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980038494/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 657,
      "start_side" : "RIGHT",
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980038494",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980044405"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980044405"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in 69f987e8ecbf8e8d3202c3ad118501aa1d6399e3: i had to do it\r\n```suggestion\r\n    return mkey_res.m_result;\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T13:34:16Z",
      "diff_hunk" : "@@ -701,77 +856,228 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n \n             if (Hash(to_hash) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                return false;\n+                err = \"Error reading wallet database: descriptor unencrypted key CPubKey/CPrivKey corrupt\\n\";\n+                return DBErrors::CORRUPT;\n             }\n \n-            if (!key.Load(pkey, pubkey, true))\n+            if (!privkey.Load(pkey, pubkey, true))\n             {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n+                err = \"Error reading wallet database: descriptor unencrypted key CPrivKey corrupt\\n\";\n+                return DBErrors::CORRUPT;\n             }\n-            wss.m_descriptor_keys.insert(std::make_pair(std::make_pair(desc_id, pubkey.GetID()), key));\n-        } else if (strType == DBKeys::WALLETDESCRIPTORCKEY) {\n+            spk_man->AddKey(pubkey.GetID(), privkey);\n+            return DBErrors::LOAD_OK;\n+        });\n+        result = std::max(result, key_res.m_result);\n+        num_keys = key_res.m_records;\n+\n+        // Get encrypted keys\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCKEY, id);\n+        LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCKEY, prefix,\n+            [&id, &num_ckeys, &spk_man] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n             uint256 desc_id;\n             CPubKey pubkey;\n-            ssKey >> desc_id;\n-            ssKey >> pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n             if (!pubkey.IsValid())\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n+                err = \"Error reading wallet database: descriptor encrypted key CPubKey corrupt\\n\";\n+                return DBErrors::CORRUPT;\n             }\n             std::vector<unsigned char> privkey;\n-            ssValue >> privkey;\n-            wss.nCKeys++;\n+            value >> privkey;\n+            num_ckeys++;\n \n-            wss.m_descriptor_crypt_keys.insert(std::make_pair(std::make_pair(desc_id, pubkey.GetID()), std::make_pair(pubkey, privkey)));\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::LOCKED_UTXO) {\n-            uint256 hash;\n-            uint32_t n;\n-            ssKey >> hash;\n-            ssKey >> n;\n-            pwallet->LockCoin(COutPoint(hash, n));\n-        } else if (strType != DBKeys::BESTBLOCK && strType != DBKeys::BESTBLOCK_NOMERKLE &&\n-                   strType != DBKeys::MINVERSION && strType != DBKeys::ACENTRY &&\n-                   strType != DBKeys::VERSION && strType != DBKeys::SETTINGS &&\n-                   strType != DBKeys::FLAGS) {\n-            wss.m_unknown_records++;\n-        }\n-    } catch (const std::exception& e) {\n-        if (strErr.empty()) {\n-            strErr = e.what();\n-        }\n-        return false;\n-    } catch (...) {\n-        if (strErr.empty()) {\n-            strErr = \"Caught unknown exception in ReadKeyValue\";\n+            spk_man->AddCryptedKey(pubkey.GetID(), pubkey, privkey);\n+            return DBErrors::LOAD_OK;\n+        });\n+        result = std::max(result, ckey_res.m_result);\n+        num_ckeys = ckey_res.m_records;\n+\n+        return result;\n+    });\n+\n+    pwallet->WalletLogPrintf(\"Descriptors: %u, Descriptor Keys: %u plaintext, %u encrypted, %u total.\\n\",\n+           desc_res.m_records, num_keys, num_ckeys, num_keys + num_ckeys);\n+\n+    return desc_res.m_result;\n+}\n+\n+static DBErrors LoadAddressBookRecords(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load name record\n+    LoadResult name_res = LoadRecords(pwallet, batch, DBKeys::NAME,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        std::string strAddress;\n+        key >> strAddress;\n+        std::string label;\n+        value >> label;\n+        pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (name_res.m_result != DBErrors::LOAD_OK) return name_res.m_result;\n+\n+    // Load purpose record\n+    LoadResult purpose_res = LoadRecords(pwallet, batch, DBKeys::PURPOSE,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        std::string strAddress;\n+        key >> strAddress;\n+        value >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (purpose_res.m_result != DBErrors::LOAD_OK) return purpose_res.m_result;\n+\n+    // Load destination data record\n+    LoadResult dest_res = LoadRecords(pwallet, batch, DBKeys::DESTDATA,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        std::string strAddress, strKey, strValue;\n+        key >> strAddress;\n+        key >> strKey;\n+        value >> strValue;\n+        pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (dest_res.m_result != DBErrors::LOAD_OK) return dest_res.m_result;\n+\n+    return DBErrors::LOAD_OK;\n+}\n+\n+static DBErrors LoadTxRecords(CWallet* pwallet, DatabaseBatch& batch, std::vector<uint256> upgraded_txs, bool& any_unordered) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load tx record\n+    bool corrupted_tx = false;\n+    any_unordered = false;\n+    LoadResult tx_res = LoadRecords(pwallet, batch, DBKeys::TX,\n+        [&corrupted_tx, &any_unordered, &upgraded_txs] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        DBErrors result = DBErrors::LOAD_OK;\n+        uint256 hash;\n+        key >> hash;\n+        // LoadToWallet call below creates a new CWalletTx that fill_wtx\n+        // callback fills with transaction metadata.\n+        auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n+            if(!new_tx) {\n+                // There's some corruption here since the tx we just tried to load was already in the wallet.\n+                // We don't consider this type of corruption critical, and can fix it by removing tx data and\n+                // rescanning.\n+                err = \"Error: Corrupt transaction found. This can be fixed by removing transactions from wallet and rescanning.\\n\";\n+                result = DBErrors::CORRUPT;\n+                corrupted_tx = true;\n+                return false;\n+            }\n+            value >> wtx;\n+            if (wtx.GetHash() != hash)\n+                return false;\n+\n+            // Undo serialize changes in 31600\n+            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n+            {\n+                if (!value.empty())\n+                {\n+                    uint8_t fTmp;\n+                    uint8_t fUnused;\n+                    std::string unused_string;\n+                    value >> fTmp >> fUnused >> unused_string;\n+                    pwallet->WalletLogPrintf(\"LoadWallet() upgrading tx ver=%d %d %s\\n\",\n+                                       wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n+                    wtx.fTimeReceivedIsTxTime = fTmp;\n+                }\n+                else\n+                {\n+                    pwallet->WalletLogPrintf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n+                    wtx.fTimeReceivedIsTxTime = 0;\n+                }\n+                upgraded_txs.push_back(hash);\n+            }\n+\n+            if (wtx.nOrderPos == -1)\n+                any_unordered = true;\n+\n+            return true;\n+        };\n+        if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n+            if (corrupted_tx) {\n+                result = DBErrors::CORRUPT;\n+            } else {\n+                result = DBErrors::NEED_RESCAN;\n+            }\n         }\n-        return false;\n-    }\n-    return true;\n+        return result;\n+    });\n+    result = std::max(result, tx_res.m_result);\n+\n+    // Load locked utxo record\n+    LoadResult locked_utxo_res = LoadRecords(pwallet, batch, DBKeys::LOCKED_UTXO,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        uint256 hash;\n+        uint32_t n;\n+        key >> hash;\n+        key >> n;\n+        pwallet->LockCoin(COutPoint(hash, n));\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, tx_res.m_result);\n+    if (result != DBErrors::LOAD_OK) return result;\n+\n+    // Load orderposnext record\n+    batch.Read(DBKeys::ORDERPOSNEXT, pwallet->nOrderPosNext);\n+\n+    return DBErrors::LOAD_OK;\n }\n \n-bool ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn)\n+static DBErrors LoadActiveSPKMs(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    CWalletScanState dummy_wss;\n-    LOCK(pwallet->cs_wallet);\n-    return ReadKeyValue(pwallet, ssKey, ssValue, dummy_wss, strType, strErr, filter_fn);\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load spk records\n+    std::set<std::pair<OutputType, bool>> seen_spks;\n+    for (auto& spk_key : {DBKeys::ACTIVEEXTERNALSPK, DBKeys::ACTIVEINTERNALSPK}) {\n+        LoadResult spkm_res = LoadRecords(pwallet, batch, spk_key,\n+            [&seen_spks, &spk_key] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint8_t output_type;\n+            key >> output_type;\n+            uint256 id;\n+            value >> id;\n+\n+            bool internal = spk_key == DBKeys::ACTIVEINTERNALSPK;\n+            auto [it, insert] = seen_spks.emplace(static_cast<OutputType>(output_type), internal);\n+            if (!insert) {\n+                err = \"Multiple ScriptpubKeyMans specified for a single type\\n\";\n+                return DBErrors::CORRUPT;\n+            }\n+            pwallet->LoadActiveScriptPubKeyMan(id, static_cast<OutputType>(output_type), /*internal=*/internal);\n+            return DBErrors::LOAD_OK;\n+        });\n+        if (spkm_res.m_result != DBErrors::LOAD_OK) return spkm_res.m_result;\n+    }\n+    return DBErrors::LOAD_OK;\n }\n \n-bool WalletBatch::IsKeyType(const std::string& strType)\n+static DBErrors LoadDecryptionKeys(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    return (strType == DBKeys::KEY ||\n-            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load decryption key (mkey) records\n+    LoadResult mkey_res = LoadRecords(pwallet, batch, DBKeys::MASTER_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadEncryptionKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    return mkey_res.m_result;;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980044405",
      "id" : 980044405,
      "line" : 1073,
      "node_id" : "PRRC_kwDOABII5846akp1",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 1073,
      "original_position" : 1153,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : 1153,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980044405/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980044405",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980171004"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980171004"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Considering `prefix` is a UTF-8 encoded string:\r\nhttps://github.com/bitcoin/bitcoin/blob/f227e153e80c8c50c30d76e1ac638d7206c7ff61/src/wallet/walletdb.cpp#L30-L61\r\n\r\nis it useful to check for trailing `0xFF` bytes? Simply incrementing the last byte could reduce code complexity.\r\n```suggestion\r\n    end_range.back() = std::byte(static_cast<unsigned char>(end_range.back()) + 1);\r\n```",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T15:14:03Z",
      "diff_hunk" : "@@ -506,10 +497,69 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  __func__, sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"%s: Failed to setup cursor SQL statement: %s\\n\", __func__, sqlite3_errstr(res)));\n+    }\n+\n+    return cursor;\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980171004",
      "id" : 980171004,
      "line" : 547,
      "node_id" : "PRRC_kwDOABII5846bDj8",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 547,
      "original_position" : 106,
      "original_start_line" : 536,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 106,
      "pull_request_review_id" : 1120211654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980171004/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 536,
      "start_side" : "RIGHT",
      "updated_at" : "2022-09-26T15:31:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980171004",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I left some code review comments.",
      "created_at" : "2022-09-26T15:31:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#issuecomment-1258222357",
      "id" : 1258222357,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24914",
      "node_id" : "IC_kwDOABII585K_vMV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1258222357/reactions"
      },
      "updated_at" : "2022-09-26T15:31:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1258222357",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980256311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980256311"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's still there :grimacing: ",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-26T16:17:13Z",
      "diff_hunk" : "@@ -506,10 +494,30 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"SQLiteBatch: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+    if (!cursor) return nullptr;\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"SQLiteDatabase: Failed to setup cursor SQL statement: %s\\n\", sqlite3_errstr(res)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980256311",
      "id" : 980256311,
      "in_reply_to_id" : 915214759,
      "line" : 556,
      "node_id" : "PRRC_kwDOABII5846bYY3",
      "original_commit_id" : "d1316204a783a1eed1ef6b7d7fe0680c5b6368d3",
      "original_line" : 556,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 115,
      "pull_request_review_id" : 1120544368,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980256311/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-26T16:17:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/980256311",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r984898374"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/984898374"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/24914#discussion_r980171004\r\n\r\n> Considering `prefix` is a UTF-8 encoded string:\r\n\r\nJust IMO, but I think it is better to have a little code complexity here and do prefix lookups correctly for all binary strings, than to make it subtly or unexpectedly fail for non-utf8 strings. There's a tradeoff but in this case it seems better to make the API implementation a little more complex if it can avoid making API usage more complex or error prone.",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-30T19:38:49Z",
      "diff_hunk" : "@@ -506,10 +497,69 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  __func__, sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"%s: Failed to setup cursor SQL statement: %s\\n\", __func__, sqlite3_errstr(res)));\n+    }\n+\n+    return cursor;\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r984898374",
      "id" : 984898374,
      "in_reply_to_id" : 980171004,
      "line" : 547,
      "node_id" : "PRRC_kwDOABII5846tFtG",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 547,
      "original_position" : 106,
      "original_start_line" : 536,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 106,
      "pull_request_review_id" : 1127288236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/984898374/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 536,
      "start_side" : "RIGHT",
      "updated_at" : "2022-09-30T20:25:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/984898374",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r984911106"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/984911106"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"wallet: Add GetPrefixCursor to DatabaseBatch\" (e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be)\r\n\r\nThe handling of this last condition doesn't seem right. For example if you are looking for keys with prefix `X'FFFF'`, the right condition to check for is simply `key >= X'FFFF'`. It is not `key >= X'FFFF' AND key < X'01FFFF'`.\r\n\r\nYou could fix this by replacing this line with `end_range.clear()`. Then in the `end_range.empty()` case below, prepare the SQL statement `WHERE key >= {begin_range}` instead of `WHERE key >= {begin_range} AND key < {end_range}`.\r\n\r\nThis would fix the prefix scan for prefixes that consist of `0xff` bytes. It would also fix the prefix scan for empty prefixes (by returning all rows), so you could drop the `if (prefix.empty()) return nullptr;` error above too.\r\n\r\nRelated to this, I previously implemented an sqlite prefix scan more simply using the sqlite `instr` function in https://github.com/bitcoin/bitcoin/commit/7a05b1dee2fa68b32bfb19e273fb55a5b3836a3e#diff-d43e46c8f7010dde905ec31057a1c5c2674df9be11683f98a21546377f2cd706 from #18608. But probably the approach in this PR is more efficient, unless the sql interpreter is doing some fancy rewriting.\r\n",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-09-30T19:59:50Z",
      "diff_hunk" : "@@ -519,6 +523,45 @@ std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n     return cursor;\n }\n \n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r984911106",
      "id" : 984911106,
      "line" : 546,
      "node_id" : "PRRC_kwDOABII5846tI0C",
      "original_commit_id" : "e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be",
      "original_line" : 546,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 50,
      "pull_request_review_id" : 1127288236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/984911106/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-30T20:25:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/984911106",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r985149717"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985149717"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Alright, in this case I think a unit test with a prefix with a trailing `0xFF` should be added.\r\n\r\nEdit: this doesn't seem necessary considering https://github.com/bitcoin/bitcoin/pull/24914#discussion_r984911106.",
      "commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "created_at" : "2022-10-01T22:04:18Z",
      "diff_hunk" : "@@ -506,10 +497,69 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  __func__, sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"%s: Failed to setup cursor SQL statement: %s\\n\", __func__, sqlite3_errstr(res)));\n+    }\n+\n+    return cursor;\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r985149717",
      "id" : 985149717,
      "in_reply_to_id" : 980171004,
      "line" : 547,
      "node_id" : "PRRC_kwDOABII5846uDEV",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 547,
      "original_position" : 106,
      "original_start_line" : 536,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 106,
      "pull_request_review_id" : 1127570935,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985149717/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 536,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-01T22:05:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985149717",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r986358462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/986358462"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"wallet: Introduce DatabaseCursor RAII class for managing cursor\" (10cf25c112ff4ac7bcece87a821996004cec2b24)\r\n\r\ntrailing whitespace",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-04T01:27:56Z",
      "diff_hunk" : "@@ -92,9 +103,21 @@ class DatabaseBatch\n         return HasKey(std::move(ssKey));\n     }\n \n-    virtual bool StartCursor() = 0;\n-    virtual bool ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool& complete) = 0;\n-    virtual void CloseCursor() = 0;\n+    virtual std::unique_ptr<DatabaseCursor> GetNewCursor() = 0;\n+    bool StartCursor()\n+    {\n+        m_cursor = GetNewCursor();\n+        return m_cursor != nullptr;  ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r986358462",
      "id" : 986358462,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846yqK-",
      "original_commit_id" : "10cf25c112ff4ac7bcece87a821996004cec2b24",
      "original_line" : 110,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/wallet/db.h",
      "position" : null,
      "pull_request_review_id" : 1129198780,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/986358462/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-04T19:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/986358462",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987171148"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987171148"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"wallet: Add GetPrefixCursor to DatabaseBatch\" (e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be)\r\n\r\nCan `prefix` just be `Span<const std::byte>`? It seems like a prefix scan should only require an array of bytes to function, not a full `CDataStream` object, much less a nonconst one.",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-04T17:45:48Z",
      "diff_hunk" : "@@ -102,6 +102,7 @@ class DatabaseBatch\n     }\n \n     virtual std::unique_ptr<DatabaseCursor> GetNewCursor() = 0;\n+    virtual std::unique_ptr<DatabaseCursor> GetNewPrefixCursor(CDataStream& prefix) = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987171148",
      "id" : 987171148,
      "line" : 108,
      "node_id" : "PRRC_kwDOABII58461wlM",
      "original_commit_id" : "e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be",
      "original_line" : 108,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/db.h",
      "position" : 27,
      "pull_request_review_id" : 1129198780,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987171148/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-04T19:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987171148",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987183146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987183146"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"wallet: Have cursor users use DatabaseCursor directly\" (5a8b0f16681bf8f755e84567e7ecee2feb28336c)\r\n\r\nCode pre-exists this PR, and I guess it works, but this line should probably say `if (complete || !ret)`. It's not clear that the Next function would or should failure if the end of the stream is hit.\r\n\r\nChanging this also would make it clearer that this break is intended to handle two different conditions, and it would also make this code more similar to other code calling `ReadAtCursor`/`Next`",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-04T17:59:03Z",
      "diff_hunk" : "@@ -3677,24 +3677,25 @@ bool CWallet::MigrateToSQLite(bilingual_str& error)\n \n     // Get all of the records for DB type migration\n     std::unique_ptr<DatabaseBatch> batch = m_database->MakeBatch();\n+    std::unique_ptr<DatabaseCursor> cursor = batch->GetNewCursor();\n     std::vector<std::pair<SerializeData, SerializeData>> records;\n-    if (!batch->StartCursor()) {\n+    if (!cursor) {\n         error = _(\"Error: Unable to begin reading all records in the database\");\n         return false;\n     }\n     bool complete = false;\n     while (true) {\n         CDataStream ss_key(SER_DISK, CLIENT_VERSION);\n         CDataStream ss_value(SER_DISK, CLIENT_VERSION);\n-        bool ret = batch->ReadAtCursor(ss_key, ss_value, complete);\n+        bool ret = cursor->Next(ss_key, ss_value, complete);\n         if (!ret) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987183146",
      "id" : 987183146,
      "line" : null,
      "node_id" : "PRRC_kwDOABII58461zgq",
      "original_commit_id" : "5a8b0f16681bf8f755e84567e7ecee2feb28336c",
      "original_line" : 3691,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 1129198780,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987183146/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-04T19:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987183146",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987194757"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987194757"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"wallet: Add GetPrefixCursor to DatabaseBatch\" (e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be)\r\n\r\nNote to reviewers: this change seems safe because all of the cursor next callers except for one (in `MigrateToSQLite`) check the `complete` output variable before they use this return value.\r\n\r\nI do think more ideally this function would return something like a `util::Result<bool>` or an `enum { SUCCESS, FAILURE, DONE }` so the failure and done cases don't overlap.",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-04T18:12:45Z",
      "diff_hunk" : "@@ -477,13 +477,16 @@ bool SQLiteCursor::Next(CDataStream& key, CDataStream& value, bool& complete)\n     int res = sqlite3_step(m_cursor_stmt);\n     if (res == SQLITE_DONE) {\n         complete = true;\n-        return true;\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987194757",
      "id" : 987194757,
      "line" : 480,
      "node_id" : "PRRC_kwDOABII584612WF",
      "original_commit_id" : "e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be",
      "original_line" : 480,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 39,
      "pull_request_review_id" : 1129198780,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987194757/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-04T19:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987194757",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987226534"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987226534"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"wallet: Add GetPrefixCursor to DatabaseBatch\" (e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be)\r\n\r\nI don't understand how `datKey` can be used to return the key data if it is now initialized to be a pointer to the `m_key_prefix` buffer instead of being a freestanding Dbt object that has the DB_DBT_MALLOC flag set and can allocate its own memory. If the keys are longer than the prefix how would they fit in `datKey` now?\r\n\r\nProbably I am missing something if the code works, but I would expect it look more like:\r\n\r\n```c++\r\nif (!m_first && !m_key_prefix.empty()) {\r\n    SafeDbt prefix{m_key_prefix.data(), m_key_prefix.size()};\r\n    m_cursor->get(prefix, value, DB_SET_RANGE);\r\n}\r\nret = m_cursor->get(datKey, datValue, first ? DB_CURRENT : DB_NEXT);\r\nm_first = false;\r\n```\r\n\r\nIn case I'm not missing something and there is a problem with this code, there was a [`BerkeleyBatch::ErasePrefix`](https://github.com/bitcoin/bitcoin/commit/7a05b1dee2fa68b32bfb19e273fb55a5b3836a3e#diff-b06753f6e4621f5bcd6cd27fed4137e70a262596b08f7f3a1416ea21977c53d4) function in #18608 that did something very similar and could be an example.",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-04T18:51:40Z",
      "diff_hunk" : "@@ -668,9 +669,15 @@ bool BerkeleyCursor::Next(CDataStream& ssKey, CDataStream& ssValue, bool& comple\n     complete = false;\n     if (m_cursor == nullptr) return false;\n     // Read at cursor\n-    SafeDbt datKey;\n+    SafeDbt datKey(m_key_prefix.data(), m_key_prefix.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r987226534",
      "id" : 987226534,
      "line" : 672,
      "node_id" : "PRRC_kwDOABII58461-Gm",
      "original_commit_id" : "e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be",
      "original_line" : 672,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : 109,
      "pull_request_review_id" : 1129198780,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987226534/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-04T19:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/987226534",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989509937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989509937"
         }
      },
      "author_association" : "MEMBER",
      "body" : "AFAICT it just overwrites the `datKey.data` with a pointer to newly allocated memory. There's nothing that indicates that this doesn't work (i.e. no tests fail and wallets load succesfully).",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:50:15Z",
      "diff_hunk" : "@@ -668,9 +669,15 @@ bool BerkeleyCursor::Next(CDataStream& ssKey, CDataStream& ssValue, bool& comple\n     complete = false;\n     if (m_cursor == nullptr) return false;\n     // Read at cursor\n-    SafeDbt datKey;\n+    SafeDbt datKey(m_key_prefix.data(), m_key_prefix.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989509937",
      "id" : 989509937,
      "in_reply_to_id" : 987226534,
      "line" : 672,
      "node_id" : "PRRC_kwDOABII5846-rkx",
      "original_commit_id" : "e9b3bcb411b5742d6579d95b5e6aa2ad3f7592be",
      "original_line" : 672,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/wallet/bdb.cpp",
      "position" : 109,
      "pull_request_review_id" : 1133676864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989509937/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:50:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989509937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:50:52Z",
      "diff_hunk" : "@@ -506,10 +497,69 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  __func__, sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510289",
      "id" : 989510289,
      "in_reply_to_id" : 980023946,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-rqR",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 514,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1133677328,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510289/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:50:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510289",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510315"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510315"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:50:56Z",
      "diff_hunk" : "@@ -506,10 +497,69 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     return true;\n }\n \n-void SQLiteBatch::CloseCursor()\n+SQLiteCursor::~SQLiteCursor()\n {\n+    sqlite3_clear_bindings(m_cursor_stmt);\n     sqlite3_reset(m_cursor_stmt);\n-    m_cursor_init = false;\n+    int res = sqlite3_finalize(m_cursor_stmt);\n+    if (res != SQLITE_OK) {\n+        LogPrintf(\"%s: cursor closed but could not finalize cursor statement: %s\\n\",\n+                  __func__, sqlite3_errstr(res));\n+    }\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewCursor()\n+{\n+    if (!m_database.m_db) return nullptr;\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>();\n+\n+    const char* stmt_text = \"SELECT key, value FROM main\";\n+    int res = sqlite3_prepare_v2(m_database.m_db, stmt_text, -1, &cursor->m_cursor_stmt, nullptr);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\n+            \"%s: Failed to setup cursor SQL statement: %s\\n\", __func__, sqlite3_errstr(res)));\n+    }\n+\n+    return cursor;\n+}\n+\n+std::unique_ptr<DatabaseCursor> SQLiteBatch::GetNewPrefixCursor(CDataStream& prefix)\n+{\n+    if (prefix.empty()) return nullptr;\n+    if (!m_database.m_db) return nullptr;\n+\n+    // To get just the records we want, the SQL statement does a comparison of the binary data\n+    // where the data must be greater than or equal to the prefix, and less than\n+    // the prefix incremented by one (when interpreted as an integer)\n+    std::vector<std::byte> start_range(prefix.begin(), prefix.end());\n+    std::vector<std::byte> end_range(prefix.begin(), prefix.end());\n+    auto it = end_range.rbegin();\n+    for (; it != end_range.rend(); ++it) {\n+        if (*it == std::byte(0xff)) {\n+            *it = std::byte(0x00);\n+            continue;\n+        }\n+        *it = std::byte(std::to_integer<unsigned char>(*it) + 1);\n+        break;\n+    }\n+    if (it == end_range.rend()) {\n+        end_range.insert(end_range.begin(), std::byte(0x01));\n+    }\n+\n+    std::unique_ptr<SQLiteCursor> cursor = std::make_unique<SQLiteCursor>(start_range, end_range);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510315",
      "id" : 989510315,
      "in_reply_to_id" : 980025026,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-rqr",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 549,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 1133677367,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510315/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:50:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510315",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510615"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510615"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done in `DatabaseCursor`. AFAIK that should also delete in the child classes.",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:51:27Z",
      "diff_hunk" : "@@ -14,19 +14,36 @@ struct bilingual_str;\n namespace wallet {\n class SQLiteDatabase;\n \n+/** RAII class that provides a database cursor */\n+class SQLiteCursor : public DatabaseCursor",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510615",
      "id" : 989510615,
      "in_reply_to_id" : 980028053,
      "line" : 18,
      "node_id" : "PRRC_kwDOABII5846-rvX",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 18,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 5,
      "pull_request_review_id" : 1133677792,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510615/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:51:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510615",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510661"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510661"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:51:32Z",
      "diff_hunk" : "@@ -14,19 +14,36 @@ struct bilingual_str;\n namespace wallet {\n class SQLiteDatabase;\n \n+/** RAII class that provides a database cursor */\n+class SQLiteCursor : public DatabaseCursor\n+{\n+public:\n+    sqlite3_stmt* m_cursor_stmt{nullptr};\n+    // Copies of the prefix things for the prefix cursor.\n+    // Prevents SQLite from accessing temp variables for the prefix things.\n+    std::vector<std::byte> m_prefix_range_start;\n+    std::vector<std::byte> m_prefix_range_end;\n+\n+    explicit SQLiteCursor() {}\n+    explicit SQLiteCursor(std::vector<std::byte> start_range, std::vector<std::byte> end_range)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510661",
      "id" : 989510661,
      "in_reply_to_id" : 980029822,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-rwF",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 28,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : null,
      "pull_request_review_id" : 1133677848,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510661/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:51:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510661",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510727"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:51:38Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510727",
      "id" : 989510727,
      "in_reply_to_id" : 980030921,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-rxH",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 432,
      "original_position" : 264,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1133677935,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510727/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:51:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510727",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510830"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510830"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:51:51Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    CHDChain chain;\n+    ssValue >> chain;\n+    pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    return true;\n+}\n \n-            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n-            {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n-            }\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::MASTER_KEY) {\n-            // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n-            unsigned int nID;\n-            ssKey >> nID;\n-            CMasterKey kMasterKey;\n-            ssValue >> kMasterKey;\n-            if(pwallet->mapMasterKeys.count(nID) != 0)\n-            {\n-                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n-                return false;\n-            }\n-            pwallet->mapMasterKeys[nID] = kMasterKey;\n-            if (pwallet->nMasterKeyMaxID < nID)\n-                pwallet->nMasterKeyMaxID = nID;\n-        } else if (strType == DBKeys::CRYPTED_KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n-            {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n-            }\n-            std::vector<unsigned char> vchPrivKey;\n-            ssValue >> vchPrivKey;\n-\n-            // Get the checksum and check it\n-            bool checksum_valid = false;\n-            if (!ssValue.eof()) {\n-                uint256 checksum;\n-                ssValue >> checksum;\n-                if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n-                    strErr = \"Error reading wallet database: Encrypted key corrupt\";\n-                    return false;\n-                }\n-            }\n+bool WalletBatch::IsKeyType(const std::string& strType)\n+{\n+    return (strType == DBKeys::KEY ||\n+            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+}\n \n-            wss.nCKeys++;\n+static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    int nMinVersion = 0;\n+    if (batch.Read(DBKeys::MINVERSION, nMinVersion)) {\n+        if (nMinVersion > FEATURE_LATEST)\n+            return DBErrors::TOO_NEW;\n+        pwallet->LoadMinVersion(nMinVersion);\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n-                return false;\n-            }\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::KEYMETA) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n-\n-            // Extract some CHDChain info from this metadata if it has any\n-            if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n-                // Get the path from the key origin or from the path string\n-                // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n-                // See https://github.com/bitcoin/bitcoin/pull/12924\n-                bool internal = false;\n-                uint32_t index = 0;\n-                if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n-                    std::vector<uint32_t> path;\n-                    if (keyMeta.has_key_origin) {\n-                        // We have a key origin, so pull it from its path vector\n-                        path = keyMeta.key_origin.path;\n-                    } else {\n-                        // No key origin, have to parse the string\n-                        if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n-                            strErr = \"Error reading wallet database: keymeta with invalid HD keypath\";\n-                            return false;\n-                        }\n-                    }\n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;\n+        }\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-                    // Extract the index and internal from the path\n-                    // Path string is m/0'/k'/i'\n-                    // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n-                    // k == 0 for external, 1 for internal. i is the index\n-                    if (path.size() != 3) {\n-                        strErr = \"Error reading wallet database: keymeta found with unexpected path\";\n-                        return false;\n-                    }\n-                    if (path[0] != 0x80000000) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\", path[0]);\n-                        return false;\n-                    }\n-                    if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\", path[1]);\n-                        return false;\n-                    }\n-                    if ((path[2] & 0x80000000) == 0) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\", path[2]);\n-                        return false;\n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, CDataStream& prefix, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    return LoadRecords(pwallet, batch, key, prefix, load_func);\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            err = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\";\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (script_res.m_result != DBErrors::LOAD_OK) {\n+        return script_res.m_result;\n+    }\n+    result = std::max(result, script_res.m_result);\n+\n+    // Check whether rewrite is needed\n+    if (ckey_res.m_records > 0) {\n+        // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n+        if (last_client == 40000 || last_client == 50000) return DBErrors::NEED_REWRITE;\n+    }\n+\n+    // Load keymeta\n+    std::map<uint160, CHDChain> hd_chains;\n+    LoadResult keymeta_res = LoadRecords(pwallet, batch, DBKeys::KEYMETA,\n+        [&hd_chains] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        CPubKey vchPubKey;\n+        key >> vchPubKey;\n+        CKeyMetadata keyMeta;\n+        value >> keyMeta;\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n+\n+        // Extract some CHDChain info from this metadata if it has any\n+        if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n+            // Get the path from the key origin or from the path string\n+            // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n+            // See https://github.com/bitcoin/bitcoin/pull/12924\n+            bool internal = false;\n+            uint32_t index = 0;\n+            if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n+                std::vector<uint32_t> path;\n+                if (keyMeta.has_key_origin) {\n+                    // We have a key origin, so pull it from its path vector\n+                    path = keyMeta.key_origin.path;\n+                } else {\n+                    // No key origin, have to parse the string\n+                    if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n+                        err = \"Error reading wallet database: keymeta with invalid HD keypath\\n\";\n+                        return DBErrors::NONCRITICAL_ERROR;\n                     }\n-                    internal = path[1] == (1 | 0x80000000);\n-                    index = path[2] & ~0x80000000;\n                 }\n \n-                // Insert a new CHDChain, or get the one that already exists\n-                auto ins = wss.m_hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n-                CHDChain& chain = ins.first->second;\n-                if (ins.second) {\n-                    // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n-                    chain.nVersion = CHDChain::VERSION_HD_BASE;\n-                    chain.seed_id = keyMeta.hd_seed_id;\n+                // Extract the index and internal from the path\n+                // Path string is m/0'/k'/i'\n+                // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n+                // k == 0 for external, 1 for internal. i is the index\n+                if (path.size() != 3) {\n+                    err = \"Error reading wallet database: keymeta found with unexpected path\\n\";\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n-                if (internal) {\n-                    chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n-                    chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n-                } else {\n-                    chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n+                if (path[0] != 0x80000000) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\\n\", path[0]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n+                if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\\n\", path[1]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                if ((path[2] & 0x80000000) == 0) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\\n\", path[2]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                internal = path[1] == (1 | 0x80000000);\n+                index = path[2] & ~0x80000000;\n             }\n-        } else if (strType == DBKeys::WATCHMETA) {\n-            CScript script;\n-            ssKey >> script;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadScriptMetadata(CScriptID(script), keyMeta);\n-        } else if (strType == DBKeys::DEFAULTKEY) {\n-            // We don't want or need the default key, but if there is one set,\n-            // we want to make sure that it is valid so that we can detect corruption\n-            CPubKey vchPubKey;\n-            ssValue >> vchPubKey;\n-            if (!vchPubKey.IsValid()) {\n-                strErr = \"Error reading wallet database: Default Key corrupt\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::POOL) {\n-            int64_t nIndex;\n-            ssKey >> nIndex;\n-            CKeyPool keypool;\n-            ssValue >> keypool;\n-\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyPool(nIndex, keypool);\n-        } else if (strType == DBKeys::CSCRIPT) {\n-            uint160 hash;\n-            ssKey >> hash;\n-            CScript script;\n-            ssValue >> script;\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::ORDERPOSNEXT) {\n-            ssValue >> pwallet->nOrderPosNext;\n-        } else if (strType == DBKeys::DESTDATA) {\n-            std::string strAddress, strKey, strValue;\n-            ssKey >> strAddress;\n-            ssKey >> strKey;\n-            ssValue >> strValue;\n-            pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n-        } else if (strType == DBKeys::HDCHAIN) {\n-            CHDChain chain;\n-            ssValue >> chain;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n-        } else if (strType == DBKeys::OLD_KEY) {\n-            strErr = \"Found unsupported 'wkey' record, try loading with version 0.18\";\n-            return false;\n-        } else if (strType == DBKeys::ACTIVEEXTERNALSPK || strType == DBKeys::ACTIVEINTERNALSPK) {\n-            uint8_t type;\n-            ssKey >> type;\n-            uint256 id;\n-            ssValue >> id;\n \n-            bool internal = strType == DBKeys::ACTIVEINTERNALSPK;\n-            auto& spk_mans = internal ? wss.m_active_internal_spks : wss.m_active_external_spks;\n-            if (spk_mans.count(static_cast<OutputType>(type)) > 0) {\n-                strErr = \"Multiple ScriptPubKeyMans specified for a single type\";\n-                return false;\n+            // Insert a new CHDChain, or get the one that already exists\n+            auto ins = hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n+            CHDChain& chain = ins.first->second;\n+            if (ins.second) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510830",
      "id" : 989510830,
      "in_reply_to_id" : 980034855,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-ryu",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 634,
      "original_position" : 636,
      "original_start_line" : 632,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1133678111,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510830/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-06T21:51:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510830",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510855"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510855"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:51:55Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    CHDChain chain;\n+    ssValue >> chain;\n+    pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    return true;\n+}\n \n-            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n-            {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n-            }\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::MASTER_KEY) {\n-            // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n-            unsigned int nID;\n-            ssKey >> nID;\n-            CMasterKey kMasterKey;\n-            ssValue >> kMasterKey;\n-            if(pwallet->mapMasterKeys.count(nID) != 0)\n-            {\n-                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n-                return false;\n-            }\n-            pwallet->mapMasterKeys[nID] = kMasterKey;\n-            if (pwallet->nMasterKeyMaxID < nID)\n-                pwallet->nMasterKeyMaxID = nID;\n-        } else if (strType == DBKeys::CRYPTED_KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n-            {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n-            }\n-            std::vector<unsigned char> vchPrivKey;\n-            ssValue >> vchPrivKey;\n-\n-            // Get the checksum and check it\n-            bool checksum_valid = false;\n-            if (!ssValue.eof()) {\n-                uint256 checksum;\n-                ssValue >> checksum;\n-                if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n-                    strErr = \"Error reading wallet database: Encrypted key corrupt\";\n-                    return false;\n-                }\n-            }\n+bool WalletBatch::IsKeyType(const std::string& strType)\n+{\n+    return (strType == DBKeys::KEY ||\n+            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+}\n \n-            wss.nCKeys++;\n+static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    int nMinVersion = 0;\n+    if (batch.Read(DBKeys::MINVERSION, nMinVersion)) {\n+        if (nMinVersion > FEATURE_LATEST)\n+            return DBErrors::TOO_NEW;\n+        pwallet->LoadMinVersion(nMinVersion);\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n-                return false;\n-            }\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::KEYMETA) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n-\n-            // Extract some CHDChain info from this metadata if it has any\n-            if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n-                // Get the path from the key origin or from the path string\n-                // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n-                // See https://github.com/bitcoin/bitcoin/pull/12924\n-                bool internal = false;\n-                uint32_t index = 0;\n-                if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n-                    std::vector<uint32_t> path;\n-                    if (keyMeta.has_key_origin) {\n-                        // We have a key origin, so pull it from its path vector\n-                        path = keyMeta.key_origin.path;\n-                    } else {\n-                        // No key origin, have to parse the string\n-                        if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n-                            strErr = \"Error reading wallet database: keymeta with invalid HD keypath\";\n-                            return false;\n-                        }\n-                    }\n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;\n+        }\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-                    // Extract the index and internal from the path\n-                    // Path string is m/0'/k'/i'\n-                    // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n-                    // k == 0 for external, 1 for internal. i is the index\n-                    if (path.size() != 3) {\n-                        strErr = \"Error reading wallet database: keymeta found with unexpected path\";\n-                        return false;\n-                    }\n-                    if (path[0] != 0x80000000) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\", path[0]);\n-                        return false;\n-                    }\n-                    if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\", path[1]);\n-                        return false;\n-                    }\n-                    if ((path[2] & 0x80000000) == 0) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\", path[2]);\n-                        return false;\n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, CDataStream& prefix, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    return LoadRecords(pwallet, batch, key, prefix, load_func);\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            err = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\";\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (script_res.m_result != DBErrors::LOAD_OK) {\n+        return script_res.m_result;\n+    }\n+    result = std::max(result, script_res.m_result);\n+\n+    // Check whether rewrite is needed\n+    if (ckey_res.m_records > 0) {\n+        // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n+        if (last_client == 40000 || last_client == 50000) return DBErrors::NEED_REWRITE;\n+    }\n+\n+    // Load keymeta\n+    std::map<uint160, CHDChain> hd_chains;\n+    LoadResult keymeta_res = LoadRecords(pwallet, batch, DBKeys::KEYMETA,\n+        [&hd_chains] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        CPubKey vchPubKey;\n+        key >> vchPubKey;\n+        CKeyMetadata keyMeta;\n+        value >> keyMeta;\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n+\n+        // Extract some CHDChain info from this metadata if it has any\n+        if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n+            // Get the path from the key origin or from the path string\n+            // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n+            // See https://github.com/bitcoin/bitcoin/pull/12924\n+            bool internal = false;\n+            uint32_t index = 0;\n+            if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n+                std::vector<uint32_t> path;\n+                if (keyMeta.has_key_origin) {\n+                    // We have a key origin, so pull it from its path vector\n+                    path = keyMeta.key_origin.path;\n+                } else {\n+                    // No key origin, have to parse the string\n+                    if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n+                        err = \"Error reading wallet database: keymeta with invalid HD keypath\\n\";\n+                        return DBErrors::NONCRITICAL_ERROR;\n                     }\n-                    internal = path[1] == (1 | 0x80000000);\n-                    index = path[2] & ~0x80000000;\n                 }\n \n-                // Insert a new CHDChain, or get the one that already exists\n-                auto ins = wss.m_hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n-                CHDChain& chain = ins.first->second;\n-                if (ins.second) {\n-                    // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n-                    chain.nVersion = CHDChain::VERSION_HD_BASE;\n-                    chain.seed_id = keyMeta.hd_seed_id;\n+                // Extract the index and internal from the path\n+                // Path string is m/0'/k'/i'\n+                // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n+                // k == 0 for external, 1 for internal. i is the index\n+                if (path.size() != 3) {\n+                    err = \"Error reading wallet database: keymeta found with unexpected path\\n\";\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n-                if (internal) {\n-                    chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n-                    chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n-                } else {\n-                    chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n+                if (path[0] != 0x80000000) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\\n\", path[0]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n+                if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\\n\", path[1]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                if ((path[2] & 0x80000000) == 0) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\\n\", path[2]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                internal = path[1] == (1 | 0x80000000);\n+                index = path[2] & ~0x80000000;\n             }\n-        } else if (strType == DBKeys::WATCHMETA) {\n-            CScript script;\n-            ssKey >> script;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadScriptMetadata(CScriptID(script), keyMeta);\n-        } else if (strType == DBKeys::DEFAULTKEY) {\n-            // We don't want or need the default key, but if there is one set,\n-            // we want to make sure that it is valid so that we can detect corruption\n-            CPubKey vchPubKey;\n-            ssValue >> vchPubKey;\n-            if (!vchPubKey.IsValid()) {\n-                strErr = \"Error reading wallet database: Default Key corrupt\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::POOL) {\n-            int64_t nIndex;\n-            ssKey >> nIndex;\n-            CKeyPool keypool;\n-            ssValue >> keypool;\n-\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyPool(nIndex, keypool);\n-        } else if (strType == DBKeys::CSCRIPT) {\n-            uint160 hash;\n-            ssKey >> hash;\n-            CScript script;\n-            ssValue >> script;\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::ORDERPOSNEXT) {\n-            ssValue >> pwallet->nOrderPosNext;\n-        } else if (strType == DBKeys::DESTDATA) {\n-            std::string strAddress, strKey, strValue;\n-            ssKey >> strAddress;\n-            ssKey >> strKey;\n-            ssValue >> strValue;\n-            pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n-        } else if (strType == DBKeys::HDCHAIN) {\n-            CHDChain chain;\n-            ssValue >> chain;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n-        } else if (strType == DBKeys::OLD_KEY) {\n-            strErr = \"Found unsupported 'wkey' record, try loading with version 0.18\";\n-            return false;\n-        } else if (strType == DBKeys::ACTIVEEXTERNALSPK || strType == DBKeys::ACTIVEINTERNALSPK) {\n-            uint8_t type;\n-            ssKey >> type;\n-            uint256 id;\n-            ssValue >> id;\n \n-            bool internal = strType == DBKeys::ACTIVEINTERNALSPK;\n-            auto& spk_mans = internal ? wss.m_active_internal_spks : wss.m_active_external_spks;\n-            if (spk_mans.count(static_cast<OutputType>(type)) > 0) {\n-                strErr = \"Multiple ScriptPubKeyMans specified for a single type\";\n-                return false;\n+            // Insert a new CHDChain, or get the one that already exists\n+            auto ins = hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n+            CHDChain& chain = ins.first->second;\n+            if (ins.second) {\n+                // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n+                chain.nVersion = CHDChain::VERSION_HD_BASE;\n+                chain.seed_id = keyMeta.hd_seed_id;\n             }\n-            spk_mans[static_cast<OutputType>(type)] = id;\n-        } else if (strType == DBKeys::WALLETDESCRIPTOR) {\n-            uint256 id;\n-            ssKey >> id;\n-            WalletDescriptor desc;\n-            try {\n-                ssValue >> desc;\n-            } catch (const std::ios_base::failure& e) {\n-                strErr = e.what();\n-                wss.descriptor_unknown = true;\n-                return false;\n+            if (internal) {\n+                chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n+                chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n+            } else {\n+                chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n             }\n-            if (wss.m_descriptor_caches.count(id) == 0) {\n-                wss.m_descriptor_caches[id] = DescriptorCache();\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, script_res.m_result);\n+\n+    // Set inactive chains\n+    if (hd_chains.size() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510855",
      "id" : 989510855,
      "in_reply_to_id" : 980036012,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-rzH",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 651,
      "original_position" : 666,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1133678151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510855/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:51:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510855",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510894"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510894"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:52:00Z",
      "diff_hunk" : "@@ -297,401 +297,556 @@ bool WalletBatch::EraseLockedUTXO(const COutPoint& output)\n     return EraseIC(std::make_pair(DBKeys::LOCKED_UTXO, std::make_pair(output.hash, output.n)));\n }\n \n-class CWalletScanState {\n-public:\n-    unsigned int nKeys{0};\n-    unsigned int nCKeys{0};\n-    unsigned int nWatchKeys{0};\n-    unsigned int nKeyMeta{0};\n-    unsigned int m_unknown_records{0};\n-    bool fIsEncrypted{false};\n-    bool fAnyUnordered{false};\n-    std::vector<uint256> vWalletUpgrade;\n-    std::map<OutputType, uint256> m_active_external_spks;\n-    std::map<OutputType, uint256> m_active_internal_spks;\n-    std::map<uint256, DescriptorCache> m_descriptor_caches;\n-    std::map<std::pair<uint256, CKeyID>, CKey> m_descriptor_keys;\n-    std::map<std::pair<uint256, CKeyID>, std::pair<CPubKey, std::vector<unsigned char>>> m_descriptor_crypt_keys;\n-    std::map<uint160, CHDChain> m_hd_chains;\n-    bool tx_corrupt{false};\n-    bool descriptor_unknown{false};\n-\n-    CWalletScanState() = default;\n-};\n-\n-static bool\n-ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn = nullptr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+bool LoadKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n {\n+    LOCK(pwallet->cs_wallet);\n     try {\n-        // Unserialize\n-        // Taking advantage of the fact that pair serialization\n-        // is just the two items serialized one after the other\n-        ssKey >> strType;\n-        // If we have a filter, check if this matches the filter\n-        if (filter_fn && !filter_fn(strType)) {\n-            return true;\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n         }\n-        if (strType == DBKeys::NAME) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            std::string label;\n-            ssValue >> label;\n-            pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n-        } else if (strType == DBKeys::PURPOSE) {\n-            std::string strAddress;\n-            ssKey >> strAddress;\n-            ssValue >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n-        } else if (strType == DBKeys::TX) {\n-            uint256 hash;\n-            ssKey >> hash;\n-            // LoadToWallet call below creates a new CWalletTx that fill_wtx\n-            // callback fills with transaction metadata.\n-            auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n-                if(!new_tx) {\n-                    // There's some corruption here since the tx we just tried to load was already in the wallet.\n-                    // We don't consider this type of corruption critical, and can fix it by removing tx data and\n-                    // rescanning.\n-                    wss.tx_corrupt = true;\n-                    return false;\n-                }\n-                ssValue >> wtx;\n-                if (wtx.GetHash() != hash)\n-                    return false;\n+        CKey key;\n+        CPrivKey pkey;\n+        uint256 hash;\n+\n+        ssValue >> pkey;\n+\n+        // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n+        // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+        // using EC operations as a checksum.\n+        // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+        // remaining backwards-compatible.\n+        try\n+        {\n+            ssValue >> hash;\n+        }\n+        catch (const std::ios_base::failure&) {}\n \n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        uint8_t fTmp;\n-                        uint8_t fUnused;\n-                        std::string unused_string;\n-                        ssValue >> fTmp >> fUnused >> unused_string;\n-                        strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d %s\",\n-                                           wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    wss.vWalletUpgrade.push_back(hash);\n-                }\n+        bool fSkipCheck = false;\n \n-                if (wtx.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n+        if (!hash.IsNull())\n+        {\n+            // hash pubkey/privkey to accelerate wallet load\n+            std::vector<unsigned char> vchKey;\n+            vchKey.reserve(vchPubKey.size() + pkey.size());\n+            vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+            vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n \n-                return true;\n-            };\n-            if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n-                return false;\n-            }\n-        } else if (strType == DBKeys::WATCHS) {\n-            wss.nWatchKeys++;\n-            CScript script;\n-            ssKey >> script;\n-            uint8_t fYes;\n-            ssValue >> fYes;\n-            if (fYes == '1') {\n-                pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n-            }\n-        } else if (strType == DBKeys::KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n+            if (Hash(vchKey) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n                 return false;\n             }\n-            CKey key;\n-            CPrivKey pkey;\n-            uint256 hash;\n \n-            wss.nKeys++;\n-            ssValue >> pkey;\n+            fSkipCheck = true;\n+        }\n \n-            // Old wallets store keys as DBKeys::KEY [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as DBKeys::KEY [pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n+        if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+        {\n+            strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+            return false;\n+        }\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool LoadCryptedKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        CPubKey vchPubKey;\n+        ssKey >> vchPubKey;\n+        if (!vchPubKey.IsValid())\n+        {\n+            strErr = \"Error reading wallet database: CPubKey corrupt\";\n+            return false;\n+        }\n+        std::vector<unsigned char> vchPrivKey;\n+        ssValue >> vchPrivKey;\n+\n+        // Get the checksum and check it\n+        bool checksum_valid = false;\n+        if (!ssValue.eof()) {\n+            uint256 checksum;\n+            ssValue >> checksum;\n+            if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n+                strErr = \"Error reading wallet database: Encrypted key corrupt\";\n+                return false;\n             }\n-            catch (const std::ios_base::failure&) {}\n+        }\n \n-            bool fSkipCheck = false;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n+        {\n+            strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-            if (!hash.IsNull())\n-            {\n-                // hash pubkey/privkey to accelerate wallet load\n-                std::vector<unsigned char> vchKey;\n-                vchKey.reserve(vchPubKey.size() + pkey.size());\n-                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n-                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+bool LoadEncryptionKey(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    try {\n+        // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n+        unsigned int nID;\n+        ssKey >> nID;\n+        CMasterKey kMasterKey;\n+        ssValue >> kMasterKey;\n+        if(pwallet->mapMasterKeys.count(nID) != 0)\n+        {\n+            strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+            return false;\n+        }\n+        pwallet->mapMasterKeys[nID] = kMasterKey;\n+        if (pwallet->nMasterKeyMaxID < nID)\n+            pwallet->nMasterKeyMaxID = nID;\n \n-                if (Hash(vchKey) != hash)\n-                {\n-                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                    return false;\n-                }\n+    } catch (const std::exception& e) {\n+        if (strErr.empty()) {\n+            strErr = e.what();\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n \n-                fSkipCheck = true;\n-            }\n+bool LoadHDChain(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strErr)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    CHDChain chain;\n+    ssValue >> chain;\n+    pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    return true;\n+}\n \n-            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n-            {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n-            }\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::MASTER_KEY) {\n-            // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n-            unsigned int nID;\n-            ssKey >> nID;\n-            CMasterKey kMasterKey;\n-            ssValue >> kMasterKey;\n-            if(pwallet->mapMasterKeys.count(nID) != 0)\n-            {\n-                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n-                return false;\n-            }\n-            pwallet->mapMasterKeys[nID] = kMasterKey;\n-            if (pwallet->nMasterKeyMaxID < nID)\n-                pwallet->nMasterKeyMaxID = nID;\n-        } else if (strType == DBKeys::CRYPTED_KEY) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            if (!vchPubKey.IsValid())\n-            {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n-            }\n-            std::vector<unsigned char> vchPrivKey;\n-            ssValue >> vchPrivKey;\n-\n-            // Get the checksum and check it\n-            bool checksum_valid = false;\n-            if (!ssValue.eof()) {\n-                uint256 checksum;\n-                ssValue >> checksum;\n-                if ((checksum_valid = Hash(vchPrivKey) != checksum)) {\n-                    strErr = \"Error reading wallet database: Encrypted key corrupt\";\n-                    return false;\n-                }\n-            }\n+bool WalletBatch::IsKeyType(const std::string& strType)\n+{\n+    return (strType == DBKeys::KEY ||\n+            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+}\n \n-            wss.nCKeys++;\n+static DBErrors LoadMinVersion(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    int nMinVersion = 0;\n+    if (batch.Read(DBKeys::MINVERSION, nMinVersion)) {\n+        if (nMinVersion > FEATURE_LATEST)\n+            return DBErrors::TOO_NEW;\n+        pwallet->LoadMinVersion(nMinVersion);\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey, checksum_valid))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n-                return false;\n-            }\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::KEYMETA) {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n-\n-            // Extract some CHDChain info from this metadata if it has any\n-            if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n-                // Get the path from the key origin or from the path string\n-                // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n-                // See https://github.com/bitcoin/bitcoin/pull/12924\n-                bool internal = false;\n-                uint32_t index = 0;\n-                if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n-                    std::vector<uint32_t> path;\n-                    if (keyMeta.has_key_origin) {\n-                        // We have a key origin, so pull it from its path vector\n-                        path = keyMeta.key_origin.path;\n-                    } else {\n-                        // No key origin, have to parse the string\n-                        if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n-                            strErr = \"Error reading wallet database: keymeta with invalid HD keypath\";\n-                            return false;\n-                        }\n-                    }\n+static DBErrors LoadWalletFlags(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    uint64_t flags;\n+    if (batch.Read(DBKeys::FLAGS, flags)) {\n+        if (!pwallet->LoadWalletFlags(flags)) {\n+            pwallet->WalletLogPrintf(\"Error reading wallet database: Unknown non-tolerable wallet flags found\\n\");\n+            return DBErrors::TOO_NEW;\n+        }\n+    }\n+    return DBErrors::LOAD_OK;\n+}\n \n-                    // Extract the index and internal from the path\n-                    // Path string is m/0'/k'/i'\n-                    // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n-                    // k == 0 for external, 1 for internal. i is the index\n-                    if (path.size() != 3) {\n-                        strErr = \"Error reading wallet database: keymeta found with unexpected path\";\n-                        return false;\n-                    }\n-                    if (path[0] != 0x80000000) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\", path[0]);\n-                        return false;\n-                    }\n-                    if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\", path[1]);\n-                        return false;\n-                    }\n-                    if ((path[2] & 0x80000000) == 0) {\n-                        strErr = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\", path[2]);\n-                        return false;\n+struct LoadResult\n+{\n+    DBErrors m_result{DBErrors::LOAD_OK};\n+    std::string m_error{};\n+    int m_records{0};\n+};\n+\n+using LoadFunc = std::function<DBErrors(CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err)>;\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, CDataStream& prefix, LoadFunc load_func)\n+{\n+    LoadResult result;\n+    CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+    CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+\n+    std::unique_ptr<DatabaseCursor> cursor = batch.GetNewPrefixCursor(prefix);\n+    if (!cursor) {\n+        pwallet->WalletLogPrintf(\"Error getting database cursor for '%s' records\\n\", key);\n+        result.m_result = DBErrors::CORRUPT;\n+        return result;\n+    }\n+\n+    while (true) {\n+        bool complete;\n+        bool ret = cursor->Next(ssKey, ssValue, complete);\n+        if (complete) {\n+            break;\n+        } else if (!ret) {\n+            pwallet->WalletLogPrintf(\"Error reading next '%s' record for wallet database\\n\", key);\n+            result.m_result = DBErrors::CORRUPT;\n+            return result;\n+        }\n+        std::string type;\n+        ssKey >> type;\n+        assert(type == key);\n+        if ((result.m_result = std::max(result.m_result, load_func(pwallet, ssKey, ssValue, result.m_error))) == DBErrors::CORRUPT) {\n+            pwallet->WalletLogPrintf(\"%s\\n\", result.m_error);\n+        }\n+        ++result.m_records;\n+    }\n+    return result;\n+}\n+\n+static LoadResult LoadRecords(CWallet* pwallet, DatabaseBatch& batch, const std::string& key, LoadFunc load_func)\n+{\n+    CDataStream prefix(0, 0);\n+    prefix << key;\n+    return LoadRecords(pwallet, batch, key, prefix, load_func);\n+}\n+\n+static DBErrors LoadLegacyWalletRecords(CWallet* pwallet, DatabaseBatch& batch, int last_client) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load HD Chain\n+    CHDChain chain;\n+    if (batch.Read(DBKeys::HDCHAIN, chain)) {\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n+    }\n+\n+    // Load unencrypted keys\n+    LoadResult key_res = LoadRecords(pwallet, batch, DBKeys::KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, key_res.m_result);\n+\n+    // Load encrypted keys\n+    LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::CRYPTED_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadCryptedKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, ckey_res.m_result);\n+\n+    // Load scripts\n+    LoadResult script_res = LoadRecords(pwallet, batch, DBKeys::CSCRIPT,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        uint160 hash;\n+        key >> hash;\n+        CScript script;\n+        value >> script;\n+        if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n+        {\n+            err = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\\n\";\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (script_res.m_result != DBErrors::LOAD_OK) {\n+        return script_res.m_result;\n+    }\n+    result = std::max(result, script_res.m_result);\n+\n+    // Check whether rewrite is needed\n+    if (ckey_res.m_records > 0) {\n+        // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n+        if (last_client == 40000 || last_client == 50000) return DBErrors::NEED_REWRITE;\n+    }\n+\n+    // Load keymeta\n+    std::map<uint160, CHDChain> hd_chains;\n+    LoadResult keymeta_res = LoadRecords(pwallet, batch, DBKeys::KEYMETA,\n+        [&hd_chains] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        CPubKey vchPubKey;\n+        key >> vchPubKey;\n+        CKeyMetadata keyMeta;\n+        value >> keyMeta;\n+        pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n+\n+        // Extract some CHDChain info from this metadata if it has any\n+        if (keyMeta.nVersion >= CKeyMetadata::VERSION_WITH_HDDATA && !keyMeta.hd_seed_id.IsNull() && keyMeta.hdKeypath.size() > 0) {\n+            // Get the path from the key origin or from the path string\n+            // Not applicable when path is \"s\" or \"m\" as those indicate a seed\n+            // See https://github.com/bitcoin/bitcoin/pull/12924\n+            bool internal = false;\n+            uint32_t index = 0;\n+            if (keyMeta.hdKeypath != \"s\" && keyMeta.hdKeypath != \"m\") {\n+                std::vector<uint32_t> path;\n+                if (keyMeta.has_key_origin) {\n+                    // We have a key origin, so pull it from its path vector\n+                    path = keyMeta.key_origin.path;\n+                } else {\n+                    // No key origin, have to parse the string\n+                    if (!ParseHDKeypath(keyMeta.hdKeypath, path)) {\n+                        err = \"Error reading wallet database: keymeta with invalid HD keypath\\n\";\n+                        return DBErrors::NONCRITICAL_ERROR;\n                     }\n-                    internal = path[1] == (1 | 0x80000000);\n-                    index = path[2] & ~0x80000000;\n                 }\n \n-                // Insert a new CHDChain, or get the one that already exists\n-                auto ins = wss.m_hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n-                CHDChain& chain = ins.first->second;\n-                if (ins.second) {\n-                    // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n-                    chain.nVersion = CHDChain::VERSION_HD_BASE;\n-                    chain.seed_id = keyMeta.hd_seed_id;\n+                // Extract the index and internal from the path\n+                // Path string is m/0'/k'/i'\n+                // Path vector is [0', k', i'] (but as ints OR'd with the hardened bit\n+                // k == 0 for external, 1 for internal. i is the index\n+                if (path.size() != 3) {\n+                    err = \"Error reading wallet database: keymeta found with unexpected path\\n\";\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n-                if (internal) {\n-                    chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n-                    chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n-                } else {\n-                    chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n+                if (path[0] != 0x80000000) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000) for the element at index 0\\n\", path[0]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n                 }\n+                if (path[1] != 0x80000000 && path[1] != (1 | 0x80000000)) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected 0x80000000 or 0x80000001) for the element at index 1\\n\", path[1]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                if ((path[2] & 0x80000000) == 0) {\n+                    err = strprintf(\"Unexpected path index of 0x%08x (expected to be greater than or equal to 0x80000000)\\n\", path[2]);\n+                    return DBErrors::NONCRITICAL_ERROR;\n+                }\n+                internal = path[1] == (1 | 0x80000000);\n+                index = path[2] & ~0x80000000;\n             }\n-        } else if (strType == DBKeys::WATCHMETA) {\n-            CScript script;\n-            ssKey >> script;\n-            CKeyMetadata keyMeta;\n-            ssValue >> keyMeta;\n-            wss.nKeyMeta++;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadScriptMetadata(CScriptID(script), keyMeta);\n-        } else if (strType == DBKeys::DEFAULTKEY) {\n-            // We don't want or need the default key, but if there is one set,\n-            // we want to make sure that it is valid so that we can detect corruption\n-            CPubKey vchPubKey;\n-            ssValue >> vchPubKey;\n-            if (!vchPubKey.IsValid()) {\n-                strErr = \"Error reading wallet database: Default Key corrupt\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::POOL) {\n-            int64_t nIndex;\n-            ssKey >> nIndex;\n-            CKeyPool keypool;\n-            ssValue >> keypool;\n-\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadKeyPool(nIndex, keypool);\n-        } else if (strType == DBKeys::CSCRIPT) {\n-            uint160 hash;\n-            ssKey >> hash;\n-            CScript script;\n-            ssValue >> script;\n-            if (!pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadCScript(script))\n-            {\n-                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\";\n-                return false;\n-            }\n-        } else if (strType == DBKeys::ORDERPOSNEXT) {\n-            ssValue >> pwallet->nOrderPosNext;\n-        } else if (strType == DBKeys::DESTDATA) {\n-            std::string strAddress, strKey, strValue;\n-            ssKey >> strAddress;\n-            ssKey >> strKey;\n-            ssValue >> strValue;\n-            pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n-        } else if (strType == DBKeys::HDCHAIN) {\n-            CHDChain chain;\n-            ssValue >> chain;\n-            pwallet->GetOrCreateLegacyScriptPubKeyMan()->LoadHDChain(chain);\n-        } else if (strType == DBKeys::OLD_KEY) {\n-            strErr = \"Found unsupported 'wkey' record, try loading with version 0.18\";\n-            return false;\n-        } else if (strType == DBKeys::ACTIVEEXTERNALSPK || strType == DBKeys::ACTIVEINTERNALSPK) {\n-            uint8_t type;\n-            ssKey >> type;\n-            uint256 id;\n-            ssValue >> id;\n \n-            bool internal = strType == DBKeys::ACTIVEINTERNALSPK;\n-            auto& spk_mans = internal ? wss.m_active_internal_spks : wss.m_active_external_spks;\n-            if (spk_mans.count(static_cast<OutputType>(type)) > 0) {\n-                strErr = \"Multiple ScriptPubKeyMans specified for a single type\";\n-                return false;\n+            // Insert a new CHDChain, or get the one that already exists\n+            auto ins = hd_chains.emplace(keyMeta.hd_seed_id, CHDChain());\n+            CHDChain& chain = ins.first->second;\n+            if (ins.second) {\n+                // For new chains, we want to default to VERSION_HD_BASE until we see an internal\n+                chain.nVersion = CHDChain::VERSION_HD_BASE;\n+                chain.seed_id = keyMeta.hd_seed_id;\n             }\n-            spk_mans[static_cast<OutputType>(type)] = id;\n-        } else if (strType == DBKeys::WALLETDESCRIPTOR) {\n-            uint256 id;\n-            ssKey >> id;\n-            WalletDescriptor desc;\n-            try {\n-                ssValue >> desc;\n-            } catch (const std::ios_base::failure& e) {\n-                strErr = e.what();\n-                wss.descriptor_unknown = true;\n-                return false;\n+            if (internal) {\n+                chain.nVersion = CHDChain::VERSION_HD_CHAIN_SPLIT;\n+                chain.nInternalChainCounter = std::max(chain.nInternalChainCounter, index + 1);\n+            } else {\n+                chain.nExternalChainCounter = std::max(chain.nExternalChainCounter, index + 1);\n             }\n-            if (wss.m_descriptor_caches.count(id) == 0) {\n-                wss.m_descriptor_caches[id] = DescriptorCache();\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, script_res.m_result);\n+\n+    // Set inactive chains\n+    if (hd_chains.size() > 0) {\n+        LegacyScriptPubKeyMan* legacy_spkm = pwallet->GetLegacyScriptPubKeyMan();\n+        if (!legacy_spkm) {\n+            pwallet->WalletLogPrintf(\"Inactive HD Chains found but no Legacy ScriptPubKeyMan\\n\");\n+            return DBErrors::CORRUPT;\n+        }\n+        for (const auto& chain_pair : hd_chains) {\n+            if (chain_pair.first != pwallet->GetLegacyScriptPubKeyMan()->GetHDChain().seed_id) {\n+                pwallet->GetLegacyScriptPubKeyMan()->AddInactiveHDChain(chain_pair.second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510894",
      "id" : 989510894,
      "in_reply_to_id" : 980038494,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-rzu",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 659,
      "original_position" : 674,
      "original_start_line" : 657,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1133678214,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510894/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-06T21:52:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510894",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:52:03Z",
      "diff_hunk" : "@@ -701,77 +856,228 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n \n             if (Hash(to_hash) != hash)\n             {\n-                strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n-                return false;\n+                err = \"Error reading wallet database: descriptor unencrypted key CPubKey/CPrivKey corrupt\\n\";\n+                return DBErrors::CORRUPT;\n             }\n \n-            if (!key.Load(pkey, pubkey, true))\n+            if (!privkey.Load(pkey, pubkey, true))\n             {\n-                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                return false;\n+                err = \"Error reading wallet database: descriptor unencrypted key CPrivKey corrupt\\n\";\n+                return DBErrors::CORRUPT;\n             }\n-            wss.m_descriptor_keys.insert(std::make_pair(std::make_pair(desc_id, pubkey.GetID()), key));\n-        } else if (strType == DBKeys::WALLETDESCRIPTORCKEY) {\n+            spk_man->AddKey(pubkey.GetID(), privkey);\n+            return DBErrors::LOAD_OK;\n+        });\n+        result = std::max(result, key_res.m_result);\n+        num_keys = key_res.m_records;\n+\n+        // Get encrypted keys\n+        prefix = PrefixStream(DBKeys::WALLETDESCRIPTORCKEY, id);\n+        LoadResult ckey_res = LoadRecords(pwallet, batch, DBKeys::WALLETDESCRIPTORCKEY, prefix,\n+            [&id, &num_ckeys, &spk_man] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n             uint256 desc_id;\n             CPubKey pubkey;\n-            ssKey >> desc_id;\n-            ssKey >> pubkey;\n+            key >> desc_id;\n+            assert(desc_id == id);\n+            key >> pubkey;\n             if (!pubkey.IsValid())\n             {\n-                strErr = \"Error reading wallet database: CPubKey corrupt\";\n-                return false;\n+                err = \"Error reading wallet database: descriptor encrypted key CPubKey corrupt\\n\";\n+                return DBErrors::CORRUPT;\n             }\n             std::vector<unsigned char> privkey;\n-            ssValue >> privkey;\n-            wss.nCKeys++;\n+            value >> privkey;\n+            num_ckeys++;\n \n-            wss.m_descriptor_crypt_keys.insert(std::make_pair(std::make_pair(desc_id, pubkey.GetID()), std::make_pair(pubkey, privkey)));\n-            wss.fIsEncrypted = true;\n-        } else if (strType == DBKeys::LOCKED_UTXO) {\n-            uint256 hash;\n-            uint32_t n;\n-            ssKey >> hash;\n-            ssKey >> n;\n-            pwallet->LockCoin(COutPoint(hash, n));\n-        } else if (strType != DBKeys::BESTBLOCK && strType != DBKeys::BESTBLOCK_NOMERKLE &&\n-                   strType != DBKeys::MINVERSION && strType != DBKeys::ACENTRY &&\n-                   strType != DBKeys::VERSION && strType != DBKeys::SETTINGS &&\n-                   strType != DBKeys::FLAGS) {\n-            wss.m_unknown_records++;\n-        }\n-    } catch (const std::exception& e) {\n-        if (strErr.empty()) {\n-            strErr = e.what();\n-        }\n-        return false;\n-    } catch (...) {\n-        if (strErr.empty()) {\n-            strErr = \"Caught unknown exception in ReadKeyValue\";\n+            spk_man->AddCryptedKey(pubkey.GetID(), pubkey, privkey);\n+            return DBErrors::LOAD_OK;\n+        });\n+        result = std::max(result, ckey_res.m_result);\n+        num_ckeys = ckey_res.m_records;\n+\n+        return result;\n+    });\n+\n+    pwallet->WalletLogPrintf(\"Descriptors: %u, Descriptor Keys: %u plaintext, %u encrypted, %u total.\\n\",\n+           desc_res.m_records, num_keys, num_ckeys, num_keys + num_ckeys);\n+\n+    return desc_res.m_result;\n+}\n+\n+static DBErrors LoadAddressBookRecords(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load name record\n+    LoadResult name_res = LoadRecords(pwallet, batch, DBKeys::NAME,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        std::string strAddress;\n+        key >> strAddress;\n+        std::string label;\n+        value >> label;\n+        pwallet->m_address_book[DecodeDestination(strAddress)].SetLabel(label);\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (name_res.m_result != DBErrors::LOAD_OK) return name_res.m_result;\n+\n+    // Load purpose record\n+    LoadResult purpose_res = LoadRecords(pwallet, batch, DBKeys::PURPOSE,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        std::string strAddress;\n+        key >> strAddress;\n+        value >> pwallet->m_address_book[DecodeDestination(strAddress)].purpose;\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (purpose_res.m_result != DBErrors::LOAD_OK) return purpose_res.m_result;\n+\n+    // Load destination data record\n+    LoadResult dest_res = LoadRecords(pwallet, batch, DBKeys::DESTDATA,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        std::string strAddress, strKey, strValue;\n+        key >> strAddress;\n+        key >> strKey;\n+        value >> strValue;\n+        pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);\n+        return DBErrors::LOAD_OK;\n+    });\n+    if (dest_res.m_result != DBErrors::LOAD_OK) return dest_res.m_result;\n+\n+    return DBErrors::LOAD_OK;\n+}\n+\n+static DBErrors LoadTxRecords(CWallet* pwallet, DatabaseBatch& batch, std::vector<uint256> upgraded_txs, bool& any_unordered) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    AssertLockHeld(pwallet->cs_wallet);\n+    DBErrors result = DBErrors::LOAD_OK;\n+\n+    // Load tx record\n+    bool corrupted_tx = false;\n+    any_unordered = false;\n+    LoadResult tx_res = LoadRecords(pwallet, batch, DBKeys::TX,\n+        [&corrupted_tx, &any_unordered, &upgraded_txs] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        DBErrors result = DBErrors::LOAD_OK;\n+        uint256 hash;\n+        key >> hash;\n+        // LoadToWallet call below creates a new CWalletTx that fill_wtx\n+        // callback fills with transaction metadata.\n+        auto fill_wtx = [&](CWalletTx& wtx, bool new_tx) {\n+            if(!new_tx) {\n+                // There's some corruption here since the tx we just tried to load was already in the wallet.\n+                // We don't consider this type of corruption critical, and can fix it by removing tx data and\n+                // rescanning.\n+                err = \"Error: Corrupt transaction found. This can be fixed by removing transactions from wallet and rescanning.\\n\";\n+                result = DBErrors::CORRUPT;\n+                corrupted_tx = true;\n+                return false;\n+            }\n+            value >> wtx;\n+            if (wtx.GetHash() != hash)\n+                return false;\n+\n+            // Undo serialize changes in 31600\n+            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n+            {\n+                if (!value.empty())\n+                {\n+                    uint8_t fTmp;\n+                    uint8_t fUnused;\n+                    std::string unused_string;\n+                    value >> fTmp >> fUnused >> unused_string;\n+                    pwallet->WalletLogPrintf(\"LoadWallet() upgrading tx ver=%d %d %s\\n\",\n+                                       wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());\n+                    wtx.fTimeReceivedIsTxTime = fTmp;\n+                }\n+                else\n+                {\n+                    pwallet->WalletLogPrintf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n+                    wtx.fTimeReceivedIsTxTime = 0;\n+                }\n+                upgraded_txs.push_back(hash);\n+            }\n+\n+            if (wtx.nOrderPos == -1)\n+                any_unordered = true;\n+\n+            return true;\n+        };\n+        if (!pwallet->LoadToWallet(hash, fill_wtx)) {\n+            if (corrupted_tx) {\n+                result = DBErrors::CORRUPT;\n+            } else {\n+                result = DBErrors::NEED_RESCAN;\n+            }\n         }\n-        return false;\n-    }\n-    return true;\n+        return result;\n+    });\n+    result = std::max(result, tx_res.m_result);\n+\n+    // Load locked utxo record\n+    LoadResult locked_utxo_res = LoadRecords(pwallet, batch, DBKeys::LOCKED_UTXO,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {\n+        uint256 hash;\n+        uint32_t n;\n+        key >> hash;\n+        key >> n;\n+        pwallet->LockCoin(COutPoint(hash, n));\n+        return DBErrors::LOAD_OK;\n+    });\n+    result = std::max(result, tx_res.m_result);\n+    if (result != DBErrors::LOAD_OK) return result;\n+\n+    // Load orderposnext record\n+    batch.Read(DBKeys::ORDERPOSNEXT, pwallet->nOrderPosNext);\n+\n+    return DBErrors::LOAD_OK;\n }\n \n-bool ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strType, std::string& strErr, const KeyFilterFn& filter_fn)\n+static DBErrors LoadActiveSPKMs(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    CWalletScanState dummy_wss;\n-    LOCK(pwallet->cs_wallet);\n-    return ReadKeyValue(pwallet, ssKey, ssValue, dummy_wss, strType, strErr, filter_fn);\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load spk records\n+    std::set<std::pair<OutputType, bool>> seen_spks;\n+    for (auto& spk_key : {DBKeys::ACTIVEEXTERNALSPK, DBKeys::ACTIVEINTERNALSPK}) {\n+        LoadResult spkm_res = LoadRecords(pwallet, batch, spk_key,\n+            [&seen_spks, &spk_key] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+            uint8_t output_type;\n+            key >> output_type;\n+            uint256 id;\n+            value >> id;\n+\n+            bool internal = spk_key == DBKeys::ACTIVEINTERNALSPK;\n+            auto [it, insert] = seen_spks.emplace(static_cast<OutputType>(output_type), internal);\n+            if (!insert) {\n+                err = \"Multiple ScriptpubKeyMans specified for a single type\\n\";\n+                return DBErrors::CORRUPT;\n+            }\n+            pwallet->LoadActiveScriptPubKeyMan(id, static_cast<OutputType>(output_type), /*internal=*/internal);\n+            return DBErrors::LOAD_OK;\n+        });\n+        if (spkm_res.m_result != DBErrors::LOAD_OK) return spkm_res.m_result;\n+    }\n+    return DBErrors::LOAD_OK;\n }\n \n-bool WalletBatch::IsKeyType(const std::string& strType)\n+static DBErrors LoadDecryptionKeys(CWallet* pwallet, DatabaseBatch& batch) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    return (strType == DBKeys::KEY ||\n-            strType == DBKeys::MASTER_KEY || strType == DBKeys::CRYPTED_KEY);\n+    AssertLockHeld(pwallet->cs_wallet);\n+\n+    // Load decryption key (mkey) records\n+    LoadResult mkey_res = LoadRecords(pwallet, batch, DBKeys::MASTER_KEY,\n+        [] (CWallet* pwallet, CDataStream& key, CDataStream& value, std::string& err) {\n+        if (!LoadEncryptionKey(pwallet, key, value, err)) {\n+            return DBErrors::CORRUPT;\n+        }\n+        return DBErrors::LOAD_OK;\n+    });\n+    return mkey_res.m_result;;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989510938",
      "id" : 989510938,
      "in_reply_to_id" : 980044405,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-r0a",
      "original_commit_id" : "b7167d0d65363780615d7b2442ca46816126ad50",
      "original_line" : 1073,
      "original_position" : 1153,
      "original_start_line" : null,
      "path" : "src/wallet/walletdb.cpp",
      "position" : null,
      "pull_request_review_id" : 1133678266,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:52:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989510938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989511064"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989511064"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:52:14Z",
      "diff_hunk" : "@@ -92,9 +103,21 @@ class DatabaseBatch\n         return HasKey(std::move(ssKey));\n     }\n \n-    virtual bool StartCursor() = 0;\n-    virtual bool ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool& complete) = 0;\n-    virtual void CloseCursor() = 0;\n+    virtual std::unique_ptr<DatabaseCursor> GetNewCursor() = 0;\n+    bool StartCursor()\n+    {\n+        m_cursor = GetNewCursor();\n+        return m_cursor != nullptr;  ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989511064",
      "id" : 989511064,
      "in_reply_to_id" : 986358462,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-r2Y",
      "original_commit_id" : "10cf25c112ff4ac7bcece87a821996004cec2b24",
      "original_line" : 110,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/wallet/db.h",
      "position" : null,
      "pull_request_review_id" : 1133678406,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989511064/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:52:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989511064",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989511127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989511127"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "15bc973d0db48a8d5f44abfec4664dcf58de21e8",
      "created_at" : "2022-10-06T21:52:22Z",
      "diff_hunk" : "@@ -3677,24 +3677,25 @@ bool CWallet::MigrateToSQLite(bilingual_str& error)\n \n     // Get all of the records for DB type migration\n     std::unique_ptr<DatabaseBatch> batch = m_database->MakeBatch();\n+    std::unique_ptr<DatabaseCursor> cursor = batch->GetNewCursor();\n     std::vector<std::pair<SerializeData, SerializeData>> records;\n-    if (!batch->StartCursor()) {\n+    if (!cursor) {\n         error = _(\"Error: Unable to begin reading all records in the database\");\n         return false;\n     }\n     bool complete = false;\n     while (true) {\n         CDataStream ss_key(SER_DISK, CLIENT_VERSION);\n         CDataStream ss_value(SER_DISK, CLIENT_VERSION);\n-        bool ret = batch->ReadAtCursor(ss_key, ss_value, complete);\n+        bool ret = cursor->Next(ss_key, ss_value, complete);\n         if (!ret) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24914#discussion_r989511127",
      "id" : 989511127,
      "in_reply_to_id" : 987183146,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846-r3X",
      "original_commit_id" : "5a8b0f16681bf8f755e84567e7ecee2feb28336c",
      "original_line" : 3691,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 1133678505,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24914",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989511127/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-06T21:52:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989511127",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
