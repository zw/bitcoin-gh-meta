[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r791661778"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791661778"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would it compile if you remove this and use `::ToString(node.k)` instead?",
      "commit_id" : "74d3f9b58e56c1375bfe7f4c1c1a0fda17124f1d",
      "created_at" : "2022-01-25T12:28:07Z",
      "diff_hunk" : "@@ -0,0 +1,1563 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::MULTI: {\n+                    CScript script = CScript() << node.k;\n+                    for (const auto& key : node.keys) {\n+                        script << ctx.ToPKBytes(key);\n+                    }\n+                    return std::move(script) << node.keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+                }\n+                case NodeType::THRESH: {\n+                    CScript script = std::move(subs[0]);\n+                    for (size_t i = 1; i < subs.size(); ++i) {\n+                        script = (std::move(script) + std::move(subs[i])) << OP_ADD;\n+                    }\n+                    return std::move(script) << node.k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                }\n+            }\n+            assert(false);\n+            return {};\n+        };\n+        return TreeEval<CScript>(false, downfn, upfn);\n+    }\n+\n+    template<typename CTx>\n+    bool ToString(const CTx& ctx, std::string& ret) const {\n+        // To construct the std::string representation for a Miniscript object, we use\n+        // the TreeEvalMaybe algorithm. The State is a boolean: whether the parent node is a\n+        // wrapper. If so, non-wrapper expressions must be prefixed with a \":\".\n+        auto downfn = [](bool, const Node& node, size_t) {\n+            return (node.nodetype == NodeType::WRAP_A || node.nodetype == NodeType::WRAP_S ||\n+                    node.nodetype == NodeType::WRAP_D || node.nodetype == NodeType::WRAP_V ||\n+                    node.nodetype == NodeType::WRAP_J || node.nodetype == NodeType::WRAP_N ||\n+                    node.nodetype == NodeType::WRAP_C ||\n+                    (node.nodetype == NodeType::AND_V && node.subs[1]->nodetype == NodeType::JUST_1) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[0]->nodetype == NodeType::JUST_0) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[1]->nodetype == NodeType::JUST_0));\n+        };\n+        // The upward function computes for a node, given whether its parent is a wrapper,\n+        // and the string representations of its child nodes, the string representation of the node.\n+        auto upfn = [&ctx](bool wrapped, const Node& node, Span<std::string> subs) -> std::optional<std::string> {\n+            std::string ret = wrapped ? \":\" : \"\";\n+            std::stringstream k_sstr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r791661778",
      "id" : 791661778,
      "line" : 504,
      "node_id" : "PRRC_kwDOABII584vL8zS",
      "original_commit_id" : "74d3f9b58e56c1375bfe7f4c1c1a0fda17124f1d",
      "original_line" : 504,
      "original_position" : 504,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 504,
      "pull_request_review_id" : 862209933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791661778/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T12:28:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791661778",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Arg, the unit test (`miniscript_tests`) gets [OOM killed in the CI](https://cirrus-ci.com/task/6650942870257664) when ASAN is enabled.\r\nEDIT: reproduced locally (the RAM usage is crazy, went up to 13G before i killed it although the test without ASAN uses only a few hundreds MB).\r\n~~Decreasing the number of iterations for the random tests to 100 for now (caps the mem usage to 2G on my machine under ASAN). I'll look into making `GenNode` generate valid nodes more often, which i think is the main culprit here...~~\r\n\r\nNote: this was later fixed by having a `miniscript_random` fuzz target (in #24149) instead of trying to generate random nodes in the unit tests.\r\n\r\n\r\nAside: this shouldn't be labeled as \"Consensus\" (neither should #24148 be) :)",
      "created_at" : "2022-01-25T13:03:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021161686",
      "id" : 1021161686,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII58483bDW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021161686/reactions"
      },
      "updated_at" : "2022-02-21T15:14:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021161686",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r791688920"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791688920"
         }
      },
      "author_association" : "MEMBER",
      "body" : ":man_facepalming: Yes. Done.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-25T13:03:08Z",
      "diff_hunk" : "@@ -0,0 +1,1563 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::MULTI: {\n+                    CScript script = CScript() << node.k;\n+                    for (const auto& key : node.keys) {\n+                        script << ctx.ToPKBytes(key);\n+                    }\n+                    return std::move(script) << node.keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+                }\n+                case NodeType::THRESH: {\n+                    CScript script = std::move(subs[0]);\n+                    for (size_t i = 1; i < subs.size(); ++i) {\n+                        script = (std::move(script) + std::move(subs[i])) << OP_ADD;\n+                    }\n+                    return std::move(script) << node.k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                }\n+            }\n+            assert(false);\n+            return {};\n+        };\n+        return TreeEval<CScript>(false, downfn, upfn);\n+    }\n+\n+    template<typename CTx>\n+    bool ToString(const CTx& ctx, std::string& ret) const {\n+        // To construct the std::string representation for a Miniscript object, we use\n+        // the TreeEvalMaybe algorithm. The State is a boolean: whether the parent node is a\n+        // wrapper. If so, non-wrapper expressions must be prefixed with a \":\".\n+        auto downfn = [](bool, const Node& node, size_t) {\n+            return (node.nodetype == NodeType::WRAP_A || node.nodetype == NodeType::WRAP_S ||\n+                    node.nodetype == NodeType::WRAP_D || node.nodetype == NodeType::WRAP_V ||\n+                    node.nodetype == NodeType::WRAP_J || node.nodetype == NodeType::WRAP_N ||\n+                    node.nodetype == NodeType::WRAP_C ||\n+                    (node.nodetype == NodeType::AND_V && node.subs[1]->nodetype == NodeType::JUST_1) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[0]->nodetype == NodeType::JUST_0) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[1]->nodetype == NodeType::JUST_0));\n+        };\n+        // The upward function computes for a node, given whether its parent is a wrapper,\n+        // and the string representations of its child nodes, the string representation of the node.\n+        auto upfn = [&ctx](bool wrapped, const Node& node, Span<std::string> subs) -> std::optional<std::string> {\n+            std::string ret = wrapped ? \":\" : \"\";\n+            std::stringstream k_sstr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r791688920",
      "id" : 791688920,
      "in_reply_to_id" : 791661778,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584vMDbY",
      "original_commit_id" : "74d3f9b58e56c1375bfe7f4c1c1a0fda17124f1d",
      "original_line" : 504,
      "original_position" : 504,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 862247706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791688920/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T13:03:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791688920",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. I wonder if it makes sense to start out with a small subset of miniscript, so reviewers can focus on the implementation rather than on completeness.",
      "created_at" : "2022-01-25T15:09:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021285627",
      "id" : 1021285627,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584835T7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021285627/reactions"
      },
      "updated_at" : "2022-01-25T15:09:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021285627",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792111522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792111522"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is my code, but it was written when the codebase was still C++11. In C++17 this can be written more idiomatically without recursion. Can be done afterwards, but it may help review.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-25T20:54:56Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792111522",
      "id" : 792111522,
      "line" : 151,
      "node_id" : "PRRC_kwDOABII584vNqmi",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 150,
      "original_position" : 150,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 150,
      "pull_request_review_id" : 862854599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792111522/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T21:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792111522",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792112450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792112450"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Self-nit: this should be \"will be at the end of *result*\", not on the stack.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-25T20:56:08Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792112450",
      "id" : 792112450,
      "line" : 367,
      "node_id" : "PRRC_kwDOABII584vNq1C",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 320,
      "original_position" : 320,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 320,
      "pull_request_review_id" : 862854599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792112450/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T21:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792112450",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792113199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792113199"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Self-nit: subexpression*s*.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-25T20:57:00Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792113199",
      "id" : 792113199,
      "line" : 408,
      "node_id" : "PRRC_kwDOABII584vNrAv",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 361,
      "original_position" : 361,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 361,
      "pull_request_review_id" : 862854599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792113199/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T21:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792113199",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Strong concept ACK",
      "created_at" : "2022-01-25T21:00:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021604268",
      "id" : 1021604268,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII58485HGs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021604268/reactions"
      },
      "updated_at" : "2022-01-25T21:00:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021604268",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/meshcollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/meshcollider/followers",
         "following_url" : "https://api.github.com/users/meshcollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/meshcollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/meshcollider",
         "id" : 3211283,
         "login" : "meshcollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/meshcollider/orgs",
         "received_events_url" : "https://api.github.com/users/meshcollider/received_events",
         "repos_url" : "https://api.github.com/users/meshcollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/meshcollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/meshcollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792116302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792116302"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This test, along with all the RandomNode logic, is probably much more useful if converted to a fuzz test (which doesn't need to construct a realistic/useful probability model, but can just choose based on inputs). Let me know if you want any help with that.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-25T21:01:31Z",
      "diff_hunk" : "@@ -0,0 +1,407 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <string>\n+\n+#include <test/util/setup_common.h>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <uint256.h>\n+#include <crypto/ripemd160.h>\n+#include <crypto/sha256.h>\n+#include <script/miniscript.h>\n+\n+namespace {\n+\n+/** TestData groups various kinds of precomputed data necessary in this test. */\n+struct TestData {\n+    //! The only public keys used in this test.\n+    std::vector<CPubKey> pubkeys;\n+    //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n+    std::map<CPubKey, CKeyID> pkhashes;\n+\n+    // Various precomputed hashes\n+    std::vector<std::vector<unsigned char>> sha256;\n+    std::vector<std::vector<unsigned char>> ripemd160;\n+    std::vector<std::vector<unsigned char>> hash256;\n+    std::vector<std::vector<unsigned char>> hash160;\n+\n+    TestData()\n+    {\n+        // We generate 255 public keys and 255 hashes of each type.\n+        for (int i = 1; i <= 255; ++i) {\n+            // This 32-byte array functions as both private key data and hash preimage (31 zero bytes plus any nonzero byte).\n+            unsigned char keydata[32] = {0};\n+            keydata[31] = i;\n+\n+            // Compute CPubkey and CKeyID\n+            CKey key;\n+            key.Set(keydata, keydata + 32, true);\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID keyid = pubkey.GetID();\n+            pubkeys.push_back(pubkey);\n+            pkhashes.emplace(pubkey, keyid);\n+\n+            // Compute various hashes\n+            std::vector<unsigned char> hash;\n+            hash.resize(32);\n+            CSHA256().Write(keydata, 32).Finalize(hash.data());\n+            sha256.push_back(hash);\n+            CHash256().Write(keydata).Finalize(hash);\n+            hash256.push_back(hash);\n+            hash.resize(20);\n+            CRIPEMD160().Write(keydata, 32).Finalize(hash.data());\n+            ripemd160.push_back(hash);\n+            CHash160().Write(keydata).Finalize(hash);\n+            hash160.push_back(hash);\n+        }\n+    }\n+};\n+\n+//! Global TestData object\n+std::unique_ptr<const TestData> g_testdata;\n+\n+/** A class encapsulating conversion routing for CPubKey. */\n+struct KeyConverter {\n+    typedef CPubKey Key;\n+\n+    //! Public keys in text form are their usual hex notation (no xpubs, ...).\n+    bool ToString(const CPubKey& key, std::string& ret) const { ret = HexStr(key); return true; }\n+\n+    //! Convert a public key to bytes.\n+    std::vector<unsigned char> ToPKBytes(const CPubKey& key) const { return {key.begin(), key.end()}; }\n+\n+    //! Convert a public key to its Hash160 bytes (precomputed).\n+    std::vector<unsigned char> ToPKHBytes(const CPubKey& key) const\n+    {\n+        auto it = g_testdata->pkhashes.find(key);\n+        assert(it != g_testdata->pkhashes.end());\n+        return {it->second.begin(), it->second.end()};\n+    }\n+\n+    //! Parse a public key from a range of hex characters.\n+    template<typename I>\n+    bool FromString(I first, I last, CPubKey& key) const {\n+        auto bytes = ParseHex(std::string(first, last));\n+        key.Set(bytes.begin(), bytes.end());\n+        return key.IsValid();\n+    }\n+};\n+\n+//! Singleton instance of KeyConverter.\n+const KeyConverter CONVERTER{};\n+\n+// Helper types and functions that use miniscript instantiated for CPubKey.\n+using NodeType = miniscript::NodeType;\n+using NodeRef = miniscript::NodeRef<CPubKey>;\n+template<typename... Args> NodeRef MakeNodeRef(Args&&... args) { return miniscript::MakeNodeRef<CPubKey>(std::forward<Args>(args)...); }\n+using miniscript::operator\"\" _mst;\n+\n+NodeRef GenNode(miniscript::Type typ, int complexity);\n+\n+//! Generate a random valid miniscript node of the given type and complexity.\n+NodeRef RandomNode(miniscript::Type typ, int complexity) {\n+    assert(complexity > 0);\n+    NodeRef ret;\n+    do {\n+        ret = GenNode(typ, complexity);\n+    } while (!ret || !ret->IsValid() || !(ret->GetType() << typ));\n+    return ret;\n+}\n+\n+//! Generate a vector of valid miniscript nodes of the given types, and a specified complexity of their sum.\n+std::vector<NodeRef> MultiNode(int complexity, const std::vector<miniscript::Type>& types)\n+{\n+    int nodes = types.size();\n+    assert(complexity >= nodes);\n+    std::vector<int> subcomplex(nodes, 1);\n+    if (nodes == 1) {\n+        subcomplex[0] = complexity;\n+    } else {\n+        // This is a silly inefficient way to construct a multinomial distribution.\n+        for (int i = 0; i < complexity - nodes; ++i) {\n+            subcomplex[InsecureRandRange(nodes)]++;\n+        }\n+    }\n+    std::vector<NodeRef> subs;\n+    for (int i = 0; i < nodes; ++i) {\n+        subs.push_back(RandomNode(types[i], subcomplex[i]));\n+    }\n+    return subs;\n+}\n+\n+//! Generate a random (but occasionally invalid) miniscript node of the given type and complexity.\n+NodeRef GenNode(miniscript::Type typ, int complexity) {\n+    if (typ << \"B\"_mst) {\n+        // Generate a \"B\" node.\n+        if (complexity == 1) {\n+            switch (InsecureRandBits(2)) {\n+                case 0: return MakeNodeRef(InsecureRandBool() ? NodeType::JUST_0 : NodeType::JUST_1);\n+                case 1: return MakeNodeRef(InsecureRandBool() ? NodeType::OLDER : NodeType::AFTER, 1 + InsecureRandRange((1ULL << (1 + InsecureRandRange(31))) - 1));\n+                case 2: {\n+                    int hashtype = InsecureRandBits(2);\n+                    int index = InsecureRandRange(255);\n+                    switch (hashtype) {\n+                        case 0: return MakeNodeRef(NodeType::SHA256, g_testdata->sha256[index]);\n+                        case 1: return MakeNodeRef(NodeType::RIPEMD160, g_testdata->ripemd160[index]);\n+                        case 2: return MakeNodeRef(NodeType::HASH256, g_testdata->hash256[index]);\n+                        case 3: return MakeNodeRef(NodeType::HASH160, g_testdata->hash160[index]);\n+                    }\n+                    break;\n+                }\n+                case 3: return MakeNodeRef(NodeType::WRAP_C, MultiNode(complexity, Vector(\"K\"_mst)));\n+            }\n+            assert(false);\n+        }\n+        switch (InsecureRandRange(7 + (complexity >= 3) * 7 + (complexity >= 4) * 2)) {\n+            // Complexity >= 2\n+            case 0: return MakeNodeRef(NodeType::WRAP_C, MultiNode(complexity, Vector(\"K\"_mst)));\n+            case 1: return MakeNodeRef(NodeType::WRAP_D, MultiNode(complexity - 1, Vector(\"V\"_mst)));\n+            case 2: return MakeNodeRef(NodeType::WRAP_J, MultiNode(complexity - 1, Vector(\"B\"_mst)));\n+            case 3: return MakeNodeRef(NodeType::WRAP_N, MultiNode(complexity - 1, Vector(\"B\"_mst)));\n+            case 4: return MakeNodeRef(NodeType::OR_I, Cat(MultiNode(complexity - 1, Vector(\"B\"_mst)), Vector(MakeNodeRef(NodeType::JUST_0))));\n+            case 5: return MakeNodeRef(NodeType::OR_I, Cat(Vector(MakeNodeRef(NodeType::JUST_0)), MultiNode(complexity - 1, Vector(\"B\"_mst))));\n+            case 6: return MakeNodeRef(NodeType::AND_V, Cat(MultiNode(complexity - 1, Vector(\"V\"_mst)), Vector(MakeNodeRef(NodeType::JUST_1))));\n+            // Complexity >= 3\n+            case 7: return MakeNodeRef(NodeType::AND_V, MultiNode(complexity - 1, Vector(\"V\"_mst, \"B\"_mst)));\n+            case 8: return MakeNodeRef(NodeType::ANDOR, Cat(MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst)), Vector(MakeNodeRef(NodeType::JUST_0))));\n+            case 9: return MakeNodeRef(NodeType::AND_B, MultiNode(complexity - 1, Vector(\"B\"_mst, \"W\"_mst)));\n+            case 10: return MakeNodeRef(NodeType::OR_B, MultiNode(complexity - 1, Vector(\"B\"_mst, \"W\"_mst)));\n+            case 11: return MakeNodeRef(NodeType::OR_D, MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst)));\n+            case 12: return MakeNodeRef(NodeType::OR_I, MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst)));\n+            case 13: {\n+                if (complexity != 3) return {};\n+                int nkeys = 1 + (InsecureRandRange(15) * InsecureRandRange(25)) / 17;\n+                int sigs = 1 + InsecureRandRange(nkeys);\n+                std::vector<CPubKey> keys;\n+                for (int i = 0; i < nkeys; ++i) keys.push_back(g_testdata->pubkeys[InsecureRandRange(255)]);\n+                return MakeNodeRef(NodeType::MULTI, std::move(keys), sigs);\n+            }\n+            // Complexity >= 4\n+            case 14: return MakeNodeRef(NodeType::ANDOR, MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst, \"B\"_mst)));\n+            case 15: {\n+                int args = 3 + InsecureRandRange(std::min(3, complexity - 3));\n+                int sats = 2 + InsecureRandRange(args - 2);\n+                return MakeNodeRef(NodeType::THRESH, MultiNode(complexity - 1, Cat(Vector(\"B\"_mst), std::vector<miniscript::Type>(args - 1, \"W\"_mst))), sats);\n+            }\n+        }\n+    } else if (typ << \"V\"_mst) {\n+        // Generate a \"V\" node.\n+        switch (InsecureRandRange(1 + (complexity >= 3) * 3 + (complexity >= 4))) {\n+            // Complexity >= 1\n+            case 0: return MakeNodeRef(NodeType::WRAP_V, MultiNode(complexity, Vector(\"B\"_mst)));\n+            // Complexity >= 3\n+            case 1: return MakeNodeRef(NodeType::AND_V, MultiNode(complexity - 1, Vector(\"V\"_mst, \"V\"_mst)));\n+            case 2: return MakeNodeRef(NodeType::OR_C, MultiNode(complexity - 1, Vector(\"B\"_mst, \"V\"_mst)));\n+            case 3: return MakeNodeRef(NodeType::OR_I, MultiNode(complexity - 1, Vector(\"V\"_mst, \"V\"_mst)));\n+            // Complexity >= 4\n+            case 4: return MakeNodeRef(NodeType::ANDOR, MultiNode(complexity - 1, Vector(\"B\"_mst, \"V\"_mst, \"V\"_mst)));\n+        }\n+    } else if (typ << \"W\"_mst) {\n+        // Generate a \"W\" node by wrapping a \"B\" node.\n+        auto sub = RandomNode(\"B\"_mst, complexity);\n+        if (sub->GetType() << \"o\"_mst) {\n+            if (InsecureRandBool()) return MakeNodeRef(NodeType::WRAP_S, Vector(std::move(sub)));\n+        }\n+        return MakeNodeRef(NodeType::WRAP_A, Vector(std::move(sub)));\n+    } else if (typ << \"K\"_mst) {\n+        // Generate a \"K\" node.\n+        if (complexity == 1 || complexity == 2) {\n+            if (InsecureRandBool()) {\n+                return MakeNodeRef(NodeType::PK_K, Vector(g_testdata->pubkeys[InsecureRandRange(255)]));\n+            } else {\n+                return MakeNodeRef(NodeType::PK_H, Vector(g_testdata->pubkeys[InsecureRandRange(255)]));\n+            }\n+        }\n+        switch (InsecureRandRange(2 + (complexity >= 4))) {\n+            // Complexity >= 3\n+            case 0: return MakeNodeRef(NodeType::AND_V, MultiNode(complexity - 1, Vector(\"V\"_mst, \"K\"_mst)));\n+            case 1: return MakeNodeRef(NodeType::OR_I, MultiNode(complexity - 1, Vector(\"K\"_mst, \"K\"_mst)));\n+            // Complexity >= 4\n+            case 2: return MakeNodeRef(NodeType::ANDOR, MultiNode(complexity - 1, Vector(\"B\"_mst, \"K\"_mst, \"K\"_mst)));\n+        }\n+    }\n+    assert(false);\n+    return {};\n+}\n+\n+enum TestMode : int {\n+    TESTMODE_INVALID = 0,\n+    TESTMODE_VALID = 1,\n+    TESTMODE_NONMAL = 2,\n+    TESTMODE_NEEDSIG = 4,\n+    TESTMODE_TIMELOCKMIX = 8\n+};\n+\n+void Test(const std::string& ms, const std::string& hexscript, int mode)\n+{\n+    auto node = miniscript::FromString(ms, CONVERTER);\n+    if (mode == TESTMODE_INVALID) {\n+        BOOST_CHECK_MESSAGE(!node || !node->IsValid(), \"Unexpectedly valid: \" + ms);\n+    } else {\n+        BOOST_CHECK_MESSAGE(node, \"Unparseable: \" + ms);\n+        BOOST_CHECK_MESSAGE(node->IsValid(), \"Invalid: \" + ms);\n+        BOOST_CHECK_MESSAGE(node->IsValidTopLevel(), \"Invalid top level: \" + ms);\n+        auto computed_script = node->ToScript(CONVERTER);\n+        BOOST_CHECK_MESSAGE(node->ScriptSize() == computed_script.size(), \"Script size mismatch: \" + ms);\n+        if (hexscript != \"?\") BOOST_CHECK_MESSAGE(HexStr(computed_script) == hexscript, \"Script mismatch: \" + ms + \" (\" + HexStr(computed_script) + \" vs \" + hexscript + \")\");\n+        BOOST_CHECK_MESSAGE(node->IsNonMalleable() == !!(mode & TESTMODE_NONMAL), \"Malleability mismatch: \" + ms);\n+        BOOST_CHECK_MESSAGE(node->NeedsSignature() == !!(mode & TESTMODE_NEEDSIG), \"Signature necessity mismatch: \" + ms);\n+        BOOST_CHECK_MESSAGE((node->GetType() << \"k\"_mst) == !(mode & TESTMODE_TIMELOCKMIX), \"Timelock mix mismatch: \" + ms);\n+    }\n+\n+}\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(miniscript_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(fixed_tests)\n+{\n+    g_testdata.reset(new TestData());\n+\n+    // Validity rules\n+    Test(\"l:older(1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // older(1): valid\n+    Test(\"l:older(0)\", \"?\", TESTMODE_INVALID); // older(0): k must be at least 1\n+    Test(\"l:older(2147483647)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // older(2147483647): valid\n+    Test(\"l:older(2147483648)\", \"?\", TESTMODE_INVALID); // older(2147483648): k must be below 2^31\n+    Test(\"u:after(1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // after(1): valid\n+    Test(\"u:after(0)\", \"?\", TESTMODE_INVALID); // after(0): k must be at least 1\n+    Test(\"u:after(2147483647)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // after(2147483647): valid\n+    Test(\"u:after(2147483648)\", \"?\", TESTMODE_INVALID); // after(2147483648): k must be below 2^31\n+    Test(\"andor(0,1,1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // andor(Bdu,B,B): valid\n+    Test(\"andor(a:0,1,1)\", \"?\", TESTMODE_INVALID); // andor(Wdu,B,B): X must be B\n+    Test(\"andor(0,a:1,a:1)\", \"?\", TESTMODE_INVALID); // andor(Bdu,W,W): Y and Z must be B/V/K\n+    Test(\"andor(1,1,1)\", \"?\", TESTMODE_INVALID); // andor(Bu,B,B): X must be d\n+    Test(\"andor(n:or_i(0,after(1)),1,1)\", \"?\", TESTMODE_VALID); // andor(Bdu,B,B): valid\n+    Test(\"andor(or_i(0,after(1)),1,1)\", \"?\", TESTMODE_INVALID); // andor(Bd,B,B): X must be u\n+    Test(\"c:andor(0,pk_k(03a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7),pk_k(036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00))\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG); // andor(Bdu,K,K): valid\n+    Test(\"t:andor(0,v:1,v:1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // andor(Bdu,V,V): valid\n+    Test(\"and_v(v:1,1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // and_v(V,B): valid\n+    Test(\"t:and_v(v:1,v:1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // and_v(V,V): valid\n+    Test(\"c:and_v(v:1,pk_k(036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00))\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG); // and_v(V,K): valid\n+    Test(\"and_v(1,1)\", \"?\", TESTMODE_INVALID); // and_v(B,B): X must be V\n+    Test(\"and_v(pk_k(02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5),1)\", \"?\", TESTMODE_INVALID); // and_v(K,B): X must be V\n+    Test(\"and_v(v:1,a:1)\", \"?\", TESTMODE_INVALID); // and_v(K,W): Y must be B/V/K\n+    Test(\"and_b(1,a:1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // and_b(B,W): valid\n+    Test(\"and_b(1,1)\", \"?\", TESTMODE_INVALID); // and_b(B,B): Y must W\n+    Test(\"and_b(v:1,a:1)\", \"?\", TESTMODE_INVALID); // and_b(V,W): X must be B\n+    Test(\"and_b(a:1,a:1)\", \"?\", TESTMODE_INVALID); // and_b(W,W): X must be B\n+    Test(\"and_b(pk_k(025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc),a:1)\", \"?\", TESTMODE_INVALID); // and_b(K,W): X must be B\n+    Test(\"or_b(0,a:0)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG); // or_b(Bd,Wd): valid\n+    Test(\"or_b(1,a:0)\", \"?\", TESTMODE_INVALID); // or_b(B,Wd): X must be d\n+    Test(\"or_b(0,a:1)\", \"?\", TESTMODE_INVALID); // or_b(Bd,W): Y must be d\n+    Test(\"or_b(0,0)\", \"?\", TESTMODE_INVALID); // or_b(Bd,Bd): Y must W\n+    Test(\"or_b(v:0,a:0)\", \"?\", TESTMODE_INVALID); // or_b(V,Wd): X must be B\n+    Test(\"or_b(a:0,a:0)\", \"?\", TESTMODE_INVALID); // or_b(Wd,Wd): X must be B\n+    Test(\"or_b(pk_k(025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc),a:0)\", \"?\", TESTMODE_INVALID); // or_b(Kd,Wd): X must be B\n+    Test(\"t:or_c(0,v:1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // or_c(Bdu,V): valid\n+    Test(\"t:or_c(a:0,v:1)\", \"?\", TESTMODE_INVALID); // or_c(Wdu,V): X must be B\n+    Test(\"t:or_c(1,v:1)\", \"?\", TESTMODE_INVALID); // or_c(Bu,V): X must be d\n+    Test(\"t:or_c(n:or_i(0,after(1)),v:1)\", \"?\", TESTMODE_VALID); // or_c(Bdu,V): valid\n+    Test(\"t:or_c(or_i(0,after(1)),v:1)\", \"?\", TESTMODE_INVALID); // or_c(Bd,V): X must be u\n+    Test(\"t:or_c(0,1)\", \"?\", TESTMODE_INVALID); // or_c(Bdu,B): Y must be V\n+    Test(\"or_d(0,1)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // or_d(Bdu,B): valid\n+    Test(\"or_d(a:0,1)\", \"?\", TESTMODE_INVALID); // or_d(Wdu,B): X must be B\n+    Test(\"or_d(1,1)\", \"?\", TESTMODE_INVALID); // or_d(Bu,B): X must be d\n+    Test(\"or_d(n:or_i(0,after(1)),1)\", \"?\", TESTMODE_VALID); // or_d(Bdu,B): valid\n+    Test(\"or_d(or_i(0,after(1)),1)\", \"?\", TESTMODE_INVALID); // or_d(Bd,B): X must be u\n+    Test(\"or_d(0,v:1)\", \"?\", TESTMODE_INVALID); // or_d(Bdu,V): Y must be B\n+    Test(\"or_i(1,1)\", \"?\", TESTMODE_VALID); // or_i(B,B): valid\n+    Test(\"t:or_i(v:1,v:1)\", \"?\", TESTMODE_VALID); // or_i(V,V): valid\n+    Test(\"c:or_i(pk_k(03a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7),pk_k(036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00))\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG); // or_i(K,K): valid\n+    Test(\"or_i(a:1,a:1)\", \"?\", TESTMODE_INVALID); // or_i(W,W): X and Y must be B/V/K\n+    Test(\"or_b(l:after(100),al:after(1000000000))\", \"?\", TESTMODE_VALID); // or_b(timelock, heighlock) valid\n+    Test(\"and_b(after(100),a:after(1000000000))\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_TIMELOCKMIX); // and_b(timelock, heighlock) invalid\n+    Test(\"pk(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65)\", \"2103d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG); // alias to c:pk_k\n+    Test(\"pkh(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65)\", \"76a914fcd35ddacad9f2d5be5e464639441c6065e6955d88ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG); // alias to c:pk_h\n+\n+\n+    // Randomly generated test set that covers the majority of type and node type combinations\n+    Test(\"lltvln:after(1231488000)\", \"6300676300676300670400046749b1926869516868\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"uuj:and_v(v:multi(2,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a,025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc),after(1231488000))\", \"6363829263522103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a21025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc52af0400046749b168670068670068\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"or_b(un:multi(2,03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),al:older(16))\", \"63522103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee872921024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae926700686b63006760b2686c9b\", TESTMODE_VALID);\n+    Test(\"j:and_v(vdv:after(1567547623),older(2016))\", \"829263766304e7e06e5db169686902e007b268\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"t:and_v(vu:hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),v:sha256(ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc5))\", \"6382012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876700686982012088a820ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc58851\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"t:andor(multi(3,02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e,03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556,02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),v:older(4194305),v:sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2))\", \"532102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a14602975562102e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd1353ae6482012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2886703010040b2696851\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"or_d(multi(1,02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9),or_b(multi(3,022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01,032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a),su:after(500000)))\", \"512102f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f951ae73645321022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a0121032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f2103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a53ae7c630320a107b16700689b68\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"or_d(sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6),and_n(un:after(499999999),older(4194305)))\", \"82012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68773646304ff64cd1db19267006864006703010040b26868\", TESTMODE_VALID);\n+    Test(\"and_v(or_i(v:multi(2,02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5,03774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb),v:multi(2,03e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a,025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc)),sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68))\", \"63522102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee52103774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb52af67522103e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a21025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc52af6882012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c6887\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"j:and_b(multi(2,0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),s:or_i(older(1),older(4252898)))\", \"82926352210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179821024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae7c6351b26703e2e440b2689a68\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"and_b(older(16),s:or_d(sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),n:after(1567547623)))\", \"60b27c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87736404e7e06e5db192689a\", TESTMODE_VALID);\n+    Test(\"j:and_v(v:hash160(20195b5a3d650c17f0f29f91c33f8f6335193d07),or_d(sha256(96de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c47),older(16)))\", \"82926382012088a91420195b5a3d650c17f0f29f91c33f8f6335193d078882012088a82096de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c4787736460b26868\", TESTMODE_VALID);\n+    Test(\"and_b(hash256(32ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac),a:and_b(hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),a:older(1)))\", \"82012088aa2032ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac876b82012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876b51b26c9a6c9a\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"thresh(2,multi(2,03a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),a:multi(1,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),ac:pk_k(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01))\", \"522103a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c721036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0052ae6b5121036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0051ae6c936b21022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01ac6c935287\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"and_n(sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68),t:or_i(v:older(4252898),v:older(144)))\", \"82012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68876400676303e2e440b26967029000b269685168\", TESTMODE_VALID);\n+    Test(\"or_d(d:and_v(v:older(4252898),v:older(4252898)),sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6))\", \"766303e2e440b26903e2e440b26968736482012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68768\", TESTMODE_VALID);\n+    Test(\"c:and_v(or_c(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),v:multi(1,02c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db)),pk_k(03acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764512102c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db51af682103acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbeac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"c:and_v(or_c(multi(2,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00,02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5),v:ripemd160(1b0f3c404d12075c68c938f9f60ebea4f74941a0)),pk_k(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556))\", \"5221036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a002102352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d552ae6482012088a6141b0f3c404d12075c68c938f9f60ebea4f74941a088682103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"and_v(andor(hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),v:hash256(939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735),v:older(50000)),after(499999999))\", \"82012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b2587640350c300b2696782012088aa20939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735886804ff64cd1db1\", TESTMODE_VALID);\n+    Test(\"andor(hash256(5f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040),j:and_v(v:hash160(3a2bff0da9d96868e66abc4427bea4691cf61ccd),older(4194305)),ripemd160(44d90e2d3714c8663b632fcf0f9d5f22192cc4c8))\", \"82012088aa205f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040876482012088a61444d90e2d3714c8663b632fcf0f9d5f22192cc4c8876782926382012088a9143a2bff0da9d96868e66abc4427bea4691cf61ccd8803010040b26868\", TESTMODE_VALID);\n+    Test(\"or_i(c:and_v(v:after(500000),pk_k(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),sha256(d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f946))\", \"630320a107b1692102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5ac6782012088a820d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f9468768\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"thresh(2,c:pk_h(025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc),s:sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),a:hash160(dd69735817e0e3f6f826a9238dc2e291184f0131))\", \"76a9145dedfbf9ea599dd4e3ca6a80b333c472fd0b3f6988ac7c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87936b82012088a914dd69735817e0e3f6f826a9238dc2e291184f0131876c935287\", TESTMODE_VALID);\n+    Test(\"and_n(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),uc:and_v(v:older(144),pk_k(03fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ce)))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764006763029000b2692103fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ceac67006868\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"and_n(c:pk_k(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),and_b(l:older(4252898),a:older(16)))\", \"2103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729ac64006763006703e2e440b2686b60b26c9a68\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG | TESTMODE_TIMELOCKMIX);\n+    Test(\"c:or_i(and_v(v:older(16),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e)),pk_h(026a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4))\", \"6360b26976a9149fc5dbe5efdce10374a4dd4053c93af540211718886776a9142fbd32c8dd59ee7c17e66cb6ebea7e9846c3040f8868ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"or_d(c:pk_h(02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),andor(c:pk_k(024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),older(2016),after(1567547623)))\", \"76a914c42e7ef92fdb603af844d064faad95db9bcdfd3d88ac736421024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97ac6404e7e06e5db16702e007b26868\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"c:andor(ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e),and_v(v:hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),pk_h(03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a)))\", \"82012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba876482012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b258876a914dd100be7d9aea5721158ebde6d6a1fd8fff93bb1886776a9149fc5dbe5efdce10374a4dd4053c93af5402117188868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"c:andor(u:ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),or_i(pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)))\", \"6382012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba87670068646376a9149652d86bedf43ad264362e6e6eba6eb764508127886776a914751e76e8199196d454941c45d1b3a323f1433bd688686776a91420d637c1a6404d2227f3561fdbaff5a680dba6488868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"c:or_i(andor(c:pk_h(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),pk_k(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e))\", \"6376a914fcd35ddacad9f2d5be5e464639441c6065e6955d88ac6476a91406afd46bcdfd22ef94ac122aa11f241244a37ecc886776a9149652d86bedf43ad264362e6e6eba6eb7645081278868672102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e68ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"thresh(1,c:pk_k(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),altv:after(1000000000),altv:after(100))\", \"2103d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65ac6b6300670400ca9a3bb16951686c936b6300670164b16951686c935187\", TESTMODE_VALID);\n+    Test(\"thresh(2,c:pk_k(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),ac:pk_k(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556),altv:after(1000000000),altv:after(100))\", \"2103d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65ac6b2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac6c936b6300670400ca9a3bb16951686c936b6300670164b16951686c935287\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_TIMELOCKMIX);\n+    // A threshold as large as the number of subs is valid.\n+    Test(\"thresh(2,c:pk_k(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),altv:after(100))\", \"2103d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65ac6b6300670164b16951686c935287\", TESTMODE_VALID | TESTMODE_NEEDSIG | TESTMODE_NONMAL);\n+    // A threshold of 1 is valid.\n+    Test(\"thresh(1,c:pk_k(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),sc:pk_k(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556))\", \"2103d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65ac7c2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac935187\", TESTMODE_VALID | TESTMODE_NEEDSIG | TESTMODE_NONMAL);\n+    // A threshold with a k larger than the number of subs is invalid\n+    Test(\"thresh(3,c:pk_k(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),sc:pk_k(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556))\", \"2103d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65ac7c2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac935187\", TESTMODE_INVALID);\n+    // A threshold with a k null is invalid\n+    Test(\"thresh(0,c:pk_k(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),sc:pk_k(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556))\", \"2103d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65ac7c2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac935187\", TESTMODE_INVALID);\n+\n+\n+    // Timelock tests\n+    Test(\"after(100)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // only heightlock\n+    Test(\"after(1000000000)\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL); // only timelock\n+    Test(\"or_b(l:after(100),al:after(1000000000))\", \"?\", TESTMODE_VALID); // or_b(timelock, heighlock) valid\n+    Test(\"and_b(after(100),a:after(1000000000))\", \"?\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_TIMELOCKMIX); // and_b(timelock, heighlock) invalid\n+    /* This is correctly detected as non-malleable but for the wrong reason. The type system assumes that branches 1 and 2\n+       can be spent together to create a non-malleble witness, but because of mixing of timelocks they cannot be spent together.\n+       But since exactly one of the two after's can be satisfied, the witness involving the key cannot be malleated.\n+    */\n+    Test(\"thresh(2,ltv:after(1000000000),altv:after(100),a:pk(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65))\", \"?\", TESTMODE_VALID | TESTMODE_TIMELOCKMIX | TESTMODE_NONMAL); // thresh with k = 2\n+    // This is actually non-malleable in practice, but we cannot detect it in type system. See above rationale\n+    Test(\"thresh(1,c:pk_k(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),altv:after(1000000000),altv:after(100))\", \"?\", TESTMODE_VALID); // thresh with k = 1\n+\n+\n+    g_testdata.reset();\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_tests)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792116302",
      "id" : 792116302,
      "line" : 415,
      "node_id" : "PRRC_kwDOABII584vNrxO",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 382,
      "original_position" : 382,
      "original_start_line" : null,
      "path" : "src/test/miniscript_tests.cpp",
      "position" : 382,
      "pull_request_review_id" : 862854599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792116302/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T21:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792116302",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792117110"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792117110"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Miniscript: conversion from script\"\r\n\r\nI think this change (as well as the one to `IsValidTopLevel` below) is in the wrong commit.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-25T21:02:45Z",
      "diff_hunk" : "@@ -549,10 +551,10 @@ struct Node {\n     Type GetType() const { return typ; }\n \n     //! Check whether this node is valid at all.\n-    bool IsValid() const { return !(GetType() == \"\"_mst); }\n+    bool IsValid() const { return !(GetType() == \"\"_mst) && ScriptSize() <= MAX_STANDARD_P2WSH_SCRIPT_SIZE; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r792117110",
      "id" : 792117110,
      "line" : 699,
      "node_id" : "PRRC_kwDOABII584vNr92",
      "original_commit_id" : "9d4cddd829206129fb09ee199516627a5668495a",
      "original_line" : 554,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 21,
      "pull_request_review_id" : 862854599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792117110/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T21:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/792117110",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#13062](https://github.com/bitcoin/bitcoin/pull/13062) (Make script interpreter independent from storage type CScript by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-01-26T00:26:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021735972",
      "id" : 1021735972,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII58485nQk",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021735972/reactions"
      },
      "updated_at" : "2022-03-18T09:03:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021735972",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r793854441"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/793854441"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't really like this revert. Does this also enable `CScript{} + CScriptBase{}`? If yes, that sounds bad, because you likely don't want to append data without pushing it.\r\n\r\nEven if it doesn't, is there any downside in having a named function for this? The existing `Cat` might even work for this?",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-27T17:43:36Z",
      "diff_hunk" : "@@ -429,6 +429,20 @@ class CScript : public CScriptBase\n \n     SERIALIZE_METHODS(CScript, obj) { READWRITEAS(CScriptBase, obj); }\n \n+    CScript& operator+=(const CScript& b)\n+    {\n+        reserve(size() + b.size());\n+        insert(end(), b.begin(), b.end());\n+        return *this;\n+    }\n+\n+    friend CScript operator+(const CScript& a, const CScript& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r793854441",
      "id" : 793854441,
      "line" : 441,
      "node_id" : "PRRC_kwDOABII584vUUHp",
      "original_commit_id" : "e4711c23cbe123f5791644f202acc3f8997c2448",
      "original_line" : 439,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : 11,
      "pull_request_review_id" : 865226116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/793854441/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-27T17:43:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/793854441",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "nice. Concept ACK.\n",
      "created_at" : "2022-01-27T21:03:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1023636751",
      "id" : 1023636751,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849A3UP",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1023636751/reactions"
      },
      "updated_at" : "2022-01-27T21:03:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1023636751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/45598?v=4",
         "events_url" : "https://api.github.com/users/jb55/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jb55/followers",
         "following_url" : "https://api.github.com/users/jb55/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jb55/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jb55",
         "id" : 45598,
         "login" : "jb55",
         "node_id" : "MDQ6VXNlcjQ1NTk4",
         "organizations_url" : "https://api.github.com/users/jb55/orgs",
         "received_events_url" : "https://api.github.com/users/jb55/received_events",
         "repos_url" : "https://api.github.com/users/jb55/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jb55/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jb55/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jb55"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-01-29T08:18:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1024864009",
      "id" : 1024864009,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849Fi8J",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024864009/reactions"
      },
      "updated_at" : "2022-01-29T08:18:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024864009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3072149?v=4",
         "events_url" : "https://api.github.com/users/dunxen/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dunxen/followers",
         "following_url" : "https://api.github.com/users/dunxen/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dunxen/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dunxen",
         "id" : 3072149,
         "login" : "dunxen",
         "node_id" : "MDQ6VXNlcjMwNzIxNDk=",
         "organizations_url" : "https://api.github.com/users/dunxen/orgs",
         "received_events_url" : "https://api.github.com/users/dunxen/received_events",
         "repos_url" : "https://api.github.com/users/dunxen/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dunxen/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dunxen/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dunxen"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Concept ACK. I wonder if it makes sense to start out with a small subset of miniscript, so reviewers can focus on the implementation rather than on completeness.\r\n\r\nI have tried to split this work into as many PR as reasonable, to reduce the size of this first chunk as much as possible. Note that 21% (you can't make this up) of the diff here is tests, and even more so in the following PRs. I'm afraid that further splitting this doesn't make sense.\r\nFor smaller chunks to review, commits here should be focused, atomic and independently reviewable.\r\n\r\nFurther, i'm currently simplifying a few things following Pieter's comments above.\r\nI'm happy to help review as much as i can, and if not for the first reviewers, comments like \"it took time for me to grasp this was doing X, [adding a comment here / rewriting it this way] would be helpful to following reviewers\" are very welcome!",
      "created_at" : "2022-01-29T09:37:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1024876678",
      "id" : 1024876678,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849FmCG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024876678/reactions"
      },
      "updated_at" : "2022-01-29T09:38:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024876678",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It's mostly 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c that introduces a rather large body of stuff. Conceptually `c:pk_k(key)` is the easiest thing to understand, the equivalent of a `pk()` descriptor. So one commit could introduce `NodeType` with just `PK_K` and `WRAP_C`, `Type` with just B and K implemented. That should make that commit about 90% smaller, while still introducing the main moving parts of a parser, constraint checking, etc.\r\n\r\nThis doesn't necessarily require more PR's, though it might: only a limited subset of the descriptor language is necessary to get the functionality currently in descriptors. So then you could go straight to #24148 and #24149, to finish the job of blending miniscript with descriptors, while using parallel PR's to expand the miniscript language.",
      "created_at" : "2022-01-29T15:33:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1024933026",
      "id" : 1024933026,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849Fzyi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024933026/reactions"
      },
      "updated_at" : "2022-01-29T15:37:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024933026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r795211395"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/795211395"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed, just using `Cat`does work.\r\n```diff\r\ndiff --git a/src/script/miniscript.h b/src/script/miniscript.h\r\nindex c67a3c4ea0..88fa4730cd 100644\r\n--- a/src/script/miniscript.h\r\n+++ b/src/script/miniscript.h\r\n@@ -446,7 +446,7 @@ public:\r\n                 case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\r\n                 case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\r\n                 case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\r\n-                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\r\n+                case NodeType::WRAP_A: return Cat(Cat((CScript() << OP_TOALTSTACK), std::move(subs[0])), (CScript() << OP_FROMALTSTACK));\r\n                 case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\r\n                 case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\r\n                 case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\r\n```\r\n\r\nI'll look into adding a `Cat()` which takes variadic arguments, instead of nesting them and creating more vectors than needed.\r\n\r\nUpdate: current plan is to have a `BuildScript()` instead.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-30T16:33:29Z",
      "diff_hunk" : "@@ -429,6 +429,20 @@ class CScript : public CScriptBase\n \n     SERIALIZE_METHODS(CScript, obj) { READWRITEAS(CScriptBase, obj); }\n \n+    CScript& operator+=(const CScript& b)\n+    {\n+        reserve(size() + b.size());\n+        insert(end(), b.begin(), b.end());\n+        return *this;\n+    }\n+\n+    friend CScript operator+(const CScript& a, const CScript& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r795211395",
      "id" : 795211395,
      "in_reply_to_id" : 793854441,
      "line" : 441,
      "node_id" : "PRRC_kwDOABII584vZfaD",
      "original_commit_id" : "e4711c23cbe123f5791644f202acc3f8997c2448",
      "original_line" : 439,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : 11,
      "pull_request_review_id" : 867142814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/795211395/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-01T08:23:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/795211395",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796078234"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796078234"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nnit: spelling `subexpressions`",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T21:28:08Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796078234",
      "id" : 796078234,
      "line" : 413,
      "node_id" : "PRRC_kwDOABII584vczCa",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 366,
      "original_position" : 366,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 366,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796078234/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796078234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796086703"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796086703"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nI think the pattern `(CScript() << OP_BLAH)` can be simplified to `CScript(OP_BLAH)`.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T21:41:17Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796086703",
      "id" : 796086703,
      "line" : 464,
      "node_id" : "PRRC_kwDOABII584vc1Gv",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 417,
      "original_position" : 417,
      "original_start_line" : 394,
      "path" : "src/script/miniscript.h",
      "position" : 417,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796086703/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 441,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796086703",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796096601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796096601"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nI don't understand why a new switch-case block starts here. Couldn't this just be part of the previous one?",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T21:55:46Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::MULTI: {\n+                    CScript script = CScript() << node.k;\n+                    for (const auto& key : node.keys) {\n+                        script << ctx.ToPKBytes(key);\n+                    }\n+                    return std::move(script) << node.keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+                }\n+                case NodeType::THRESH: {\n+                    CScript script = std::move(subs[0]);\n+                    for (size_t i = 1; i < subs.size(); ++i) {\n+                        script = (std::move(script) + std::move(subs[i])) << OP_ADD;\n+                    }\n+                    return std::move(script) << node.k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                }\n+            }\n+            assert(false);\n+            return {};\n+        };\n+        return TreeEval<CScript>(false, downfn, upfn);\n+    }\n+\n+    template<typename CTx>\n+    bool ToString(const CTx& ctx, std::string& ret) const {\n+        // To construct the std::string representation for a Miniscript object, we use\n+        // the TreeEvalMaybe algorithm. The State is a boolean: whether the parent node is a\n+        // wrapper. If so, non-wrapper expressions must be prefixed with a \":\".\n+        auto downfn = [](bool, const Node& node, size_t) {\n+            return (node.nodetype == NodeType::WRAP_A || node.nodetype == NodeType::WRAP_S ||\n+                    node.nodetype == NodeType::WRAP_D || node.nodetype == NodeType::WRAP_V ||\n+                    node.nodetype == NodeType::WRAP_J || node.nodetype == NodeType::WRAP_N ||\n+                    node.nodetype == NodeType::WRAP_C ||\n+                    (node.nodetype == NodeType::AND_V && node.subs[1]->nodetype == NodeType::JUST_1) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[0]->nodetype == NodeType::JUST_0) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[1]->nodetype == NodeType::JUST_0));\n+        };\n+        // The upward function computes for a node, given whether its parent is a wrapper,\n+        // and the string representations of its child nodes, the string representation of the node.\n+        auto upfn = [&ctx](bool wrapped, const Node& node, Span<std::string> subs) -> std::optional<std::string> {\n+            std::string ret = wrapped ? \":\" : \"\";\n+\n+            switch (node.nodetype) {\n+                case NodeType::WRAP_A: return \"a\" + std::move(subs[0]);\n+                case NodeType::WRAP_S: return \"s\" + std::move(subs[0]);\n+                case NodeType::WRAP_C:\n+                    if (node.subs[0]->nodetype == NodeType::PK_K) {\n+                        // pk(K) is syntactic sugar for c:pk_k(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+                    }\n+                    if (node.subs[0]->nodetype == NodeType::PK_H) {\n+                        // pkh(K) is syntactic sugar for c:pk_h(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pkh(\" + std::move(key_str) + \")\";\n+                    }\n+                    return \"c\" + std::move(subs[0]);\n+                case NodeType::WRAP_D: return \"d\" + std::move(subs[0]);\n+                case NodeType::WRAP_V: return \"v\" + std::move(subs[0]);\n+                case NodeType::WRAP_J: return \"j\" + std::move(subs[0]);\n+                case NodeType::WRAP_N: return \"n\" + std::move(subs[0]);\n+                case NodeType::AND_V:\n+                    // t:X is syntactic sugar for and_v(X,1).\n+                    if (node.subs[1]->nodetype == NodeType::JUST_1) return \"t\" + std::move(subs[0]);\n+                    break;\n+                case NodeType::OR_I:\n+                    if (node.subs[0]->nodetype == NodeType::JUST_0) return \"l\" + std::move(subs[1]);\n+                    if (node.subs[1]->nodetype == NodeType::JUST_0) return \"u\" + std::move(subs[0]);\n+                    break;\n+                default: break;\n+            }\n+            switch (node.nodetype) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796096601",
      "id" : 796096601,
      "line" : 536,
      "node_id" : "PRRC_kwDOABII584vc3hZ",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 489,
      "original_position" : 489,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 489,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796096601/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796096601",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796098118"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796098118"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nIt would be nice if `NodeType` and `Type` were named with more distinct names so that it is less confusing about what \"type\" is being referred to.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T21:57:38Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796098118",
      "id" : 796098118,
      "line" : 183,
      "node_id" : "PRRC_kwDOABII584vc35G",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 182,
      "original_position" : 182,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 182,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796098118/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796098118",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796104623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796104623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nCan the key parsing stuff be refactored into its own function instead of copy and pasted for the next 3 expressions?",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T22:07:46Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::MULTI: {\n+                    CScript script = CScript() << node.k;\n+                    for (const auto& key : node.keys) {\n+                        script << ctx.ToPKBytes(key);\n+                    }\n+                    return std::move(script) << node.keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+                }\n+                case NodeType::THRESH: {\n+                    CScript script = std::move(subs[0]);\n+                    for (size_t i = 1; i < subs.size(); ++i) {\n+                        script = (std::move(script) + std::move(subs[i])) << OP_ADD;\n+                    }\n+                    return std::move(script) << node.k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                }\n+            }\n+            assert(false);\n+            return {};\n+        };\n+        return TreeEval<CScript>(false, downfn, upfn);\n+    }\n+\n+    template<typename CTx>\n+    bool ToString(const CTx& ctx, std::string& ret) const {\n+        // To construct the std::string representation for a Miniscript object, we use\n+        // the TreeEvalMaybe algorithm. The State is a boolean: whether the parent node is a\n+        // wrapper. If so, non-wrapper expressions must be prefixed with a \":\".\n+        auto downfn = [](bool, const Node& node, size_t) {\n+            return (node.nodetype == NodeType::WRAP_A || node.nodetype == NodeType::WRAP_S ||\n+                    node.nodetype == NodeType::WRAP_D || node.nodetype == NodeType::WRAP_V ||\n+                    node.nodetype == NodeType::WRAP_J || node.nodetype == NodeType::WRAP_N ||\n+                    node.nodetype == NodeType::WRAP_C ||\n+                    (node.nodetype == NodeType::AND_V && node.subs[1]->nodetype == NodeType::JUST_1) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[0]->nodetype == NodeType::JUST_0) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[1]->nodetype == NodeType::JUST_0));\n+        };\n+        // The upward function computes for a node, given whether its parent is a wrapper,\n+        // and the string representations of its child nodes, the string representation of the node.\n+        auto upfn = [&ctx](bool wrapped, const Node& node, Span<std::string> subs) -> std::optional<std::string> {\n+            std::string ret = wrapped ? \":\" : \"\";\n+\n+            switch (node.nodetype) {\n+                case NodeType::WRAP_A: return \"a\" + std::move(subs[0]);\n+                case NodeType::WRAP_S: return \"s\" + std::move(subs[0]);\n+                case NodeType::WRAP_C:\n+                    if (node.subs[0]->nodetype == NodeType::PK_K) {\n+                        // pk(K) is syntactic sugar for c:pk_k(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+                    }\n+                    if (node.subs[0]->nodetype == NodeType::PK_H) {\n+                        // pkh(K) is syntactic sugar for c:pk_h(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pkh(\" + std::move(key_str) + \")\";\n+                    }\n+                    return \"c\" + std::move(subs[0]);\n+                case NodeType::WRAP_D: return \"d\" + std::move(subs[0]);\n+                case NodeType::WRAP_V: return \"v\" + std::move(subs[0]);\n+                case NodeType::WRAP_J: return \"j\" + std::move(subs[0]);\n+                case NodeType::WRAP_N: return \"n\" + std::move(subs[0]);\n+                case NodeType::AND_V:\n+                    // t:X is syntactic sugar for and_v(X,1).\n+                    if (node.subs[1]->nodetype == NodeType::JUST_1) return \"t\" + std::move(subs[0]);\n+                    break;\n+                case NodeType::OR_I:\n+                    if (node.subs[0]->nodetype == NodeType::JUST_0) return \"l\" + std::move(subs[1]);\n+                    if (node.subs[1]->nodetype == NodeType::JUST_0) return \"u\" + std::move(subs[0]);\n+                    break;\n+                default: break;\n+            }\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: {\n+                    std::string key_str;\n+                    if (!ctx.ToString(node.keys[0], key_str)) return {};\n+                    return std::move(ret) + \"pk_k(\" + std::move(key_str) + \")\";\n+                }\n+                case NodeType::PK_H: {\n+                    std::string key_str;\n+                    if (!ctx.ToString(node.keys[0], key_str)) return {};\n+                    return std::move(ret) + \"pk_h(\" + std::move(key_str) + \")\";\n+                }\n+                case NodeType::AFTER: return std::move(ret) + \"after(\" + ::ToString(node.k) + \")\";\n+                case NodeType::OLDER: return std::move(ret) + \"older(\" + ::ToString(node.k) + \")\";\n+                case NodeType::HASH256: return std::move(ret) + \"hash256(\" + HexStr(node.data) + \")\";\n+                case NodeType::HASH160: return std::move(ret) + \"hash160(\" + HexStr(node.data) + \")\";\n+                case NodeType::SHA256: return std::move(ret) + \"sha256(\" + HexStr(node.data) + \")\";\n+                case NodeType::RIPEMD160: return std::move(ret) + \"ripemd160(\" + HexStr(node.data) + \")\";\n+                case NodeType::JUST_1: return std::move(ret) + \"1\";\n+                case NodeType::JUST_0: return std::move(ret) + \"0\";\n+                case NodeType::AND_V: return std::move(ret) + \"and_v(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::AND_B: return std::move(ret) + \"and_b(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_B: return std::move(ret) + \"or_b(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_D: return std::move(ret) + \"or_d(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_C: return std::move(ret) + \"or_c(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_I: return std::move(ret) + \"or_i(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::ANDOR:\n+                    // and_n(X,Y) is syntactic sugar for andor(X,Y,0).\n+                    if (node.subs[2]->nodetype == NodeType::JUST_0) return std::move(ret) + \"and_n(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                    return std::move(ret) + \"andor(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \",\" + std::move(subs[2]) + \")\";\n+                case NodeType::MULTI: {\n+                    auto str = std::move(ret) + \"multi(\" + ::ToString(node.k);\n+                    for (const auto& key : node.keys) {\n+                        std::string key_str;\n+                        if (!ctx.ToString(key, key_str)) return {};\n+                        str += \",\" + std::move(key_str);\n+                    }\n+                    return std::move(str) + \")\";\n+                }\n+                case NodeType::THRESH: {\n+                    auto str = std::move(ret) + \"thresh(\" + ::ToString(node.k);\n+                    for (auto& sub : subs) {\n+                        str += \",\" + std::move(sub);\n+                    }\n+                    return std::move(str) + \")\";\n+                }\n+                default: assert(false);\n+            }\n+            return \"\"; // Should never be reached.\n+        };\n+\n+        auto res = TreeEvalMaybe<std::string>(false, downfn, upfn);\n+        if (res.has_value()) ret = std::move(*res);\n+        return res.has_value();\n+    }\n+\n+public:\n+    //! Return the size of the script for this expression (faster than ToScript().size()).\n+    size_t ScriptSize() const { return scriptlen; }\n+\n+    //! Return the expression type.\n+    Type GetType() const { return typ; }\n+\n+    //! Check whether this node is valid at all.\n+    bool IsValid() const { return !(GetType() == \"\"_mst); }\n+\n+    //! Check whether this node is valid as a script on its own.\n+    bool IsValidTopLevel() const { return GetType() << \"B\"_mst; }\n+\n+    //! Check whether this script can always be satisfied in a non-malleable way.\n+    bool IsNonMalleable() const { return GetType() << \"m\"_mst; }\n+\n+    //! Check whether this script always needs a signature.\n+    bool NeedsSignature() const { return GetType() << \"s\"_mst; }\n+\n+    //! Do all sanity checks.\n+    bool IsSane() const { return GetType() << \"mk\"_mst && IsValid(); }\n+\n+    //! Check whether this node is safe as a script on its own.\n+    bool IsSaneTopLevel() const { return IsValidTopLevel() && IsSane() && NeedsSignature(); }\n+\n+    //! Equality testing.\n+    bool operator==(const Node<Key>& arg) const\n+    {\n+        if (nodetype != arg.nodetype) return false;\n+        if (k != arg.k) return false;\n+        if (data != arg.data) return false;\n+        if (keys != arg.keys) return false;\n+        if (subs.size() != arg.subs.size()) return false;\n+        for (size_t i = 0; i < subs.size(); ++i) {\n+            if (!(*subs[i] == *arg.subs[i])) return false;\n+        }\n+        assert(scriptlen == arg.scriptlen);\n+        assert(typ == arg.typ);\n+        return true;\n+    }\n+\n+    // Constructors with various argument combinations.\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, uint32_t val = 0) : nodetype(nt), k(val), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, uint32_t val = 0) : nodetype(nt), k(val), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+};\n+\n+namespace internal {\n+\n+enum class ParseContext {\n+    /** An expression which may be begin with wrappers followed by a colon. */\n+    WRAPPED_EXPR,\n+    /** A miniscript expression which does not begin with wrappers. */\n+    EXPR,\n+\n+    /** SWAP wraps the top constructed node with s: */\n+    SWAP,\n+    /** ALT wraps the top constructed node with a: */\n+    ALT,\n+    /** CHECK wraps the top constructed node with c: */\n+    CHECK,\n+    /** DUP_IF wraps the top constructed node with d: */\n+    DUP_IF,\n+    /** VERIFY wraps the top constructed node with v: */\n+    VERIFY,\n+    /** NON_ZERO wraps the top constructed node with j: */\n+    NON_ZERO,\n+    /** ZERO_NOTEQUAL wraps the top constructed node with n: */\n+    ZERO_NOTEQUAL,\n+    /** WRAP_U will construct an or_i(X,0) node from the top constructed node. */\n+    WRAP_U,\n+    /** WRAP_T will construct an and_v(X,1) node from the top constructed node. */\n+    WRAP_T,\n+\n+    /** AND_N will construct an andor(X,Y,0) node from the last two constructed nodes. */\n+    AND_N,\n+    /** AND_V will construct an and_v node from the last two constructed nodes. */\n+    AND_V,\n+    /** AND_B will construct an and_b node from the last two constructed nodes. */\n+    AND_B,\n+    /** ANDOR will construct an andor node from the last three constructed nodes. */\n+    ANDOR,\n+    /** OR_B will construct an or_b node from the last two constructed nodes. */\n+    OR_B,\n+    /** OR_C will construct an or_c node from the last two constructed nodes. */\n+    OR_C,\n+    /** OR_D will construct an or_d node from the last two constructed nodes. */\n+    OR_D,\n+    /** OR_I will construct an or_i node from the last two constructed nodes. */\n+    OR_I,\n+\n+    /** THRESH will read a wrapped expression, and then look for a COMMA. If\n+     * no comma follows, it will construct a thresh node from the appropriate\n+     * number of constructed children. Otherwise, it will recurse with another\n+     * THRESH. */\n+    THRESH,\n+\n+    /** COMMA expects the next element to be ',' and fails if not. */\n+    COMMA,\n+    /** CLOSE_BRACKET expects the next element to be ')' and fails if not. */\n+    CLOSE_BRACKET,\n+};\n+\n+\n+int FindNextChar(Span<const char> in, const char m);\n+\n+/** BuildBack pops the last two elements off `constructed` and wraps them in the specified NodeType */\n+template<typename Key>\n+void BuildBack(NodeType nt, std::vector<NodeRef<Key>>& constructed, const bool reverse = false)\n+{\n+    NodeRef<Key> child = std::move(constructed.back());\n+    constructed.pop_back();\n+    if (reverse) {\n+        constructed.back() = MakeNodeRef<Key>(nt, Vector(std::move(child), std::move(constructed.back())));\n+    } else {\n+        constructed.back() = MakeNodeRef<Key>(nt, Vector(std::move(constructed.back()), std::move(child)));\n+    }\n+}\n+\n+//! Parse a miniscript from its textual descriptor form.\n+template<typename Key, typename Ctx>\n+inline NodeRef<Key> Parse(Span<const char> in, const Ctx& ctx)\n+{\n+    using namespace spanparsing;\n+\n+    // The two integers are used to hold state for thresh()\n+    std::vector<std::tuple<ParseContext, int64_t, int64_t>> to_parse;\n+    std::vector<NodeRef<Key>> constructed;\n+\n+    to_parse.emplace_back(ParseContext::WRAPPED_EXPR, -1, -1);\n+\n+    while (!to_parse.empty()) {\n+        // Get the current context we are decoding within\n+        auto [cur_context, n, k] = to_parse.back();\n+        to_parse.pop_back();\n+\n+        switch (cur_context) {\n+        case ParseContext::WRAPPED_EXPR: {\n+            int colon_index = -1;\n+            for (int i = 1; i < (int)in.size(); ++i) {\n+                if (in[i] == ':') {\n+                    colon_index = i;\n+                    break;\n+                }\n+                if (in[i] < 'a' || in[i] > 'z') break;\n+            }\n+            // If there is no colon, this loop won't execute\n+            for (int j = 0; j < colon_index; ++j) {\n+                if (in[j] == 'a') {\n+                    to_parse.emplace_back(ParseContext::ALT, -1, -1);\n+                } else if (in[j] == 's') {\n+                    to_parse.emplace_back(ParseContext::SWAP, -1, -1);\n+                } else if (in[j] == 'c') {\n+                    to_parse.emplace_back(ParseContext::CHECK, -1, -1);\n+                } else if (in[j] == 'd') {\n+                    to_parse.emplace_back(ParseContext::DUP_IF, -1, -1);\n+                } else if (in[j] == 'j') {\n+                    to_parse.emplace_back(ParseContext::NON_ZERO, -1, -1);\n+                } else if (in[j] == 'n') {\n+                    to_parse.emplace_back(ParseContext::ZERO_NOTEQUAL, -1, -1);\n+                } else if (in[j] == 'v') {\n+                    to_parse.emplace_back(ParseContext::VERIFY, -1, -1);\n+                } else if (in[j] == 'u') {\n+                    to_parse.emplace_back(ParseContext::WRAP_U, -1, -1);\n+                } else if (in[j] == 't') {\n+                    to_parse.emplace_back(ParseContext::WRAP_T, -1, -1);\n+                } else if (in[j] == 'l') {\n+                    // The l: wrapper is equivalent to or_i(0,X)\n+                    constructed.push_back(MakeNodeRef<Key>(NodeType::JUST_0));\n+                    to_parse.emplace_back(ParseContext::OR_I, -1, -1);\n+                } else {\n+                    return {};\n+                }\n+            }\n+            to_parse.emplace_back(ParseContext::EXPR, -1, -1);\n+            in = in.subspan(colon_index + 1);\n+            break;\n+        }\n+        case ParseContext::EXPR: {\n+            if (Const(\"0\", in)) {\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::JUST_0));\n+            } else if (Const(\"1\", in)) {\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::JUST_1));\n+            } else if (Const(\"pk(\", in)) {\n+                Key key;\n+                int key_size = FindNextChar(in, ')');\n+                if (key_size < 1) return {};\n+                if (!ctx.FromString(in.begin(), in.begin() + key_size, key)) return {};\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::WRAP_C, Vector(MakeNodeRef<Key>(NodeType::PK_K, Vector(std::move(key))))));\n+                in = in.subspan(key_size + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796104623",
      "id" : 796104623,
      "line" : 883,
      "node_id" : "PRRC_kwDOABII584vc5ev",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 736,
      "original_position" : 736,
      "original_start_line" : 731,
      "path" : "src/script/miniscript.h",
      "position" : 736,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796104623/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 878,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796104623",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796104879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796104879"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nCan the hex data parsing stuff be refactored into a function instead of copy and pasted for the next 3 expressions?",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T22:08:10Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::MULTI: {\n+                    CScript script = CScript() << node.k;\n+                    for (const auto& key : node.keys) {\n+                        script << ctx.ToPKBytes(key);\n+                    }\n+                    return std::move(script) << node.keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+                }\n+                case NodeType::THRESH: {\n+                    CScript script = std::move(subs[0]);\n+                    for (size_t i = 1; i < subs.size(); ++i) {\n+                        script = (std::move(script) + std::move(subs[i])) << OP_ADD;\n+                    }\n+                    return std::move(script) << node.k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                }\n+            }\n+            assert(false);\n+            return {};\n+        };\n+        return TreeEval<CScript>(false, downfn, upfn);\n+    }\n+\n+    template<typename CTx>\n+    bool ToString(const CTx& ctx, std::string& ret) const {\n+        // To construct the std::string representation for a Miniscript object, we use\n+        // the TreeEvalMaybe algorithm. The State is a boolean: whether the parent node is a\n+        // wrapper. If so, non-wrapper expressions must be prefixed with a \":\".\n+        auto downfn = [](bool, const Node& node, size_t) {\n+            return (node.nodetype == NodeType::WRAP_A || node.nodetype == NodeType::WRAP_S ||\n+                    node.nodetype == NodeType::WRAP_D || node.nodetype == NodeType::WRAP_V ||\n+                    node.nodetype == NodeType::WRAP_J || node.nodetype == NodeType::WRAP_N ||\n+                    node.nodetype == NodeType::WRAP_C ||\n+                    (node.nodetype == NodeType::AND_V && node.subs[1]->nodetype == NodeType::JUST_1) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[0]->nodetype == NodeType::JUST_0) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[1]->nodetype == NodeType::JUST_0));\n+        };\n+        // The upward function computes for a node, given whether its parent is a wrapper,\n+        // and the string representations of its child nodes, the string representation of the node.\n+        auto upfn = [&ctx](bool wrapped, const Node& node, Span<std::string> subs) -> std::optional<std::string> {\n+            std::string ret = wrapped ? \":\" : \"\";\n+\n+            switch (node.nodetype) {\n+                case NodeType::WRAP_A: return \"a\" + std::move(subs[0]);\n+                case NodeType::WRAP_S: return \"s\" + std::move(subs[0]);\n+                case NodeType::WRAP_C:\n+                    if (node.subs[0]->nodetype == NodeType::PK_K) {\n+                        // pk(K) is syntactic sugar for c:pk_k(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+                    }\n+                    if (node.subs[0]->nodetype == NodeType::PK_H) {\n+                        // pkh(K) is syntactic sugar for c:pk_h(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pkh(\" + std::move(key_str) + \")\";\n+                    }\n+                    return \"c\" + std::move(subs[0]);\n+                case NodeType::WRAP_D: return \"d\" + std::move(subs[0]);\n+                case NodeType::WRAP_V: return \"v\" + std::move(subs[0]);\n+                case NodeType::WRAP_J: return \"j\" + std::move(subs[0]);\n+                case NodeType::WRAP_N: return \"n\" + std::move(subs[0]);\n+                case NodeType::AND_V:\n+                    // t:X is syntactic sugar for and_v(X,1).\n+                    if (node.subs[1]->nodetype == NodeType::JUST_1) return \"t\" + std::move(subs[0]);\n+                    break;\n+                case NodeType::OR_I:\n+                    if (node.subs[0]->nodetype == NodeType::JUST_0) return \"l\" + std::move(subs[1]);\n+                    if (node.subs[1]->nodetype == NodeType::JUST_0) return \"u\" + std::move(subs[0]);\n+                    break;\n+                default: break;\n+            }\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: {\n+                    std::string key_str;\n+                    if (!ctx.ToString(node.keys[0], key_str)) return {};\n+                    return std::move(ret) + \"pk_k(\" + std::move(key_str) + \")\";\n+                }\n+                case NodeType::PK_H: {\n+                    std::string key_str;\n+                    if (!ctx.ToString(node.keys[0], key_str)) return {};\n+                    return std::move(ret) + \"pk_h(\" + std::move(key_str) + \")\";\n+                }\n+                case NodeType::AFTER: return std::move(ret) + \"after(\" + ::ToString(node.k) + \")\";\n+                case NodeType::OLDER: return std::move(ret) + \"older(\" + ::ToString(node.k) + \")\";\n+                case NodeType::HASH256: return std::move(ret) + \"hash256(\" + HexStr(node.data) + \")\";\n+                case NodeType::HASH160: return std::move(ret) + \"hash160(\" + HexStr(node.data) + \")\";\n+                case NodeType::SHA256: return std::move(ret) + \"sha256(\" + HexStr(node.data) + \")\";\n+                case NodeType::RIPEMD160: return std::move(ret) + \"ripemd160(\" + HexStr(node.data) + \")\";\n+                case NodeType::JUST_1: return std::move(ret) + \"1\";\n+                case NodeType::JUST_0: return std::move(ret) + \"0\";\n+                case NodeType::AND_V: return std::move(ret) + \"and_v(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::AND_B: return std::move(ret) + \"and_b(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_B: return std::move(ret) + \"or_b(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_D: return std::move(ret) + \"or_d(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_C: return std::move(ret) + \"or_c(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::OR_I: return std::move(ret) + \"or_i(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                case NodeType::ANDOR:\n+                    // and_n(X,Y) is syntactic sugar for andor(X,Y,0).\n+                    if (node.subs[2]->nodetype == NodeType::JUST_0) return std::move(ret) + \"and_n(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \")\";\n+                    return std::move(ret) + \"andor(\" + std::move(subs[0]) + \",\" + std::move(subs[1]) + \",\" + std::move(subs[2]) + \")\";\n+                case NodeType::MULTI: {\n+                    auto str = std::move(ret) + \"multi(\" + ::ToString(node.k);\n+                    for (const auto& key : node.keys) {\n+                        std::string key_str;\n+                        if (!ctx.ToString(key, key_str)) return {};\n+                        str += \",\" + std::move(key_str);\n+                    }\n+                    return std::move(str) + \")\";\n+                }\n+                case NodeType::THRESH: {\n+                    auto str = std::move(ret) + \"thresh(\" + ::ToString(node.k);\n+                    for (auto& sub : subs) {\n+                        str += \",\" + std::move(sub);\n+                    }\n+                    return std::move(str) + \")\";\n+                }\n+                default: assert(false);\n+            }\n+            return \"\"; // Should never be reached.\n+        };\n+\n+        auto res = TreeEvalMaybe<std::string>(false, downfn, upfn);\n+        if (res.has_value()) ret = std::move(*res);\n+        return res.has_value();\n+    }\n+\n+public:\n+    //! Return the size of the script for this expression (faster than ToScript().size()).\n+    size_t ScriptSize() const { return scriptlen; }\n+\n+    //! Return the expression type.\n+    Type GetType() const { return typ; }\n+\n+    //! Check whether this node is valid at all.\n+    bool IsValid() const { return !(GetType() == \"\"_mst); }\n+\n+    //! Check whether this node is valid as a script on its own.\n+    bool IsValidTopLevel() const { return GetType() << \"B\"_mst; }\n+\n+    //! Check whether this script can always be satisfied in a non-malleable way.\n+    bool IsNonMalleable() const { return GetType() << \"m\"_mst; }\n+\n+    //! Check whether this script always needs a signature.\n+    bool NeedsSignature() const { return GetType() << \"s\"_mst; }\n+\n+    //! Do all sanity checks.\n+    bool IsSane() const { return GetType() << \"mk\"_mst && IsValid(); }\n+\n+    //! Check whether this node is safe as a script on its own.\n+    bool IsSaneTopLevel() const { return IsValidTopLevel() && IsSane() && NeedsSignature(); }\n+\n+    //! Equality testing.\n+    bool operator==(const Node<Key>& arg) const\n+    {\n+        if (nodetype != arg.nodetype) return false;\n+        if (k != arg.k) return false;\n+        if (data != arg.data) return false;\n+        if (keys != arg.keys) return false;\n+        if (subs.size() != arg.subs.size()) return false;\n+        for (size_t i = 0; i < subs.size(); ++i) {\n+            if (!(*subs[i] == *arg.subs[i])) return false;\n+        }\n+        assert(scriptlen == arg.scriptlen);\n+        assert(typ == arg.typ);\n+        return true;\n+    }\n+\n+    // Constructors with various argument combinations.\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, uint32_t val = 0) : nodetype(nt), k(val), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, uint32_t val = 0) : nodetype(nt), k(val), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+};\n+\n+namespace internal {\n+\n+enum class ParseContext {\n+    /** An expression which may be begin with wrappers followed by a colon. */\n+    WRAPPED_EXPR,\n+    /** A miniscript expression which does not begin with wrappers. */\n+    EXPR,\n+\n+    /** SWAP wraps the top constructed node with s: */\n+    SWAP,\n+    /** ALT wraps the top constructed node with a: */\n+    ALT,\n+    /** CHECK wraps the top constructed node with c: */\n+    CHECK,\n+    /** DUP_IF wraps the top constructed node with d: */\n+    DUP_IF,\n+    /** VERIFY wraps the top constructed node with v: */\n+    VERIFY,\n+    /** NON_ZERO wraps the top constructed node with j: */\n+    NON_ZERO,\n+    /** ZERO_NOTEQUAL wraps the top constructed node with n: */\n+    ZERO_NOTEQUAL,\n+    /** WRAP_U will construct an or_i(X,0) node from the top constructed node. */\n+    WRAP_U,\n+    /** WRAP_T will construct an and_v(X,1) node from the top constructed node. */\n+    WRAP_T,\n+\n+    /** AND_N will construct an andor(X,Y,0) node from the last two constructed nodes. */\n+    AND_N,\n+    /** AND_V will construct an and_v node from the last two constructed nodes. */\n+    AND_V,\n+    /** AND_B will construct an and_b node from the last two constructed nodes. */\n+    AND_B,\n+    /** ANDOR will construct an andor node from the last three constructed nodes. */\n+    ANDOR,\n+    /** OR_B will construct an or_b node from the last two constructed nodes. */\n+    OR_B,\n+    /** OR_C will construct an or_c node from the last two constructed nodes. */\n+    OR_C,\n+    /** OR_D will construct an or_d node from the last two constructed nodes. */\n+    OR_D,\n+    /** OR_I will construct an or_i node from the last two constructed nodes. */\n+    OR_I,\n+\n+    /** THRESH will read a wrapped expression, and then look for a COMMA. If\n+     * no comma follows, it will construct a thresh node from the appropriate\n+     * number of constructed children. Otherwise, it will recurse with another\n+     * THRESH. */\n+    THRESH,\n+\n+    /** COMMA expects the next element to be ',' and fails if not. */\n+    COMMA,\n+    /** CLOSE_BRACKET expects the next element to be ')' and fails if not. */\n+    CLOSE_BRACKET,\n+};\n+\n+\n+int FindNextChar(Span<const char> in, const char m);\n+\n+/** BuildBack pops the last two elements off `constructed` and wraps them in the specified NodeType */\n+template<typename Key>\n+void BuildBack(NodeType nt, std::vector<NodeRef<Key>>& constructed, const bool reverse = false)\n+{\n+    NodeRef<Key> child = std::move(constructed.back());\n+    constructed.pop_back();\n+    if (reverse) {\n+        constructed.back() = MakeNodeRef<Key>(nt, Vector(std::move(child), std::move(constructed.back())));\n+    } else {\n+        constructed.back() = MakeNodeRef<Key>(nt, Vector(std::move(constructed.back()), std::move(child)));\n+    }\n+}\n+\n+//! Parse a miniscript from its textual descriptor form.\n+template<typename Key, typename Ctx>\n+inline NodeRef<Key> Parse(Span<const char> in, const Ctx& ctx)\n+{\n+    using namespace spanparsing;\n+\n+    // The two integers are used to hold state for thresh()\n+    std::vector<std::tuple<ParseContext, int64_t, int64_t>> to_parse;\n+    std::vector<NodeRef<Key>> constructed;\n+\n+    to_parse.emplace_back(ParseContext::WRAPPED_EXPR, -1, -1);\n+\n+    while (!to_parse.empty()) {\n+        // Get the current context we are decoding within\n+        auto [cur_context, n, k] = to_parse.back();\n+        to_parse.pop_back();\n+\n+        switch (cur_context) {\n+        case ParseContext::WRAPPED_EXPR: {\n+            int colon_index = -1;\n+            for (int i = 1; i < (int)in.size(); ++i) {\n+                if (in[i] == ':') {\n+                    colon_index = i;\n+                    break;\n+                }\n+                if (in[i] < 'a' || in[i] > 'z') break;\n+            }\n+            // If there is no colon, this loop won't execute\n+            for (int j = 0; j < colon_index; ++j) {\n+                if (in[j] == 'a') {\n+                    to_parse.emplace_back(ParseContext::ALT, -1, -1);\n+                } else if (in[j] == 's') {\n+                    to_parse.emplace_back(ParseContext::SWAP, -1, -1);\n+                } else if (in[j] == 'c') {\n+                    to_parse.emplace_back(ParseContext::CHECK, -1, -1);\n+                } else if (in[j] == 'd') {\n+                    to_parse.emplace_back(ParseContext::DUP_IF, -1, -1);\n+                } else if (in[j] == 'j') {\n+                    to_parse.emplace_back(ParseContext::NON_ZERO, -1, -1);\n+                } else if (in[j] == 'n') {\n+                    to_parse.emplace_back(ParseContext::ZERO_NOTEQUAL, -1, -1);\n+                } else if (in[j] == 'v') {\n+                    to_parse.emplace_back(ParseContext::VERIFY, -1, -1);\n+                } else if (in[j] == 'u') {\n+                    to_parse.emplace_back(ParseContext::WRAP_U, -1, -1);\n+                } else if (in[j] == 't') {\n+                    to_parse.emplace_back(ParseContext::WRAP_T, -1, -1);\n+                } else if (in[j] == 'l') {\n+                    // The l: wrapper is equivalent to or_i(0,X)\n+                    constructed.push_back(MakeNodeRef<Key>(NodeType::JUST_0));\n+                    to_parse.emplace_back(ParseContext::OR_I, -1, -1);\n+                } else {\n+                    return {};\n+                }\n+            }\n+            to_parse.emplace_back(ParseContext::EXPR, -1, -1);\n+            in = in.subspan(colon_index + 1);\n+            break;\n+        }\n+        case ParseContext::EXPR: {\n+            if (Const(\"0\", in)) {\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::JUST_0));\n+            } else if (Const(\"1\", in)) {\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::JUST_1));\n+            } else if (Const(\"pk(\", in)) {\n+                Key key;\n+                int key_size = FindNextChar(in, ')');\n+                if (key_size < 1) return {};\n+                if (!ctx.FromString(in.begin(), in.begin() + key_size, key)) return {};\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::WRAP_C, Vector(MakeNodeRef<Key>(NodeType::PK_K, Vector(std::move(key))))));\n+                in = in.subspan(key_size + 1);\n+            } else if (Const(\"pkh(\", in)) {\n+                Key key;\n+                int key_size = FindNextChar(in, ')');\n+                if (key_size < 1) return {};\n+                if (!ctx.FromString(in.begin(), in.begin() + key_size, key)) return {};\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::WRAP_C, Vector(MakeNodeRef<Key>(NodeType::PK_H, Vector(std::move(key))))));\n+                in = in.subspan(key_size + 1);\n+            } else if (Const(\"pk_k(\", in)) {\n+                Key key;\n+                int key_size = FindNextChar(in, ')');\n+                if (key_size < 1) return {};\n+                if (!ctx.FromString(in.begin(), in.begin() + key_size, key)) return {};\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::PK_K, Vector(std::move(key))));\n+                in = in.subspan(key_size + 1);\n+            } else if (Const(\"pk_h(\", in)) {\n+                Key key;\n+                int key_size = FindNextChar(in, ')');\n+                if (key_size < 1) return {};\n+                if (!ctx.FromString(in.begin(), in.begin() + key_size, key)) return {};\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::PK_H, Vector(std::move(key))));\n+                in = in.subspan(key_size + 1);\n+            } else if (Const(\"sha256(\", in)) {\n+                int hash_size = FindNextChar(in, ')');\n+                if (hash_size < 1) return {};\n+                std::string val = std::string(in.begin(), in.begin() + hash_size);\n+                if (!IsHex(val)) return {};\n+                auto hash = ParseHex(val);\n+                if (hash.size() != 32) return {};\n+                constructed.push_back(MakeNodeRef<Key>(NodeType::SHA256, std::move(hash)));\n+                in = in.subspan(hash_size + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796104879",
      "id" : 796104879,
      "line" : 913,
      "node_id" : "PRRC_kwDOABII584vc5iv",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 766,
      "original_position" : 766,
      "original_start_line" : 759,
      "path" : "src/script/miniscript.h",
      "position" : 766,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796104879/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 906,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796104879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796126519"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796126519"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nSeveral of these sizes are the same, so this could be deduplicated to be a bit easier to read.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T22:46:10Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.\n+        (!(e << \"z\"_mst) || !(e << \"o\"_mst)) && // z conflicts with o\n+        (!(e << \"n\"_mst) || !(e << \"z\"_mst)) && // n conflicts with z\n+        (!(e << \"n\"_mst) || !(e << \"W\"_mst)) && // n conflicts with W\n+        (!(e << \"V\"_mst) || !(e << \"d\"_mst)) && // V conflicts with d\n+        (!(e << \"K\"_mst) ||  (e << \"u\"_mst)) && // K implies u\n+        (!(e << \"V\"_mst) || !(e << \"u\"_mst)) && // V conflicts with u\n+        (!(e << \"e\"_mst) || !(e << \"f\"_mst)) && // e conflicts with f\n+        (!(e << \"e\"_mst) ||  (e << \"d\"_mst)) && // e implies d\n+        (!(e << \"V\"_mst) || !(e << \"e\"_mst)) && // V conflicts with e\n+        (!(e << \"d\"_mst) || !(e << \"f\"_mst)) && // d conflicts with f\n+        (!(e << \"V\"_mst) ||  (e << \"f\"_mst)) && // V implies f\n+        (!(e << \"K\"_mst) ||  (e << \"s\"_mst)) && // K implies s\n+        (!(e << \"z\"_mst) ||  (e << \"m\"_mst)); // z implies m\n+    assert(ok);\n+    return e;\n+}\n+\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys) {\n+    // Sanity check on data\n+    if (nodetype == NodeType::SHA256 || nodetype == NodeType::HASH256) {\n+        assert(data_size == 32);\n+    } else if (nodetype == NodeType::RIPEMD160 || nodetype == NodeType::HASH160) {\n+        assert(data_size == 20);\n+    } else {\n+        assert(data_size == 0);\n+    }\n+    // Sanity check on k\n+    if (nodetype == NodeType::OLDER || nodetype == NodeType::AFTER) {\n+        assert(k >= 1 && k < 0x80000000UL);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(k >= 1 && k <= n_keys);\n+    } else if (nodetype == NodeType::THRESH) {\n+        assert(k >= 1 && k <= n_subs);\n+    } else {\n+        assert(k == 0);\n+    }\n+    // Sanity check on subs\n+    if (nodetype == NodeType::AND_V || nodetype == NodeType::AND_B || nodetype == NodeType::OR_B ||\n+        nodetype == NodeType::OR_C || nodetype == NodeType::OR_I || nodetype == NodeType::OR_D) {\n+        assert(n_subs == 2);\n+    } else if (nodetype == NodeType::ANDOR) {\n+        assert(n_subs == 3);\n+    } else if (nodetype == NodeType::WRAP_A || nodetype == NodeType::WRAP_S || nodetype == NodeType::WRAP_C ||\n+               nodetype == NodeType::WRAP_D || nodetype == NodeType::WRAP_V || nodetype == NodeType::WRAP_J ||\n+               nodetype == NodeType::WRAP_N) {\n+        assert(n_subs == 1);\n+    } else if (nodetype != NodeType::THRESH) {\n+        assert(n_subs == 0);\n+    }\n+    // Sanity check on keys\n+    if (nodetype == NodeType::PK_K || nodetype == NodeType::PK_H) {\n+        assert(n_keys == 1);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(n_keys >= 1 && n_keys <= 20);\n+    } else {\n+        assert(n_keys == 0);\n+    }\n+\n+    // Below is the per-nodetype logic for computing the expression types.\n+    // It heavily relies on Type's << operator (where \"X << a_mst\" means\n+    // \"X has all properties listed in a\").\n+    switch (nodetype) {\n+        case NodeType::PK_K: return \"Konudemsxk\"_mst;\n+        case NodeType::PK_H: return \"Knudemsxk\"_mst;\n+        case NodeType::OLDER: return\n+            \"g\"_mst.If(k & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) |\n+            \"h\"_mst.If(!(k & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG)) |\n+            \"Bzfmxk\"_mst;\n+        case NodeType::AFTER: return\n+            \"i\"_mst.If(k >= LOCKTIME_THRESHOLD) |\n+            \"j\"_mst.If(k < LOCKTIME_THRESHOLD) |\n+            \"Bzfmxk\"_mst;\n+        case NodeType::SHA256: return \"Bonudmk\"_mst;\n+        case NodeType::RIPEMD160: return \"Bonudmk\"_mst;\n+        case NodeType::HASH256: return \"Bonudmk\"_mst;\n+        case NodeType::HASH160: return \"Bonudmk\"_mst;\n+        case NodeType::JUST_1: return \"Bzufmxk\"_mst;\n+        case NodeType::JUST_0: return \"Bzudemsxk\"_mst;\n+        case NodeType::WRAP_A: return\n+            \"W\"_mst.If(x << \"B\"_mst) | // W=B_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"udfems\"_mst) | // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"x\"_mst; // x\n+        case NodeType::WRAP_S: return\n+            \"W\"_mst.If(x << \"Bo\"_mst) | // W=B_x*o_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"udfemsx\"_mst); // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x, x=x_x\n+        case NodeType::WRAP_C: return\n+            \"B\"_mst.If(x << \"K\"_mst) | // B=K_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"ondfem\"_mst) | // o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x\n+            \"us\"_mst; // u, s\n+        case NodeType::WRAP_D: return\n+            \"B\"_mst.If(x << \"Vz\"_mst) | // B=V_x*z_x\n+            \"o\"_mst.If(x << \"z\"_mst) | // o=z_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"ms\"_mst) | // m=m_x, s=s_x\n+            \"nudx\"_mst; // n, u, d, x\n+        case NodeType::WRAP_V: return\n+            \"V\"_mst.If(x << \"B\"_mst) | // V=B_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"zonms\"_mst) | // z=z_x, o=o_x, n=n_x, m=m_x, s=s_x\n+            \"fx\"_mst; // f, x\n+        case NodeType::WRAP_J: return\n+            \"B\"_mst.If(x << \"Bn\"_mst) | // B=B_x*n_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"oums\"_mst) | // o=o_x, u=u_x, m=m_x, s=s_x\n+            \"ndx\"_mst; // n, d, x\n+        case NodeType::WRAP_N: return\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"Bzondfems\"_mst) | // B=B_x, z=z_x, o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"ux\"_mst; // u, x\n+        case NodeType::AND_V: return\n+            (y & \"KVB\"_mst).If(x << \"V\"_mst) | // B=V_x*B_y, V=V_x*V_y, K=V_x*K_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"dmz\"_mst) | // d=d_x*d_y, m=m_x*m_y, z=z_x*z_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"f\"_mst.If((y << \"f\"_mst) || (x << \"s\"_mst)) | // f=f_y+s_x\n+            (y & \"ux\"_mst) | // u=u_y, x=x_y\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            \"k\"_mst.If(((x & y) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*!(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case NodeType::AND_B: return\n+            (x & \"B\"_mst).If(y << \"W\"_mst) | // B=B_x*W_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            (x & y & \"e\"_mst).If((x & y) << \"s\"_mst) | // e=e_x*e_y*s_x*s_y\n+            (x & y & \"dzm\"_mst) | // d=d_x*d_y, z=z_x*z_y, m=m_x*m_y\n+            \"f\"_mst.If(((x & y) << \"f\"_mst) || (x << \"sf\"_mst) || (y << \"sf\"_mst)) | // f=f_x*f_y + f_x*s_x + f_y*s_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"ux\"_mst | // u, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            \"k\"_mst.If(((x & y) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*!(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case NodeType::OR_B: return\n+            \"B\"_mst.If(x << \"Bd\"_mst && y << \"Wd\"_mst) | // B=B_x*d_x*W_x*d_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst && (x & y) << \"e\"_mst) | // m=m_x*m_y*e_x*e_y*(s_x+s_y)\n+            (x & y & \"zse\"_mst) | // z=z_x*z_y, s=s_x*s_y, e=e_x*e_y\n+            \"dux\"_mst | // d, u, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::OR_D: return\n+            (y & \"B\"_mst).If(x << \"Bdu\"_mst) | // B=B_y*B_x*d_x*u_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x+s_y)\n+            (x & y & \"zes\"_mst) | // z=z_x*z_y, e=e_x*e_y, s=s_x*s_y\n+            (y & \"ufd\"_mst) | // u=u_y, f=f_y, d=d_y\n+            \"x\"_mst | // x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::OR_C: return\n+            (y & \"V\"_mst).If(x << \"Bdu\"_mst) | // V=V_y*B_x*u_x*d_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x+s_y)\n+            (x & y & \"zs\"_mst) | // z=z_x*z_y, s=s_x*s_y\n+            \"fx\"_mst | // f, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::OR_I: return\n+            (x & y & \"VBKufs\"_mst) | // V=V_x*V_y, B=B_x*B_y, K=K_x*K_y, u=u_x*u_y, f=f_x*f_y, s=s_x*s_y\n+            \"o\"_mst.If((x & y) << \"z\"_mst) | // o=z_x*z_y\n+            ((x | y) & \"e\"_mst).If((x | y) << \"f\"_mst) | // e=e_x*f_y+f_x*e_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst) | // m=m_x*m_y*(s_x+s_y)\n+            ((x | y) & \"d\"_mst) | // d=d_x+d_y\n+            \"x\"_mst | // x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::ANDOR: return\n+            (y & z & \"BKV\"_mst).If(x << \"Bdu\"_mst) | // B=B_x*d_x*u_x*B_y*B_z, K=B_x*d_x*u_x*K_y*K_z, V=B_x*d_x*u_x*V_y*V_z\n+            (x & y & z & \"z\"_mst) | // z=z_x*z_y*z_z\n+            ((x | (y & z)) & \"o\"_mst).If((x | (y & z)) << \"z\"_mst) | // o=o_x*z_y*z_z+z_x*o_y*o_z\n+            (y & z & \"u\"_mst) | // u=u_y*u_z\n+            (z & \"f\"_mst).If((x << \"s\"_mst) || (y << \"f\"_mst)) | // f=(s_x+f_y)*f_z\n+            (z & \"d\"_mst) | // d=d_z\n+            (x & z & \"e\"_mst).If(x << \"s\"_mst || y << \"f\"_mst) | // e=e_x*e_z*(s_x+f_y)\n+            (x & y & z & \"m\"_mst).If(x << \"e\"_mst && (x | y | z) << \"s\"_mst) | // m=m_x*m_y*m_z*e_x*(s_x+s_y+s_z)\n+            (z & (x | y) & \"s\"_mst) | // s=s_z*(s_x+s_y)\n+            \"x\"_mst | // x\n+            ((x | y | z) & \"ghij\"_mst) | // g=g_x+g_y+g_z, h=h_x+h_y+h_z, i=i_x+i_y+i_z, j=j_x+j_y_j_z\n+            \"k\"_mst.If(((x & y & z) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*k_z* !(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case NodeType::MULTI: return \"Bnudemsk\"_mst;\n+        case NodeType::THRESH: {\n+            bool all_e = true;\n+            bool all_m = true;\n+            uint32_t args = 0;\n+            uint32_t num_s = 0;\n+            Type acc_tl = \"k\"_mst;\n+            for (size_t i = 0; i < sub_types.size(); ++i) {\n+                Type t = sub_types[i];\n+                if (!(t << (i ? \"Wdu\"_mst : \"Bdu\"_mst))) return \"\"_mst; // Require Bdu, Wdu, Wdu, ...\n+                if (!(t << \"e\"_mst)) all_e = false;\n+                if (!(t << \"m\"_mst)) all_m = false;\n+                if (t << \"s\"_mst) num_s += 1;\n+                args += (t << \"z\"_mst) ? 0 : (t << \"o\"_mst) ? 1 : 2;\n+                acc_tl = ((acc_tl | t) & \"ghij\"_mst) |\n+                    // Thresh contains a combination of timelocks if it has threshold > 1 and\n+                    // it contains two different children that have different types of timelocks\n+                    // Note how if any of the children don't have \"k\", the parent also does not have \"k\"\n+                    \"k\"_mst.If(((acc_tl & t) << \"k\"_mst) && ((k <= 1) ||\n+                        ((k > 1) && !(((acc_tl << \"g\"_mst) && (t << \"h\"_mst)) ||\n+                        ((acc_tl << \"h\"_mst) && (t << \"g\"_mst)) ||\n+                        ((acc_tl << \"i\"_mst) && (t << \"j\"_mst)) ||\n+                        ((acc_tl << \"j\"_mst) && (t << \"i\"_mst))))));\n+            }\n+            return \"Bdu\"_mst |\n+                   \"z\"_mst.If(args == 0) | // z=all z\n+                   \"o\"_mst.If(args == 1) | // o=all z except one o\n+                   \"e\"_mst.If(all_e && num_s == n_subs) | // e=all e and all s\n+                   \"m\"_mst.If(all_e && all_m && num_s >= n_subs - k) | // m=all e, >=(n-k) s\n+                   \"s\"_mst.If(num_s >= n_subs - k + 1) |  // s= >=(n-k+1) s\n+                   acc_tl; // timelock info\n+            }\n+    }\n+    assert(false);\n+    return \"\"_mst;\n+}\n+\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys) {\n+    switch (nodetype) {\n+        case NodeType::PK_K: return subsize + 34;\n+        case NodeType::PK_H: return subsize + 3 + 21;\n+        case NodeType::OLDER: return subsize + 1 + (CScript() << k).size();\n+        case NodeType::AFTER: return subsize + 1 + (CScript() << k).size();\n+        case NodeType::HASH256: return subsize + 4 + 2 + 33;\n+        case NodeType::HASH160: return subsize + 4 + 2 + 21;\n+        case NodeType::SHA256: return subsize + 4 + 2 + 33;\n+        case NodeType::RIPEMD160: return subsize + 4 + 2 + 21;\n+        case NodeType::WRAP_A: return subsize + 2;\n+        case NodeType::WRAP_S: return subsize + 1;\n+        case NodeType::WRAP_C: return subsize + 1;\n+        case NodeType::WRAP_D: return subsize + 3;\n+        case NodeType::WRAP_V: return subsize + (sub0typ << \"x\"_mst);\n+        case NodeType::WRAP_J: return subsize + 4;\n+        case NodeType::WRAP_N: return subsize + 1;\n+        case NodeType::JUST_1: return 1;\n+        case NodeType::JUST_0: return 1;\n+        case NodeType::AND_V: return subsize;\n+        case NodeType::AND_B: return subsize + 1;\n+        case NodeType::OR_B: return subsize + 1;\n+        case NodeType::OR_D: return subsize + 3;\n+        case NodeType::OR_C: return subsize + 2;\n+        case NodeType::OR_I: return subsize + 3;\n+        case NodeType::ANDOR: return subsize + 3;\n+        case NodeType::THRESH: return subsize + n_subs + 1;\n+        case NodeType::MULTI: return subsize + 3 + (n_keys > 16) + (k > 16) + 34 * n_keys;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796126519",
      "id" : 796126519,
      "line" : 279,
      "node_id" : "PRRC_kwDOABII584vc-03",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 278,
      "original_position" : 278,
      "original_start_line" : 253,
      "path" : "src/script/miniscript.cpp",
      "position" : 278,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796126519/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 254,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796126519",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796128056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796128056"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\nThis appears to be unused.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T22:49:07Z",
      "diff_hunk" : "@@ -0,0 +1,407 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <string>\n+\n+#include <test/util/setup_common.h>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <uint256.h>\n+#include <crypto/ripemd160.h>\n+#include <crypto/sha256.h>\n+#include <script/miniscript.h>\n+\n+namespace {\n+\n+/** TestData groups various kinds of precomputed data necessary in this test. */\n+struct TestData {\n+    //! The only public keys used in this test.\n+    std::vector<CPubKey> pubkeys;\n+    //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n+    std::map<CPubKey, CKeyID> pkhashes;\n+\n+    // Various precomputed hashes\n+    std::vector<std::vector<unsigned char>> sha256;\n+    std::vector<std::vector<unsigned char>> ripemd160;\n+    std::vector<std::vector<unsigned char>> hash256;\n+    std::vector<std::vector<unsigned char>> hash160;\n+\n+    TestData()\n+    {\n+        // We generate 255 public keys and 255 hashes of each type.\n+        for (int i = 1; i <= 255; ++i) {\n+            // This 32-byte array functions as both private key data and hash preimage (31 zero bytes plus any nonzero byte).\n+            unsigned char keydata[32] = {0};\n+            keydata[31] = i;\n+\n+            // Compute CPubkey and CKeyID\n+            CKey key;\n+            key.Set(keydata, keydata + 32, true);\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID keyid = pubkey.GetID();\n+            pubkeys.push_back(pubkey);\n+            pkhashes.emplace(pubkey, keyid);\n+\n+            // Compute various hashes\n+            std::vector<unsigned char> hash;\n+            hash.resize(32);\n+            CSHA256().Write(keydata, 32).Finalize(hash.data());\n+            sha256.push_back(hash);\n+            CHash256().Write(keydata).Finalize(hash);\n+            hash256.push_back(hash);\n+            hash.resize(20);\n+            CRIPEMD160().Write(keydata, 32).Finalize(hash.data());\n+            ripemd160.push_back(hash);\n+            CHash160().Write(keydata).Finalize(hash);\n+            hash160.push_back(hash);\n+        }\n+    }\n+};\n+\n+//! Global TestData object\n+std::unique_ptr<const TestData> g_testdata;\n+\n+/** A class encapsulating conversion routing for CPubKey. */\n+struct KeyConverter {\n+    typedef CPubKey Key;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796128056",
      "id" : 796128056,
      "line" : 72,
      "node_id" : "PRRC_kwDOABII584vc_M4",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/test/miniscript_tests.cpp",
      "position" : 70,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796128056/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796128056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796133172"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796133172"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c \"Miniscript: type system, script creation, text notation, tests\"\r\n\r\n`<<` confused me for a while as I am used to it meaning bit shift when used in a flags like context, rather than a containment operator.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-01-31T22:59:02Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796133172",
      "id" : 796133172,
      "line" : 137,
      "node_id" : "PRRC_kwDOABII584vdAc0",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 136,
      "original_position" : 136,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 136,
      "pull_request_review_id" : 868437207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796133172/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-31T22:59:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796133172",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796339816"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796339816"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If you touch this perhaps worth changing to `* - \"j\" Whether the branch contains a absolute height timelock`",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-01T08:06:54Z",
      "diff_hunk" : "@@ -0,0 +1,1561 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796339816",
      "id" : 796339816,
      "line" : 110,
      "node_id" : "PRRC_kwDOABII584vdy5o",
      "original_commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "original_line" : 110,
      "original_position" : 110,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 110,
      "pull_request_review_id" : 868779669,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796339816/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-01T08:10:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796339816",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796356564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796356564"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, but it is going to go along with https://github.com/bitcoin/bitcoin/pull/24147#discussion_r795211395 in favour of a `BuildScript(OP, sub, sub, OP, OP, sub, ...)`.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-01T08:24:11Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796356564",
      "id" : 796356564,
      "in_reply_to_id" : 796086703,
      "line" : 464,
      "node_id" : "PRRC_kwDOABII584vd2_U",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 417,
      "original_position" : 417,
      "original_start_line" : 394,
      "path" : "src/script/miniscript.h",
      "position" : 417,
      "pull_request_review_id" : 868794841,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796356564/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 441,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-01T08:24:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796356564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796365609"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796365609"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note the duplicated case between the two switches. Some nodes' text representation can be abbreviated using a wrapper, and you want to try that first.\r\nBesides that, i guess it's a matter of style between trying all wrappers first and merging them between the respective node types that are currently duplicated.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-01T08:36:20Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::MULTI: {\n+                    CScript script = CScript() << node.k;\n+                    for (const auto& key : node.keys) {\n+                        script << ctx.ToPKBytes(key);\n+                    }\n+                    return std::move(script) << node.keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+                }\n+                case NodeType::THRESH: {\n+                    CScript script = std::move(subs[0]);\n+                    for (size_t i = 1; i < subs.size(); ++i) {\n+                        script = (std::move(script) + std::move(subs[i])) << OP_ADD;\n+                    }\n+                    return std::move(script) << node.k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                }\n+            }\n+            assert(false);\n+            return {};\n+        };\n+        return TreeEval<CScript>(false, downfn, upfn);\n+    }\n+\n+    template<typename CTx>\n+    bool ToString(const CTx& ctx, std::string& ret) const {\n+        // To construct the std::string representation for a Miniscript object, we use\n+        // the TreeEvalMaybe algorithm. The State is a boolean: whether the parent node is a\n+        // wrapper. If so, non-wrapper expressions must be prefixed with a \":\".\n+        auto downfn = [](bool, const Node& node, size_t) {\n+            return (node.nodetype == NodeType::WRAP_A || node.nodetype == NodeType::WRAP_S ||\n+                    node.nodetype == NodeType::WRAP_D || node.nodetype == NodeType::WRAP_V ||\n+                    node.nodetype == NodeType::WRAP_J || node.nodetype == NodeType::WRAP_N ||\n+                    node.nodetype == NodeType::WRAP_C ||\n+                    (node.nodetype == NodeType::AND_V && node.subs[1]->nodetype == NodeType::JUST_1) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[0]->nodetype == NodeType::JUST_0) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[1]->nodetype == NodeType::JUST_0));\n+        };\n+        // The upward function computes for a node, given whether its parent is a wrapper,\n+        // and the string representations of its child nodes, the string representation of the node.\n+        auto upfn = [&ctx](bool wrapped, const Node& node, Span<std::string> subs) -> std::optional<std::string> {\n+            std::string ret = wrapped ? \":\" : \"\";\n+\n+            switch (node.nodetype) {\n+                case NodeType::WRAP_A: return \"a\" + std::move(subs[0]);\n+                case NodeType::WRAP_S: return \"s\" + std::move(subs[0]);\n+                case NodeType::WRAP_C:\n+                    if (node.subs[0]->nodetype == NodeType::PK_K) {\n+                        // pk(K) is syntactic sugar for c:pk_k(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+                    }\n+                    if (node.subs[0]->nodetype == NodeType::PK_H) {\n+                        // pkh(K) is syntactic sugar for c:pk_h(K)\n+                        std::string key_str;\n+                        if (!ctx.ToString(node.subs[0]->keys[0], key_str)) return {};\n+                        return std::move(ret) + \"pkh(\" + std::move(key_str) + \")\";\n+                    }\n+                    return \"c\" + std::move(subs[0]);\n+                case NodeType::WRAP_D: return \"d\" + std::move(subs[0]);\n+                case NodeType::WRAP_V: return \"v\" + std::move(subs[0]);\n+                case NodeType::WRAP_J: return \"j\" + std::move(subs[0]);\n+                case NodeType::WRAP_N: return \"n\" + std::move(subs[0]);\n+                case NodeType::AND_V:\n+                    // t:X is syntactic sugar for and_v(X,1).\n+                    if (node.subs[1]->nodetype == NodeType::JUST_1) return \"t\" + std::move(subs[0]);\n+                    break;\n+                case NodeType::OR_I:\n+                    if (node.subs[0]->nodetype == NodeType::JUST_0) return \"l\" + std::move(subs[1]);\n+                    if (node.subs[1]->nodetype == NodeType::JUST_0) return \"u\" + std::move(subs[0]);\n+                    break;\n+                default: break;\n+            }\n+            switch (node.nodetype) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796365609",
      "id" : 796365609,
      "in_reply_to_id" : 796096601,
      "line" : 536,
      "node_id" : "PRRC_kwDOABII584vd5Mp",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 489,
      "original_position" : 489,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 489,
      "pull_request_review_id" : 868806515,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796365609/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-01T08:36:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796365609",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796367102"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796367102"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It is? See the `CONVERTER` global.\r\n\r\nEDIT: ok i missed you were talking about the `Key` type. The Miniscript context expects it to be defined.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-01T08:38:35Z",
      "diff_hunk" : "@@ -0,0 +1,407 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <string>\n+\n+#include <test/util/setup_common.h>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <uint256.h>\n+#include <crypto/ripemd160.h>\n+#include <crypto/sha256.h>\n+#include <script/miniscript.h>\n+\n+namespace {\n+\n+/** TestData groups various kinds of precomputed data necessary in this test. */\n+struct TestData {\n+    //! The only public keys used in this test.\n+    std::vector<CPubKey> pubkeys;\n+    //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n+    std::map<CPubKey, CKeyID> pkhashes;\n+\n+    // Various precomputed hashes\n+    std::vector<std::vector<unsigned char>> sha256;\n+    std::vector<std::vector<unsigned char>> ripemd160;\n+    std::vector<std::vector<unsigned char>> hash256;\n+    std::vector<std::vector<unsigned char>> hash160;\n+\n+    TestData()\n+    {\n+        // We generate 255 public keys and 255 hashes of each type.\n+        for (int i = 1; i <= 255; ++i) {\n+            // This 32-byte array functions as both private key data and hash preimage (31 zero bytes plus any nonzero byte).\n+            unsigned char keydata[32] = {0};\n+            keydata[31] = i;\n+\n+            // Compute CPubkey and CKeyID\n+            CKey key;\n+            key.Set(keydata, keydata + 32, true);\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID keyid = pubkey.GetID();\n+            pubkeys.push_back(pubkey);\n+            pkhashes.emplace(pubkey, keyid);\n+\n+            // Compute various hashes\n+            std::vector<unsigned char> hash;\n+            hash.resize(32);\n+            CSHA256().Write(keydata, 32).Finalize(hash.data());\n+            sha256.push_back(hash);\n+            CHash256().Write(keydata).Finalize(hash);\n+            hash256.push_back(hash);\n+            hash.resize(20);\n+            CRIPEMD160().Write(keydata, 32).Finalize(hash.data());\n+            ripemd160.push_back(hash);\n+            CHash160().Write(keydata).Finalize(hash);\n+            hash160.push_back(hash);\n+        }\n+    }\n+};\n+\n+//! Global TestData object\n+std::unique_ptr<const TestData> g_testdata;\n+\n+/** A class encapsulating conversion routing for CPubKey. */\n+struct KeyConverter {\n+    typedef CPubKey Key;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796367102",
      "id" : 796367102,
      "in_reply_to_id" : 796128056,
      "line" : 72,
      "node_id" : "PRRC_kwDOABII584vd5j-",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/test/miniscript_tests.cpp",
      "position" : 70,
      "pull_request_review_id" : 868808586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796367102/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-01T16:44:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796367102",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796569889"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796569889"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "mini-nit: It should be \"a**n** absolute [...]\" in both lines",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-01T12:58:00Z",
      "diff_hunk" : "@@ -0,0 +1,1561 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796569889",
      "id" : 796569889,
      "in_reply_to_id" : 796339816,
      "line" : 110,
      "node_id" : "PRRC_kwDOABII584verEh",
      "original_commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "original_line" : 110,
      "original_position" : 110,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 110,
      "pull_request_review_id" : 869091419,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796569889/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-01T12:58:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796569889",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/425166?v=4",
         "events_url" : "https://api.github.com/users/flack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/flack/followers",
         "following_url" : "https://api.github.com/users/flack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/flack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/flack",
         "id" : 425166,
         "login" : "flack",
         "node_id" : "MDQ6VXNlcjQyNTE2Ng==",
         "organizations_url" : "https://api.github.com/users/flack/orgs",
         "received_events_url" : "https://api.github.com/users/flack/received_events",
         "repos_url" : "https://api.github.com/users/flack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/flack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/flack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/flack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796747054"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796747054"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, I grepped for `Key` and did not see it, but removing this does indeed cause a compilation failure.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-01T16:00:54Z",
      "diff_hunk" : "@@ -0,0 +1,407 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <string>\n+\n+#include <test/util/setup_common.h>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <uint256.h>\n+#include <crypto/ripemd160.h>\n+#include <crypto/sha256.h>\n+#include <script/miniscript.h>\n+\n+namespace {\n+\n+/** TestData groups various kinds of precomputed data necessary in this test. */\n+struct TestData {\n+    //! The only public keys used in this test.\n+    std::vector<CPubKey> pubkeys;\n+    //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n+    std::map<CPubKey, CKeyID> pkhashes;\n+\n+    // Various precomputed hashes\n+    std::vector<std::vector<unsigned char>> sha256;\n+    std::vector<std::vector<unsigned char>> ripemd160;\n+    std::vector<std::vector<unsigned char>> hash256;\n+    std::vector<std::vector<unsigned char>> hash160;\n+\n+    TestData()\n+    {\n+        // We generate 255 public keys and 255 hashes of each type.\n+        for (int i = 1; i <= 255; ++i) {\n+            // This 32-byte array functions as both private key data and hash preimage (31 zero bytes plus any nonzero byte).\n+            unsigned char keydata[32] = {0};\n+            keydata[31] = i;\n+\n+            // Compute CPubkey and CKeyID\n+            CKey key;\n+            key.Set(keydata, keydata + 32, true);\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID keyid = pubkey.GetID();\n+            pubkeys.push_back(pubkey);\n+            pkhashes.emplace(pubkey, keyid);\n+\n+            // Compute various hashes\n+            std::vector<unsigned char> hash;\n+            hash.resize(32);\n+            CSHA256().Write(keydata, 32).Finalize(hash.data());\n+            sha256.push_back(hash);\n+            CHash256().Write(keydata).Finalize(hash);\n+            hash256.push_back(hash);\n+            hash.resize(20);\n+            CRIPEMD160().Write(keydata, 32).Finalize(hash.data());\n+            ripemd160.push_back(hash);\n+            CHash160().Write(keydata).Finalize(hash);\n+            hash160.push_back(hash);\n+        }\n+    }\n+};\n+\n+//! Global TestData object\n+std::unique_ptr<const TestData> g_testdata;\n+\n+/** A class encapsulating conversion routing for CPubKey. */\n+struct KeyConverter {\n+    typedef CPubKey Key;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r796747054",
      "id" : 796747054,
      "in_reply_to_id" : 796128056,
      "line" : 72,
      "node_id" : "PRRC_kwDOABII584vfWUu",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/test/miniscript_tests.cpp",
      "position" : 70,
      "pull_request_review_id" : 869345551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796747054/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-01T16:00:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/796747054",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798043674"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798043674"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c:\r\nThese are not exhaustive ways to compute a `V` type. This can be computed by `or_c`, `and_v` too. \r\n\r\nnit: Perhaps replace  \r\n```diff\r\n+ This is obtained\r\n- This can be obtained\r\n```",
      "commit_id" : "cdd630e478047f17a43e5fb0e4a71f838fdc8c32",
      "created_at" : "2022-02-02T21:53:34Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798043674",
      "id" : 798043674,
      "line" : 47,
      "node_id" : "PRRC_kwDOABII584vkS4a",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 47,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 47,
      "pull_request_review_id" : 871149762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798043674/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-01T09:14:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798043674",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798049605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798049605"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Perhaps this was written before the miniscript spec was updated. The comments here can be updated to reflect the website that has an updated explanation. ",
      "commit_id" : "cdd630e478047f17a43e5fb0e4a71f838fdc8c32",
      "created_at" : "2022-02-02T22:02:15Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798049605",
      "id" : 798049605,
      "in_reply_to_id" : 798043674,
      "line" : 47,
      "node_id" : "PRRC_kwDOABII584vkUVF",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 47,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 47,
      "pull_request_review_id" : 871149762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798049605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-01T09:14:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798049605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798069391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798069391"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Note to reviewers: that the website no longer explicitly lists `m` as a type property. It is implicitly captured in the \"Guaranteeing non-malleability\" table. ",
      "commit_id" : "cdd630e478047f17a43e5fb0e4a71f838fdc8c32",
      "created_at" : "2022-02-02T22:33:42Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798069391",
      "id" : 798069391,
      "line" : 92,
      "node_id" : "PRRC_kwDOABII584vkZKP",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 92,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 92,
      "pull_request_review_id" : 871149762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798069391/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-01T09:14:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798069391",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798076142"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798076142"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit (Feel free to ignore, this may be some work for no benefit):\r\nHere and all other places,\r\n I think it might be useful to have the same ordering of fragments here as listed on the website for ease for review.",
      "commit_id" : "cdd630e478047f17a43e5fb0e4a71f838fdc8c32",
      "created_at" : "2022-02-02T22:45:40Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.\n+        (!(e << \"z\"_mst) || !(e << \"o\"_mst)) && // z conflicts with o\n+        (!(e << \"n\"_mst) || !(e << \"z\"_mst)) && // n conflicts with z\n+        (!(e << \"n\"_mst) || !(e << \"W\"_mst)) && // n conflicts with W\n+        (!(e << \"V\"_mst) || !(e << \"d\"_mst)) && // V conflicts with d\n+        (!(e << \"K\"_mst) ||  (e << \"u\"_mst)) && // K implies u\n+        (!(e << \"V\"_mst) || !(e << \"u\"_mst)) && // V conflicts with u\n+        (!(e << \"e\"_mst) || !(e << \"f\"_mst)) && // e conflicts with f\n+        (!(e << \"e\"_mst) ||  (e << \"d\"_mst)) && // e implies d\n+        (!(e << \"V\"_mst) || !(e << \"e\"_mst)) && // V conflicts with e\n+        (!(e << \"d\"_mst) || !(e << \"f\"_mst)) && // d conflicts with f\n+        (!(e << \"V\"_mst) ||  (e << \"f\"_mst)) && // V implies f\n+        (!(e << \"K\"_mst) ||  (e << \"s\"_mst)) && // K implies s\n+        (!(e << \"z\"_mst) ||  (e << \"m\"_mst)); // z implies m\n+    assert(ok);\n+    return e;\n+}\n+\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys) {\n+    // Sanity check on data\n+    if (nodetype == NodeType::SHA256 || nodetype == NodeType::HASH256) {\n+        assert(data_size == 32);\n+    } else if (nodetype == NodeType::RIPEMD160 || nodetype == NodeType::HASH160) {\n+        assert(data_size == 20);\n+    } else {\n+        assert(data_size == 0);\n+    }\n+    // Sanity check on k\n+    if (nodetype == NodeType::OLDER || nodetype == NodeType::AFTER) {\n+        assert(k >= 1 && k < 0x80000000UL);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(k >= 1 && k <= n_keys);\n+    } else if (nodetype == NodeType::THRESH) {\n+        assert(k >= 1 && k <= n_subs);\n+    } else {\n+        assert(k == 0);\n+    }\n+    // Sanity check on subs\n+    if (nodetype == NodeType::AND_V || nodetype == NodeType::AND_B || nodetype == NodeType::OR_B ||\n+        nodetype == NodeType::OR_C || nodetype == NodeType::OR_I || nodetype == NodeType::OR_D) {\n+        assert(n_subs == 2);\n+    } else if (nodetype == NodeType::ANDOR) {\n+        assert(n_subs == 3);\n+    } else if (nodetype == NodeType::WRAP_A || nodetype == NodeType::WRAP_S || nodetype == NodeType::WRAP_C ||\n+               nodetype == NodeType::WRAP_D || nodetype == NodeType::WRAP_V || nodetype == NodeType::WRAP_J ||\n+               nodetype == NodeType::WRAP_N) {\n+        assert(n_subs == 1);\n+    } else if (nodetype != NodeType::THRESH) {\n+        assert(n_subs == 0);\n+    }\n+    // Sanity check on keys\n+    if (nodetype == NodeType::PK_K || nodetype == NodeType::PK_H) {\n+        assert(n_keys == 1);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(n_keys >= 1 && n_keys <= 20);\n+    } else {\n+        assert(n_keys == 0);\n+    }\n+\n+    // Below is the per-nodetype logic for computing the expression types.\n+    // It heavily relies on Type's << operator (where \"X << a_mst\" means\n+    // \"X has all properties listed in a\").\n+    switch (nodetype) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r798076142",
      "id" : 798076142,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII584vkazu",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 82,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/script/miniscript.cpp",
      "position" : 82,
      "pull_request_review_id" : 871149762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798076142/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-01T09:14:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/798076142",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rather than somehow rebuilding from scratch, I tried the opposite approach...\r\n\r\nI peeled back the fragments in 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c like an onion, deleting a bunch of related fragments and committing that. The order is somewhat random, but I started with the ones that are not needed for descriptors. I then reverted all these commits, and squashed the original ones. The end result is a series of commits that builds all of Miniscript piecemeal: https://github.com/Sjors/bitcoin/commits/2022/02/miniscript\r\n\r\nIf you want to use it, you should be able to rebase the rest of this PR on top of it.\r\n\r\nThe types and properties are now introduced in the commit for the first fragment that needs them. Because I peeled back in somewhat random order, this may not be the most optimal way to introduce them. But at least they're not all introduced at once. That said, the bulk of properties is still introduced in the first commit, because c:pk_h() uses the kitchensink.\r\n\r\nOnly commits df93206ff5cea371594da2d7f140325c1573f8ef, 547a8d6e7de1cf1afb472564d68da2683e9aa8e7 and e1984c4a5d433531e5d66df832514b642af43997 are needed for our current descriptor capability.\r\n\r\nThe other commits implement the rest of miniscript could be moved to another PR. They can be reviewed in parallel with your followup PR's that integrate miniscript with descriptors.\r\n\r\nI put `older()` and `after()` immediately after that in 6f87083fd6b01f3f7a5228a05702c0177dfe1c75, since time/height locks are probably the most useful wallet feature to introduce next (and the wallet RPC already has some timelock related functionality). That said,  it's probably fine to introduce all the new miniscript functionality in one go.\r\n\r\nWhile peeling back fragments I was pretty reckless with the tests: I just deleted any test that contained the fragment. This leads to low coverage for the initial commits, which can probably be improved with some new tests.\r\n\r\n_Update 2022-02-06:_ I simplified the first commit even further by delaying the introduction of all properties. None of them are needed until after/older and the and/or fragments. The makes the first commit far easier to understand imo.",
      "created_at" : "2022-02-03T18:28:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1029278730",
      "id" : 1029278730,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849WYwK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029278730/reactions"
      },
      "updated_at" : "2022-02-06T19:07:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029278730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r800069165"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/800069165"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm renaming `NodeType` to `Fragment`.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-05T15:37:12Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r800069165",
      "id" : 800069165,
      "in_reply_to_id" : 796098118,
      "line" : 183,
      "node_id" : "PRRC_kwDOABII584vsBYt",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 182,
      "original_position" : 182,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 182,
      "pull_request_review_id" : 873942869,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/800069165/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-05T15:37:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/800069165",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r800070869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/800070869"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also removing the `subsize` where it was not necessary (it must always be 0 for \"leaf\" fragments). I think it's much less confusing now.",
      "commit_id" : "2b9f9f91218deb54adf107cdad40f081330fe68a",
      "created_at" : "2022-02-05T15:54:26Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.\n+        (!(e << \"z\"_mst) || !(e << \"o\"_mst)) && // z conflicts with o\n+        (!(e << \"n\"_mst) || !(e << \"z\"_mst)) && // n conflicts with z\n+        (!(e << \"n\"_mst) || !(e << \"W\"_mst)) && // n conflicts with W\n+        (!(e << \"V\"_mst) || !(e << \"d\"_mst)) && // V conflicts with d\n+        (!(e << \"K\"_mst) ||  (e << \"u\"_mst)) && // K implies u\n+        (!(e << \"V\"_mst) || !(e << \"u\"_mst)) && // V conflicts with u\n+        (!(e << \"e\"_mst) || !(e << \"f\"_mst)) && // e conflicts with f\n+        (!(e << \"e\"_mst) ||  (e << \"d\"_mst)) && // e implies d\n+        (!(e << \"V\"_mst) || !(e << \"e\"_mst)) && // V conflicts with e\n+        (!(e << \"d\"_mst) || !(e << \"f\"_mst)) && // d conflicts with f\n+        (!(e << \"V\"_mst) ||  (e << \"f\"_mst)) && // V implies f\n+        (!(e << \"K\"_mst) ||  (e << \"s\"_mst)) && // K implies s\n+        (!(e << \"z\"_mst) ||  (e << \"m\"_mst)); // z implies m\n+    assert(ok);\n+    return e;\n+}\n+\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys) {\n+    // Sanity check on data\n+    if (nodetype == NodeType::SHA256 || nodetype == NodeType::HASH256) {\n+        assert(data_size == 32);\n+    } else if (nodetype == NodeType::RIPEMD160 || nodetype == NodeType::HASH160) {\n+        assert(data_size == 20);\n+    } else {\n+        assert(data_size == 0);\n+    }\n+    // Sanity check on k\n+    if (nodetype == NodeType::OLDER || nodetype == NodeType::AFTER) {\n+        assert(k >= 1 && k < 0x80000000UL);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(k >= 1 && k <= n_keys);\n+    } else if (nodetype == NodeType::THRESH) {\n+        assert(k >= 1 && k <= n_subs);\n+    } else {\n+        assert(k == 0);\n+    }\n+    // Sanity check on subs\n+    if (nodetype == NodeType::AND_V || nodetype == NodeType::AND_B || nodetype == NodeType::OR_B ||\n+        nodetype == NodeType::OR_C || nodetype == NodeType::OR_I || nodetype == NodeType::OR_D) {\n+        assert(n_subs == 2);\n+    } else if (nodetype == NodeType::ANDOR) {\n+        assert(n_subs == 3);\n+    } else if (nodetype == NodeType::WRAP_A || nodetype == NodeType::WRAP_S || nodetype == NodeType::WRAP_C ||\n+               nodetype == NodeType::WRAP_D || nodetype == NodeType::WRAP_V || nodetype == NodeType::WRAP_J ||\n+               nodetype == NodeType::WRAP_N) {\n+        assert(n_subs == 1);\n+    } else if (nodetype != NodeType::THRESH) {\n+        assert(n_subs == 0);\n+    }\n+    // Sanity check on keys\n+    if (nodetype == NodeType::PK_K || nodetype == NodeType::PK_H) {\n+        assert(n_keys == 1);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(n_keys >= 1 && n_keys <= 20);\n+    } else {\n+        assert(n_keys == 0);\n+    }\n+\n+    // Below is the per-nodetype logic for computing the expression types.\n+    // It heavily relies on Type's << operator (where \"X << a_mst\" means\n+    // \"X has all properties listed in a\").\n+    switch (nodetype) {\n+        case NodeType::PK_K: return \"Konudemsxk\"_mst;\n+        case NodeType::PK_H: return \"Knudemsxk\"_mst;\n+        case NodeType::OLDER: return\n+            \"g\"_mst.If(k & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) |\n+            \"h\"_mst.If(!(k & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG)) |\n+            \"Bzfmxk\"_mst;\n+        case NodeType::AFTER: return\n+            \"i\"_mst.If(k >= LOCKTIME_THRESHOLD) |\n+            \"j\"_mst.If(k < LOCKTIME_THRESHOLD) |\n+            \"Bzfmxk\"_mst;\n+        case NodeType::SHA256: return \"Bonudmk\"_mst;\n+        case NodeType::RIPEMD160: return \"Bonudmk\"_mst;\n+        case NodeType::HASH256: return \"Bonudmk\"_mst;\n+        case NodeType::HASH160: return \"Bonudmk\"_mst;\n+        case NodeType::JUST_1: return \"Bzufmxk\"_mst;\n+        case NodeType::JUST_0: return \"Bzudemsxk\"_mst;\n+        case NodeType::WRAP_A: return\n+            \"W\"_mst.If(x << \"B\"_mst) | // W=B_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"udfems\"_mst) | // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"x\"_mst; // x\n+        case NodeType::WRAP_S: return\n+            \"W\"_mst.If(x << \"Bo\"_mst) | // W=B_x*o_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"udfemsx\"_mst); // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x, x=x_x\n+        case NodeType::WRAP_C: return\n+            \"B\"_mst.If(x << \"K\"_mst) | // B=K_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"ondfem\"_mst) | // o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x\n+            \"us\"_mst; // u, s\n+        case NodeType::WRAP_D: return\n+            \"B\"_mst.If(x << \"Vz\"_mst) | // B=V_x*z_x\n+            \"o\"_mst.If(x << \"z\"_mst) | // o=z_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"ms\"_mst) | // m=m_x, s=s_x\n+            \"nudx\"_mst; // n, u, d, x\n+        case NodeType::WRAP_V: return\n+            \"V\"_mst.If(x << \"B\"_mst) | // V=B_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"zonms\"_mst) | // z=z_x, o=o_x, n=n_x, m=m_x, s=s_x\n+            \"fx\"_mst; // f, x\n+        case NodeType::WRAP_J: return\n+            \"B\"_mst.If(x << \"Bn\"_mst) | // B=B_x*n_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"oums\"_mst) | // o=o_x, u=u_x, m=m_x, s=s_x\n+            \"ndx\"_mst; // n, d, x\n+        case NodeType::WRAP_N: return\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"Bzondfems\"_mst) | // B=B_x, z=z_x, o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"ux\"_mst; // u, x\n+        case NodeType::AND_V: return\n+            (y & \"KVB\"_mst).If(x << \"V\"_mst) | // B=V_x*B_y, V=V_x*V_y, K=V_x*K_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"dmz\"_mst) | // d=d_x*d_y, m=m_x*m_y, z=z_x*z_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"f\"_mst.If((y << \"f\"_mst) || (x << \"s\"_mst)) | // f=f_y+s_x\n+            (y & \"ux\"_mst) | // u=u_y, x=x_y\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            \"k\"_mst.If(((x & y) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*!(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case NodeType::AND_B: return\n+            (x & \"B\"_mst).If(y << \"W\"_mst) | // B=B_x*W_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            (x & y & \"e\"_mst).If((x & y) << \"s\"_mst) | // e=e_x*e_y*s_x*s_y\n+            (x & y & \"dzm\"_mst) | // d=d_x*d_y, z=z_x*z_y, m=m_x*m_y\n+            \"f\"_mst.If(((x & y) << \"f\"_mst) || (x << \"sf\"_mst) || (y << \"sf\"_mst)) | // f=f_x*f_y + f_x*s_x + f_y*s_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"ux\"_mst | // u, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            \"k\"_mst.If(((x & y) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*!(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case NodeType::OR_B: return\n+            \"B\"_mst.If(x << \"Bd\"_mst && y << \"Wd\"_mst) | // B=B_x*d_x*W_x*d_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst && (x & y) << \"e\"_mst) | // m=m_x*m_y*e_x*e_y*(s_x+s_y)\n+            (x & y & \"zse\"_mst) | // z=z_x*z_y, s=s_x*s_y, e=e_x*e_y\n+            \"dux\"_mst | // d, u, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::OR_D: return\n+            (y & \"B\"_mst).If(x << \"Bdu\"_mst) | // B=B_y*B_x*d_x*u_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x+s_y)\n+            (x & y & \"zes\"_mst) | // z=z_x*z_y, e=e_x*e_y, s=s_x*s_y\n+            (y & \"ufd\"_mst) | // u=u_y, f=f_y, d=d_y\n+            \"x\"_mst | // x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::OR_C: return\n+            (y & \"V\"_mst).If(x << \"Bdu\"_mst) | // V=V_y*B_x*u_x*d_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x+s_y)\n+            (x & y & \"zs\"_mst) | // z=z_x*z_y, s=s_x*s_y\n+            \"fx\"_mst | // f, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::OR_I: return\n+            (x & y & \"VBKufs\"_mst) | // V=V_x*V_y, B=B_x*B_y, K=K_x*K_y, u=u_x*u_y, f=f_x*f_y, s=s_x*s_y\n+            \"o\"_mst.If((x & y) << \"z\"_mst) | // o=z_x*z_y\n+            ((x | y) & \"e\"_mst).If((x | y) << \"f\"_mst) | // e=e_x*f_y+f_x*e_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst) | // m=m_x*m_y*(s_x+s_y)\n+            ((x | y) & \"d\"_mst) | // d=d_x+d_y\n+            \"x\"_mst | // x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case NodeType::ANDOR: return\n+            (y & z & \"BKV\"_mst).If(x << \"Bdu\"_mst) | // B=B_x*d_x*u_x*B_y*B_z, K=B_x*d_x*u_x*K_y*K_z, V=B_x*d_x*u_x*V_y*V_z\n+            (x & y & z & \"z\"_mst) | // z=z_x*z_y*z_z\n+            ((x | (y & z)) & \"o\"_mst).If((x | (y & z)) << \"z\"_mst) | // o=o_x*z_y*z_z+z_x*o_y*o_z\n+            (y & z & \"u\"_mst) | // u=u_y*u_z\n+            (z & \"f\"_mst).If((x << \"s\"_mst) || (y << \"f\"_mst)) | // f=(s_x+f_y)*f_z\n+            (z & \"d\"_mst) | // d=d_z\n+            (x & z & \"e\"_mst).If(x << \"s\"_mst || y << \"f\"_mst) | // e=e_x*e_z*(s_x+f_y)\n+            (x & y & z & \"m\"_mst).If(x << \"e\"_mst && (x | y | z) << \"s\"_mst) | // m=m_x*m_y*m_z*e_x*(s_x+s_y+s_z)\n+            (z & (x | y) & \"s\"_mst) | // s=s_z*(s_x+s_y)\n+            \"x\"_mst | // x\n+            ((x | y | z) & \"ghij\"_mst) | // g=g_x+g_y+g_z, h=h_x+h_y+h_z, i=i_x+i_y+i_z, j=j_x+j_y_j_z\n+            \"k\"_mst.If(((x & y & z) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*k_z* !(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case NodeType::MULTI: return \"Bnudemsk\"_mst;\n+        case NodeType::THRESH: {\n+            bool all_e = true;\n+            bool all_m = true;\n+            uint32_t args = 0;\n+            uint32_t num_s = 0;\n+            Type acc_tl = \"k\"_mst;\n+            for (size_t i = 0; i < sub_types.size(); ++i) {\n+                Type t = sub_types[i];\n+                if (!(t << (i ? \"Wdu\"_mst : \"Bdu\"_mst))) return \"\"_mst; // Require Bdu, Wdu, Wdu, ...\n+                if (!(t << \"e\"_mst)) all_e = false;\n+                if (!(t << \"m\"_mst)) all_m = false;\n+                if (t << \"s\"_mst) num_s += 1;\n+                args += (t << \"z\"_mst) ? 0 : (t << \"o\"_mst) ? 1 : 2;\n+                acc_tl = ((acc_tl | t) & \"ghij\"_mst) |\n+                    // Thresh contains a combination of timelocks if it has threshold > 1 and\n+                    // it contains two different children that have different types of timelocks\n+                    // Note how if any of the children don't have \"k\", the parent also does not have \"k\"\n+                    \"k\"_mst.If(((acc_tl & t) << \"k\"_mst) && ((k <= 1) ||\n+                        ((k > 1) && !(((acc_tl << \"g\"_mst) && (t << \"h\"_mst)) ||\n+                        ((acc_tl << \"h\"_mst) && (t << \"g\"_mst)) ||\n+                        ((acc_tl << \"i\"_mst) && (t << \"j\"_mst)) ||\n+                        ((acc_tl << \"j\"_mst) && (t << \"i\"_mst))))));\n+            }\n+            return \"Bdu\"_mst |\n+                   \"z\"_mst.If(args == 0) | // z=all z\n+                   \"o\"_mst.If(args == 1) | // o=all z except one o\n+                   \"e\"_mst.If(all_e && num_s == n_subs) | // e=all e and all s\n+                   \"m\"_mst.If(all_e && all_m && num_s >= n_subs - k) | // m=all e, >=(n-k) s\n+                   \"s\"_mst.If(num_s >= n_subs - k + 1) |  // s= >=(n-k+1) s\n+                   acc_tl; // timelock info\n+            }\n+    }\n+    assert(false);\n+    return \"\"_mst;\n+}\n+\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys) {\n+    switch (nodetype) {\n+        case NodeType::PK_K: return subsize + 34;\n+        case NodeType::PK_H: return subsize + 3 + 21;\n+        case NodeType::OLDER: return subsize + 1 + (CScript() << k).size();\n+        case NodeType::AFTER: return subsize + 1 + (CScript() << k).size();\n+        case NodeType::HASH256: return subsize + 4 + 2 + 33;\n+        case NodeType::HASH160: return subsize + 4 + 2 + 21;\n+        case NodeType::SHA256: return subsize + 4 + 2 + 33;\n+        case NodeType::RIPEMD160: return subsize + 4 + 2 + 21;\n+        case NodeType::WRAP_A: return subsize + 2;\n+        case NodeType::WRAP_S: return subsize + 1;\n+        case NodeType::WRAP_C: return subsize + 1;\n+        case NodeType::WRAP_D: return subsize + 3;\n+        case NodeType::WRAP_V: return subsize + (sub0typ << \"x\"_mst);\n+        case NodeType::WRAP_J: return subsize + 4;\n+        case NodeType::WRAP_N: return subsize + 1;\n+        case NodeType::JUST_1: return 1;\n+        case NodeType::JUST_0: return 1;\n+        case NodeType::AND_V: return subsize;\n+        case NodeType::AND_B: return subsize + 1;\n+        case NodeType::OR_B: return subsize + 1;\n+        case NodeType::OR_D: return subsize + 3;\n+        case NodeType::OR_C: return subsize + 2;\n+        case NodeType::OR_I: return subsize + 3;\n+        case NodeType::ANDOR: return subsize + 3;\n+        case NodeType::THRESH: return subsize + n_subs + 1;\n+        case NodeType::MULTI: return subsize + 3 + (n_keys > 16) + (k > 16) + 34 * n_keys;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r800070869",
      "id" : 800070869,
      "in_reply_to_id" : 796126519,
      "line" : 279,
      "node_id" : "PRRC_kwDOABII584vsBzV",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 278,
      "original_position" : 278,
      "original_start_line" : 253,
      "path" : "src/script/miniscript.cpp",
      "position" : 278,
      "pull_request_review_id" : 873944285,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/800070869/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 254,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-05T15:54:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/800070869",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801035751"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801035751"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In f09f339d483824a40b7aacc7c1449a206d4f79f4 \"Miniscript: conversion from script\"\r\n\r\nThese if statements are almost the same, ISTM this could be de-duplicated so that there is only one really long line to read.",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-07T20:34:32Z",
      "diff_hunk" : "@@ -1007,13 +1008,429 @@ inline NodeRef<Key> Parse(Span<const char> in, const Ctx& ctx)\n     return tl_node;\n }\n \n+/** Decode a script into opcode/push pairs.\n+ *\n+ * Construct a vector with one element per opcode in the script, in reverse order.\n+ * Each element is a pair consisting of the opcode, as well as the data pushed by\n+ * the opcode (including OP_n), if any. OP_CHECKSIGVERIFY, OP_CHECKMULTISIGVERIFY,\n+ * and OP_EQUALVERIFY are decomposed into OP_CHECKSIG, OP_CHECKMULTISIG, OP_EQUAL\n+ * respectively, plus OP_VERIFY.\n+ */\n+bool DecomposeScript(const CScript& script, std::vector<std::pair<opcodetype, std::vector<unsigned char>>>& out);\n+\n+/** Determine whether the passed pair (created by DecomposeScript) is pushing a number. */\n+bool ParseScriptNumber(const std::pair<opcodetype, std::vector<unsigned char>>& in, int64_t& k);\n+\n+enum class DecodeContext {\n+    /** A single expression of type B, K, or V. Specifically, this can't be an\n+     * and_v or an expression of type W (a: and s: wrappers). */\n+    SINGLE_BKV_EXPR,\n+    /** Potentially multiple SINGLE_BKV_EXPRs as children of (potentially multiple)\n+     * and_v expressions. Syntactic sugar for MAYBE_AND_V + SINGLE_BKV_EXPR. */\n+    BKV_EXPR,\n+    /** An expression of type W (a: or s: wrappers). */\n+    W_EXPR,\n+\n+    /** SWAP expects the next element to be OP_SWAP (inside a W-type expression that\n+     * didn't end with FROMALTSTACK), and wraps the top of the constructed stack\n+     * with s: */\n+    SWAP,\n+    /** ALT expects the next element to be TOALTSTACK (we must have already read a\n+     * FROMALTSTACK earlier), and wraps the top of the constructed stack with a: */\n+    ALT,\n+    /** CHECK wraps the top constructed node with c: */\n+    CHECK,\n+    /** DUP_IF wraps the top constructed node with d: */\n+    DUP_IF,\n+    /** VERIFY wraps the top constructed node with v: */\n+    VERIFY,\n+    /** NON_ZERO wraps the top constructed node with j: */\n+    NON_ZERO,\n+    /** ZERO_NOTEQUAL wraps the top constructed node with n: */\n+    ZERO_NOTEQUAL,\n+\n+    /** MAYBE_AND_V will check if the next part of the script could be a valid\n+     * miniscript sub-expression, and if so it will push AND_V and SINGLE_BKV_EXPR\n+     * to decode it and construct the and_v node. This is recursive, to deal with\n+     * multiple and_v nodes inside each other. */\n+    MAYBE_AND_V,\n+    /** AND_V will construct an and_v node from the last two constructed nodes. */\n+    AND_V,\n+    /** AND_B will construct an and_b node from the last two constructed nodes. */\n+    AND_B,\n+    /** ANDOR will construct an andor node from the last three constructed nodes. */\n+    ANDOR,\n+    /** OR_B will construct an or_b node from the last two constructed nodes. */\n+    OR_B,\n+    /** OR_C will construct an or_c node from the last two constructed nodes. */\n+    OR_C,\n+    /** OR_D will construct an or_d node from the last two constructed nodes. */\n+    OR_D,\n+\n+    /** In a thresh expression, all sub-expressions other than the first are W-type,\n+     * and end in OP_ADD. THRESH_W will check for this OP_ADD and either push a W_EXPR\n+     * or a SINGLE_BKV_EXPR and jump to THRESH_E accordingly. */\n+    THRESH_W,\n+    /** THRESH_E constructs a thresh node from the appropriate number of constructed\n+     * children. */\n+    THRESH_E,\n+\n+    /** ENDIF signals that we are inside some sort of OP_IF structure, which could be\n+     * or_d, or_c, or_i, andor, d:, or j: wrapper, depending on what follows. We read\n+     * a BKV_EXPR and then deal with the next opcode case-by-case. */\n+    ENDIF,\n+    /** If, inside an ENDIF context, we find an OP_NOTIF before finding an OP_ELSE,\n+     * we could either be in an or_d or an or_c node. We then check for IFDUP to\n+     * distinguish these cases. */\n+    ENDIF_NOTIF,\n+    /** If, inside an ENDIF context, we find an OP_ELSE, then we could be in either an\n+     * or_i or an andor node. Read the next BKV_EXPR and find either an OP_IF or an\n+     * OP_NOTIF. */\n+    ENDIF_ELSE,\n+};\n+\n+//! Parse a miniscript from a bitcoin script\n+template<typename Key, typename Ctx, typename I>\n+inline NodeRef<Key> DecodeScript(I& in, I last, const Ctx& ctx)\n+{\n+    // The two integers are used to hold state for thresh()\n+    std::vector<std::tuple<DecodeContext, int64_t, int64_t>> to_parse;\n+    std::vector<NodeRef<Key>> constructed;\n+\n+    // This is the top level, so we assume the type is B\n+    // (in particular, disallowing top level W expressions)\n+    to_parse.emplace_back(DecodeContext::BKV_EXPR, -1, -1);\n+\n+    while (!to_parse.empty()) {\n+        // Exit early if the Miniscript is not going to be valid.\n+        if (!constructed.empty() && !constructed.back()->IsValid()) return {};\n+\n+        // Get the current context we are decoding within\n+        auto [cur_context, n, k] = to_parse.back();\n+        to_parse.pop_back();\n+\n+        switch(cur_context) {\n+        case DecodeContext::SINGLE_BKV_EXPR: {\n+            if (in >= last) return {};\n+\n+            // Constants\n+            if (in[0].first == OP_1) {\n+                ++in;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::JUST_1));\n+            } else if (in[0].first == OP_0) {\n+                ++in;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::JUST_0));\n+            }\n+            // Public keys\n+            else if (in[0].second.size() == 33) {\n+                Key key;\n+                if (!ctx.FromPKBytes(in[0].second.begin(), in[0].second.end(), key)) return {};\n+                ++in;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::PK_K, Vector(std::move(key))));\n+            } else if (last - in >= 5 && in[0].first == OP_VERIFY && in[1].first == OP_EQUAL && in[3].first == OP_HASH160 && in[4].first == OP_DUP && in[2].second.size() == 20) {\n+                Key key;\n+                if (!ctx.FromPKHBytes(in[2].second.begin(), in[2].second.end(), key)) return {};\n+                in += 5;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::PK_H, Vector(std::move(key))));\n+            }\n+            // Time locks\n+            else if (last - in >= 2 && in[0].first == OP_CHECKSEQUENCEVERIFY && ParseScriptNumber(in[1], k)) {\n+                in += 2;\n+                if (k < 1 || k > 0x7FFFFFFFL) return {};\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::OLDER, k));\n+            } else if (last - in >= 2 && in[0].first == OP_CHECKLOCKTIMEVERIFY && ParseScriptNumber(in[1], k)) {\n+                in += 2;\n+                if (k < 1 || k > 0x7FFFFFFFL) return {};\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::AFTER, k));\n+            }\n+            // Hashes\n+            else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 32 && in[2].first == OP_SHA256 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::SHA256, in[1].second));\n+                in += 7;\n+            } else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 20 && in[2].first == OP_RIPEMD160 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::RIPEMD160, in[1].second));\n+                in += 7;\n+            } else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 32 && in[2].first == OP_HASH256 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::HASH256, in[1].second));\n+                in += 7;\n+            } else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 20 && in[2].first == OP_HASH160 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801035751",
      "id" : 801035751,
      "line" : 1301,
      "node_id" : "PRRC_kwDOABII584vvtXn",
      "original_commit_id" : "f09f339d483824a40b7aacc7c1449a206d4f79f4",
      "original_line" : 1156,
      "original_position" : 157,
      "original_start_line" : 1147,
      "path" : "src/script/miniscript.h",
      "position" : 157,
      "pull_request_review_id" : 875216427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801035751/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1292,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-07T21:17:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801035751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801037068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801037068"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 85cf12e20201eee4ed23902e1da151f63663cfab \"Miniscript: ops limit and stack size computation\"\r\n\r\nThis is named very similarly to `sat` on the next line. It is confusing and potentially disastrous if a typo is made.\r\n\r\n```suggestion\r\n    uint32_t ops;\r\n```",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-07T20:36:28Z",
      "diff_hunk" : "@@ -231,6 +231,47 @@ size_t ComputeScriptLen(Fragment nodetype, Type sub0typ, size_t subsize, uint32_\n //! A helper sanitizer/checker for the output of CalcType.\n Type SanitizeType(Type x);\n \n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801037068",
      "id" : 801037068,
      "line" : 257,
      "node_id" : "PRRC_kwDOABII584vvtsM",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 257,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 27,
      "pull_request_review_id" : 875216427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801037068/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-07T21:17:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801037068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801056705"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801056705"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 85cf12e20201eee4ed23902e1da151f63663cfab \"Miniscript: ops limit and stack size computation\"\r\n\r\nA lot of these are the same, so this could be de-duplicated in the same way that the size calculation was.",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-07T21:04:24Z",
      "diff_hunk" : "@@ -555,10 +600,110 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER: return {1, 0, {}};\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256: return {4, 0, {}};\n+            case Fragment::RIPEMD160: return {4, 0, {}};\n+            case Fragment::HASH256: return {4, 0, {}};\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case Fragment::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case Fragment::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801056705",
      "id" : 801056705,
      "line" : 629,
      "node_id" : "PRRC_kwDOABII584vvyfB",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 629,
      "original_position" : 89,
      "original_start_line" : 605,
      "path" : "src/script/miniscript.h",
      "position" : 89,
      "pull_request_review_id" : 875216427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801056705/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 605,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-07T21:17:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801056705",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801057035"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801057035"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 85cf12e20201eee4ed23902e1da151f63663cfab \"Miniscript: ops limit and stack size computation\"\r\n\r\nA lot of these are the same, so this can be de-duplicated in the same way that the size calculation was.",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-07T21:04:54Z",
      "diff_hunk" : "@@ -555,10 +600,110 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER: return {1, 0, {}};\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256: return {4, 0, {}};\n+            case Fragment::RIPEMD160: return {4, 0, {}};\n+            case Fragment::HASH256: return {4, 0, {}};\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case Fragment::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case Fragment::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::THRESH: {\n+                uint32_t stat = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    stat += sub->ops.stat + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ops.dsat, sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {stat, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::OLDER: return {0, {}};\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::SHA256: return {1, {}};\n+            case Fragment::RIPEMD160: return {1, {}};\n+            case Fragment::HASH256: return {1, {}};\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: return {Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat), subs[0]->ss.dsat + subs[2]->ss.dsat};\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: return {Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};\n+            case Fragment::WRAP_A: return subs[0]->ss;\n+            case Fragment::WRAP_S: return subs[0]->ss;\n+            case Fragment::WRAP_C: return subs[0]->ss;\n+            case Fragment::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case Fragment::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_N: return subs[0]->ss;\n+            case Fragment::JUST_1: return {0, {}};\n+            case Fragment::JUST_0: return {{}, 0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801057035",
      "id" : 801057035,
      "line" : 674,
      "node_id" : "PRRC_kwDOABII584vvykL",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 674,
      "original_position" : 134,
      "original_start_line" : 649,
      "path" : "src/script/miniscript.h",
      "position" : 134,
      "pull_request_review_id" : 875216427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801057035/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 649,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-07T21:17:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801057035",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801058088"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801058088"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 85cf12e20201eee4ed23902e1da151f63663cfab \"Miniscript: ops limit and stack size computation\"\r\n\r\nWhat is the distinction between `{}` and `0`? How com some fragments use 0, and others use `{}`?\r\n\r\nIt seems like `{}` is being used for fragments that have no dis/satisfaction. However it is used for the hashing fragments and those have a dissatisfaction.",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-07T21:06:27Z",
      "diff_hunk" : "@@ -555,10 +600,110 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER: return {1, 0, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801058088",
      "id" : 801058088,
      "line" : 607,
      "node_id" : "PRRC_kwDOABII584vvy0o",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 607,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 67,
      "pull_request_review_id" : 875216427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801058088/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-07T21:17:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801058088",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801058856"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801058856"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 85cf12e20201eee4ed23902e1da151f63663cfab \"Miniscript: ops limit and stack size computation\"\r\n\r\nIt was not immediately obvious to me that this includes the script itself as a stack item, perhaps mention that in the docstring?",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-07T21:07:39Z",
      "diff_hunk" : "@@ -555,10 +600,110 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER: return {1, 0, {}};\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256: return {4, 0, {}};\n+            case Fragment::RIPEMD160: return {4, 0, {}};\n+            case Fragment::HASH256: return {4, 0, {}};\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case Fragment::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case Fragment::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::THRESH: {\n+                uint32_t stat = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    stat += sub->ops.stat + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ops.dsat, sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {stat, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::OLDER: return {0, {}};\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::SHA256: return {1, {}};\n+            case Fragment::RIPEMD160: return {1, {}};\n+            case Fragment::HASH256: return {1, {}};\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: return {Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat), subs[0]->ss.dsat + subs[2]->ss.dsat};\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: return {Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};\n+            case Fragment::WRAP_A: return subs[0]->ss;\n+            case Fragment::WRAP_S: return subs[0]->ss;\n+            case Fragment::WRAP_C: return subs[0]->ss;\n+            case Fragment::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case Fragment::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_N: return subs[0]->ss;\n+            case Fragment::JUST_1: return {0, {}};\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::THRESH: {\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    auto next_sats = Vector(sats[0] + sub->ss.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ss.dsat, sats[j - 1] + sub->ss.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ss.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};\n+    }\n+\n public:\n     //! Return the size of the script for this expression (faster than ToScript().size()).\n     size_t ScriptSize() const { return scriptlen; }\n \n+    //! Return the maximum number of ops needed to satisfy this script non-malleably.\n+    uint32_t GetOps() const { return ops.stat + ops.sat.value; }\n+\n+    //! Check the ops limit of this script against the consensus limit.\n+    bool CheckOpsLimit() const { return GetOps() <= MAX_OPS_PER_SCRIPT; }\n+\n+    //! Return the maximum number of stack elements needed to satisfy this script non-malleably.\n+    uint32_t GetStackSize() const { return ss.sat.value + 1; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801058856",
      "id" : 801058856,
      "line" : 702,
      "node_id" : "PRRC_kwDOABII584vvzAo",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 702,
      "original_position" : 162,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 162,
      "pull_request_review_id" : 875216427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801058856/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-07T21:17:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801058856",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801067445"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801067445"
         }
      },
      "author_association" : "MEMBER",
      "body" : "While hashes do have dissatisfactions, they are always malleable. The ops counting algorithm only works for non-malleable signing, which will never use these.\r\n\r\n(Just mentioning this to explain it to you; if it's not clear from the code that this is the case it should be documented of course)",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-07T21:20:14Z",
      "diff_hunk" : "@@ -555,10 +600,110 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER: return {1, 0, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r801067445",
      "id" : 801067445,
      "in_reply_to_id" : 801058088,
      "line" : 607,
      "node_id" : "PRRC_kwDOABII584vv1G1",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 607,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 67,
      "pull_request_review_id" : 875259476,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801067445/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-07T21:29:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/801067445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r803802945"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803802945"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Naming a field of `Ops` \"`ops`\" is a bit weird, went with `count` instead.",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-10T15:34:06Z",
      "diff_hunk" : "@@ -231,6 +231,47 @@ size_t ComputeScriptLen(Fragment nodetype, Type sub0typ, size_t subsize, uint32_\n //! A helper sanitizer/checker for the output of CalcType.\n Type SanitizeType(Type x);\n \n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r803802945",
      "id" : 803802945,
      "in_reply_to_id" : 801037068,
      "line" : 257,
      "node_id" : "PRRC_kwDOABII584v6Q9B",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 257,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 27,
      "pull_request_review_id" : 879020861,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803802945/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T15:34:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803802945",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r803931519"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803931519"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not so many are the same so it wasn't a huge readability gain. So i re-ordered it to hopefully make it easier on the eyes.\r\n\r\nI also broke down the super long lines into \"count, sat, dsat\". I think that helps. Same for the stack size computation below.",
      "commit_id" : "fa39084fc47a196e8d5f4b1b7807444ffff60a6b",
      "created_at" : "2022-02-10T17:32:08Z",
      "diff_hunk" : "@@ -555,10 +600,110 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER: return {1, 0, {}};\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256: return {4, 0, {}};\n+            case Fragment::RIPEMD160: return {4, 0, {}};\n+            case Fragment::HASH256: return {4, 0, {}};\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case Fragment::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case Fragment::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case Fragment::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r803931519",
      "id" : 803931519,
      "in_reply_to_id" : 801056705,
      "line" : 629,
      "node_id" : "PRRC_kwDOABII584v6wV_",
      "original_commit_id" : "85cf12e20201eee4ed23902e1da151f63663cfab",
      "original_line" : 629,
      "original_position" : 89,
      "original_start_line" : 605,
      "path" : "src/script/miniscript.h",
      "position" : 89,
      "pull_request_review_id" : 879198587,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803931519/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 605,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-10T17:32:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803931519",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r804485876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804485876"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If i do that i need to get rid of all the `else if`s and replace them with `if { ...; break;}`. I can do that but it's more a matter of taste than a net benefit.\r\n\r\nEDIT: done.",
      "commit_id" : "4b74cc97d3543efe6c2f126da5e807da72cc782c",
      "created_at" : "2022-02-11T09:35:59Z",
      "diff_hunk" : "@@ -1007,13 +1008,429 @@ inline NodeRef<Key> Parse(Span<const char> in, const Ctx& ctx)\n     return tl_node;\n }\n \n+/** Decode a script into opcode/push pairs.\n+ *\n+ * Construct a vector with one element per opcode in the script, in reverse order.\n+ * Each element is a pair consisting of the opcode, as well as the data pushed by\n+ * the opcode (including OP_n), if any. OP_CHECKSIGVERIFY, OP_CHECKMULTISIGVERIFY,\n+ * and OP_EQUALVERIFY are decomposed into OP_CHECKSIG, OP_CHECKMULTISIG, OP_EQUAL\n+ * respectively, plus OP_VERIFY.\n+ */\n+bool DecomposeScript(const CScript& script, std::vector<std::pair<opcodetype, std::vector<unsigned char>>>& out);\n+\n+/** Determine whether the passed pair (created by DecomposeScript) is pushing a number. */\n+bool ParseScriptNumber(const std::pair<opcodetype, std::vector<unsigned char>>& in, int64_t& k);\n+\n+enum class DecodeContext {\n+    /** A single expression of type B, K, or V. Specifically, this can't be an\n+     * and_v or an expression of type W (a: and s: wrappers). */\n+    SINGLE_BKV_EXPR,\n+    /** Potentially multiple SINGLE_BKV_EXPRs as children of (potentially multiple)\n+     * and_v expressions. Syntactic sugar for MAYBE_AND_V + SINGLE_BKV_EXPR. */\n+    BKV_EXPR,\n+    /** An expression of type W (a: or s: wrappers). */\n+    W_EXPR,\n+\n+    /** SWAP expects the next element to be OP_SWAP (inside a W-type expression that\n+     * didn't end with FROMALTSTACK), and wraps the top of the constructed stack\n+     * with s: */\n+    SWAP,\n+    /** ALT expects the next element to be TOALTSTACK (we must have already read a\n+     * FROMALTSTACK earlier), and wraps the top of the constructed stack with a: */\n+    ALT,\n+    /** CHECK wraps the top constructed node with c: */\n+    CHECK,\n+    /** DUP_IF wraps the top constructed node with d: */\n+    DUP_IF,\n+    /** VERIFY wraps the top constructed node with v: */\n+    VERIFY,\n+    /** NON_ZERO wraps the top constructed node with j: */\n+    NON_ZERO,\n+    /** ZERO_NOTEQUAL wraps the top constructed node with n: */\n+    ZERO_NOTEQUAL,\n+\n+    /** MAYBE_AND_V will check if the next part of the script could be a valid\n+     * miniscript sub-expression, and if so it will push AND_V and SINGLE_BKV_EXPR\n+     * to decode it and construct the and_v node. This is recursive, to deal with\n+     * multiple and_v nodes inside each other. */\n+    MAYBE_AND_V,\n+    /** AND_V will construct an and_v node from the last two constructed nodes. */\n+    AND_V,\n+    /** AND_B will construct an and_b node from the last two constructed nodes. */\n+    AND_B,\n+    /** ANDOR will construct an andor node from the last three constructed nodes. */\n+    ANDOR,\n+    /** OR_B will construct an or_b node from the last two constructed nodes. */\n+    OR_B,\n+    /** OR_C will construct an or_c node from the last two constructed nodes. */\n+    OR_C,\n+    /** OR_D will construct an or_d node from the last two constructed nodes. */\n+    OR_D,\n+\n+    /** In a thresh expression, all sub-expressions other than the first are W-type,\n+     * and end in OP_ADD. THRESH_W will check for this OP_ADD and either push a W_EXPR\n+     * or a SINGLE_BKV_EXPR and jump to THRESH_E accordingly. */\n+    THRESH_W,\n+    /** THRESH_E constructs a thresh node from the appropriate number of constructed\n+     * children. */\n+    THRESH_E,\n+\n+    /** ENDIF signals that we are inside some sort of OP_IF structure, which could be\n+     * or_d, or_c, or_i, andor, d:, or j: wrapper, depending on what follows. We read\n+     * a BKV_EXPR and then deal with the next opcode case-by-case. */\n+    ENDIF,\n+    /** If, inside an ENDIF context, we find an OP_NOTIF before finding an OP_ELSE,\n+     * we could either be in an or_d or an or_c node. We then check for IFDUP to\n+     * distinguish these cases. */\n+    ENDIF_NOTIF,\n+    /** If, inside an ENDIF context, we find an OP_ELSE, then we could be in either an\n+     * or_i or an andor node. Read the next BKV_EXPR and find either an OP_IF or an\n+     * OP_NOTIF. */\n+    ENDIF_ELSE,\n+};\n+\n+//! Parse a miniscript from a bitcoin script\n+template<typename Key, typename Ctx, typename I>\n+inline NodeRef<Key> DecodeScript(I& in, I last, const Ctx& ctx)\n+{\n+    // The two integers are used to hold state for thresh()\n+    std::vector<std::tuple<DecodeContext, int64_t, int64_t>> to_parse;\n+    std::vector<NodeRef<Key>> constructed;\n+\n+    // This is the top level, so we assume the type is B\n+    // (in particular, disallowing top level W expressions)\n+    to_parse.emplace_back(DecodeContext::BKV_EXPR, -1, -1);\n+\n+    while (!to_parse.empty()) {\n+        // Exit early if the Miniscript is not going to be valid.\n+        if (!constructed.empty() && !constructed.back()->IsValid()) return {};\n+\n+        // Get the current context we are decoding within\n+        auto [cur_context, n, k] = to_parse.back();\n+        to_parse.pop_back();\n+\n+        switch(cur_context) {\n+        case DecodeContext::SINGLE_BKV_EXPR: {\n+            if (in >= last) return {};\n+\n+            // Constants\n+            if (in[0].first == OP_1) {\n+                ++in;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::JUST_1));\n+            } else if (in[0].first == OP_0) {\n+                ++in;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::JUST_0));\n+            }\n+            // Public keys\n+            else if (in[0].second.size() == 33) {\n+                Key key;\n+                if (!ctx.FromPKBytes(in[0].second.begin(), in[0].second.end(), key)) return {};\n+                ++in;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::PK_K, Vector(std::move(key))));\n+            } else if (last - in >= 5 && in[0].first == OP_VERIFY && in[1].first == OP_EQUAL && in[3].first == OP_HASH160 && in[4].first == OP_DUP && in[2].second.size() == 20) {\n+                Key key;\n+                if (!ctx.FromPKHBytes(in[2].second.begin(), in[2].second.end(), key)) return {};\n+                in += 5;\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::PK_H, Vector(std::move(key))));\n+            }\n+            // Time locks\n+            else if (last - in >= 2 && in[0].first == OP_CHECKSEQUENCEVERIFY && ParseScriptNumber(in[1], k)) {\n+                in += 2;\n+                if (k < 1 || k > 0x7FFFFFFFL) return {};\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::OLDER, k));\n+            } else if (last - in >= 2 && in[0].first == OP_CHECKLOCKTIMEVERIFY && ParseScriptNumber(in[1], k)) {\n+                in += 2;\n+                if (k < 1 || k > 0x7FFFFFFFL) return {};\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::AFTER, k));\n+            }\n+            // Hashes\n+            else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 32 && in[2].first == OP_SHA256 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::SHA256, in[1].second));\n+                in += 7;\n+            } else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 20 && in[2].first == OP_RIPEMD160 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::RIPEMD160, in[1].second));\n+                in += 7;\n+            } else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 32 && in[2].first == OP_HASH256 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+                constructed.push_back(MakeNodeRef<Key>(Fragment::HASH256, in[1].second));\n+                in += 7;\n+            } else if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 20 && in[2].first == OP_HASH160 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r804485876",
      "id" : 804485876,
      "in_reply_to_id" : 801035751,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v83r0",
      "original_commit_id" : "f09f339d483824a40b7aacc7c1449a206d4f79f4",
      "original_line" : 1156,
      "original_position" : 157,
      "original_start_line" : 1147,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 879948717,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804485876/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-11T11:45:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804485876",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Addressed Andrew's comments, i also reworked the fuzz target. As a consequence i added a couple missing checks in the function decoding from Script. We are currently working on different approaches to write one or more fuzz targets generating random fragments in place of the random unit tests, which was removed in the previous push. They could be included here or in #24149 since it's tightly related to testing the satisfaction logic.\r\n\r\nRegarding Sjors' point about splitting commits further i'd like to have other reviewers' opinion. I'm personally still not sure that it makes sense but heh i'm not the one reviewing the PR :). So if others think that would be useful, i could break down the first commit into tiny ones..",
      "created_at" : "2022-02-11T11:44:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1036124283",
      "id" : 1036124283,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849wgB7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1036124283/reactions"
      },
      "updated_at" : "2022-02-11T11:44:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1036124283",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 4b74cc97d3543efe6c2f126da5e807da72cc782c",
      "created_at" : "2022-02-14T19:22:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1039463882",
      "id" : 1039463882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII58499PXK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1039463882/reactions"
      },
      "updated_at" : "2022-02-14T19:22:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1039463882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r806266557"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806266557"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in f38df6abfb40120899c7324b7e690d1b585bc26b \"Miniscript: ops limit and stack size computation\"\r\n\r\nI'm having a bit of a hard time figuring out how this arrives at the right answer. Could you provide a brief explanation of how this loop works to count the opcodes (and stack size, and the input stack, in other places)?",
      "commit_id" : "4b74cc97d3543efe6c2f126da5e807da72cc782c",
      "created_at" : "2022-02-14T21:49:05Z",
      "diff_hunk" : "@@ -555,10 +600,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const uint32_t count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const uint32_t count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const uint32_t count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const uint32_t count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const uint32_t count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat)};\n+                const internal::MaxInt<uint32_t> dsat{Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const uint32_t count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ops.dsat, sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r806266557",
      "id" : 806266557,
      "line" : 670,
      "node_id" : "PRRC_kwDOABII584wDqa9",
      "original_commit_id" : "f38df6abfb40120899c7324b7e690d1b585bc26b",
      "original_line" : 670,
      "original_position" : 130,
      "original_start_line" : 660,
      "path" : "src/script/miniscript.h",
      "position" : 130,
      "pull_request_review_id" : 882226774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806266557/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 660,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-14T21:49:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806266557",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r810989328"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810989328"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The algorithm used here is the same as the one used for the satisfaction of a thresh fragment in #24149. The intent is to compute the maximum satisfaction and dissatisfaction cost (in various resources) for a given fragment.\r\n\r\nFor a `thresh` with `n` sub-fragments and a threshold of `k` the algorithm will end up with a vector of `n` elements, acting as a mapping from `k` -> cost. With the special case of `k == 0` considered the dissatisfaction of the `thresh` fragment ([the only non-malleable dissatisfaction of this fragment](https://bitcoin.sipa.be/miniscript/)). Note a `thresh` with a `k` of 0 is invalid.\r\n\r\nThe algorithm works by adding for each sub the cost of its dissatisfaction to the first entry of the vector, and the cost of its satisfaction to the last entry.\r\nThe entries from `1` to `n - 1` are then updated with the bigger of:\r\n- the existing cost (at `k`) plus the dissatisfaction cost of the current sub, that is we have enough subs satisfied and we dissatisfy the current sub\r\n- the previous cost (`k - 1`) plus the satisfaction cost of the current sub, that is we are missing one sub to get to the threshold and we satisfy the current sub",
      "commit_id" : "4b74cc97d3543efe6c2f126da5e807da72cc782c",
      "created_at" : "2022-02-21T10:34:06Z",
      "diff_hunk" : "@@ -555,10 +600,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const uint32_t count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const uint32_t count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const uint32_t count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const uint32_t count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const uint32_t count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat)};\n+                const internal::MaxInt<uint32_t> dsat{Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const uint32_t count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const internal::MaxInt<uint32_t> sat{Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const internal::MaxInt<uint32_t> dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ops.dsat, sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r810989328",
      "id" : 810989328,
      "in_reply_to_id" : 806266557,
      "line" : 670,
      "node_id" : "PRRC_kwDOABII584wVrcQ",
      "original_commit_id" : "f38df6abfb40120899c7324b7e690d1b585bc26b",
      "original_line" : 670,
      "original_position" : 130,
      "original_start_line" : 660,
      "path" : "src/script/miniscript.h",
      "position" : 130,
      "pull_request_review_id" : 888491252,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810989328/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 660,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-21T10:34:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810989328",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Pushed some cleanups by @sipa (https://github.com/sipa/miniscript/pull/101).",
      "created_at" : "2022-02-21T14:27:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1046937396",
      "id" : 1046937396,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584-Zv80",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1046937396/reactions"
      },
      "updated_at" : "2022-02-21T14:27:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1046937396",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r816580292"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/816580292"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In 65c79db36818acc193e21c4b5bb6bf7dbf8ff764:\r\n\r\nThis should be a number of signatures instead of `keys`. ",
      "commit_id" : "cdd630e478047f17a43e5fb0e4a71f838fdc8c32",
      "created_at" : "2022-03-01T09:14:04Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat)};\n+                const auto dsat{Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ops.dsat, sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: {\n+                const auto sat{Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[2]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: {\n+                const auto sat{Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[1]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r816580292",
      "id" : 816580292,
      "line" : 705,
      "node_id" : "PRRC_kwDOABII584wrAbE",
      "original_commit_id" : "65c79db36818acc193e21c4b5bb6bf7dbf8ff764",
      "original_line" : 705,
      "original_position" : 164,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 164,
      "pull_request_review_id" : 871149762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/816580292/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-01T09:14:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/816580292",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@stepansnigirev you might be interested in reviewing this.",
      "created_at" : "2022-03-03T19:16:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1058399480",
      "id" : 1058399480,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584_FeT4",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1058399480/reactions"
      },
      "updated_at" : "2022-03-03T19:16:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1058399480",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "We'll address all comments that have been left here soon, but just FYI, there are a bunch of improvements still ongoing in the miniscript repo itself (https://github.com/sipa/miniscript/, most of which will eventually be moved here after this PR and the followups).",
      "created_at" : "2022-03-03T19:19:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1058401502",
      "id" : 1058401502,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584_Feze",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1058401502/reactions"
      },
      "updated_at" : "2022-03-03T19:19:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1058401502",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-03-04T13:30:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1059164212",
      "id" : 1059164212,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584_IZA0",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1059164212/reactions"
      },
      "updated_at" : "2022-03-04T13:30:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1059164212",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r826198937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826198937"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've updated the comment to be more general but not exhaustive:\r\n```diff\r\ndiff --git a/src/script/miniscript.h b/src/script/miniscript.h\r\nindex 88270e54d7..070dcc9d14 100644\r\n--- a/src/script/miniscript.h\r\n+++ b/src/script/miniscript.h\r\n@@ -42,9 +42,9 @@ namespace miniscript {\r\n  *   - Takes its inputs from the top of the stack.\r\n  *   - When satisfactied, pushes nothing.\r\n  *   - Cannot be dissatisfied.\r\n- *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\r\n+ *   - This can be obtained by adding an OP_VERIFY to a B, modifying the last opcode\r\n  *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\r\n- *     and OP_EQUAL), or using IFs where both branches are also Vs.\r\n+ *     and OP_EQUAL), or by combining a V fragment under some conditions.\r\n  *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\r\n  * - \"K\" Key:\r\n  *   - Takes its inputs from the top of the stack.\r\n```\r\n\r\nResolving for now, feel free to continue if you think i should do more and i'll unresolve.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-03-14T17:17:51Z",
      "diff_hunk" : "@@ -0,0 +1,998 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r826198937",
      "id" : 826198937,
      "in_reply_to_id" : 798043674,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xPsuZ",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 47,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 909142717,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826198937/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-17T13:54:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826198937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r826213528"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826213528"
         }
      },
      "author_association" : "MEMBER",
      "body" : "+1 for consistency :). But was there a rationale for the website's order? I find it not very intuitive, and i'd rather \"fix\" it there first before modifying `switch`es here. For instance what about:\r\n1. All leaf fragments (from `0` to `multi`)\r\n2. 2-args \"combiner\" fragments\r\n3. 3-args \"combiner\" fragments\r\n4. n-args \"combiner\" fragments (`thresh`)\r\n5. wrappers\r\n\r\nAlso, note that most other places where we switch on the fragment type have grouped cases and groups aren't necessarily in the same order as the website (or mine from above). So ordering in `switch` cases would be more of a \"best effort\" in most places.",
      "commit_id" : "cdd630e478047f17a43e5fb0e4a71f838fdc8c32",
      "created_at" : "2022-03-14T17:33:55Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.\n+        (!(e << \"z\"_mst) || !(e << \"o\"_mst)) && // z conflicts with o\n+        (!(e << \"n\"_mst) || !(e << \"z\"_mst)) && // n conflicts with z\n+        (!(e << \"n\"_mst) || !(e << \"W\"_mst)) && // n conflicts with W\n+        (!(e << \"V\"_mst) || !(e << \"d\"_mst)) && // V conflicts with d\n+        (!(e << \"K\"_mst) ||  (e << \"u\"_mst)) && // K implies u\n+        (!(e << \"V\"_mst) || !(e << \"u\"_mst)) && // V conflicts with u\n+        (!(e << \"e\"_mst) || !(e << \"f\"_mst)) && // e conflicts with f\n+        (!(e << \"e\"_mst) ||  (e << \"d\"_mst)) && // e implies d\n+        (!(e << \"V\"_mst) || !(e << \"e\"_mst)) && // V conflicts with e\n+        (!(e << \"d\"_mst) || !(e << \"f\"_mst)) && // d conflicts with f\n+        (!(e << \"V\"_mst) ||  (e << \"f\"_mst)) && // V implies f\n+        (!(e << \"K\"_mst) ||  (e << \"s\"_mst)) && // K implies s\n+        (!(e << \"z\"_mst) ||  (e << \"m\"_mst)); // z implies m\n+    assert(ok);\n+    return e;\n+}\n+\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys) {\n+    // Sanity check on data\n+    if (nodetype == NodeType::SHA256 || nodetype == NodeType::HASH256) {\n+        assert(data_size == 32);\n+    } else if (nodetype == NodeType::RIPEMD160 || nodetype == NodeType::HASH160) {\n+        assert(data_size == 20);\n+    } else {\n+        assert(data_size == 0);\n+    }\n+    // Sanity check on k\n+    if (nodetype == NodeType::OLDER || nodetype == NodeType::AFTER) {\n+        assert(k >= 1 && k < 0x80000000UL);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(k >= 1 && k <= n_keys);\n+    } else if (nodetype == NodeType::THRESH) {\n+        assert(k >= 1 && k <= n_subs);\n+    } else {\n+        assert(k == 0);\n+    }\n+    // Sanity check on subs\n+    if (nodetype == NodeType::AND_V || nodetype == NodeType::AND_B || nodetype == NodeType::OR_B ||\n+        nodetype == NodeType::OR_C || nodetype == NodeType::OR_I || nodetype == NodeType::OR_D) {\n+        assert(n_subs == 2);\n+    } else if (nodetype == NodeType::ANDOR) {\n+        assert(n_subs == 3);\n+    } else if (nodetype == NodeType::WRAP_A || nodetype == NodeType::WRAP_S || nodetype == NodeType::WRAP_C ||\n+               nodetype == NodeType::WRAP_D || nodetype == NodeType::WRAP_V || nodetype == NodeType::WRAP_J ||\n+               nodetype == NodeType::WRAP_N) {\n+        assert(n_subs == 1);\n+    } else if (nodetype != NodeType::THRESH) {\n+        assert(n_subs == 0);\n+    }\n+    // Sanity check on keys\n+    if (nodetype == NodeType::PK_K || nodetype == NodeType::PK_H) {\n+        assert(n_keys == 1);\n+    } else if (nodetype == NodeType::MULTI) {\n+        assert(n_keys >= 1 && n_keys <= 20);\n+    } else {\n+        assert(n_keys == 0);\n+    }\n+\n+    // Below is the per-nodetype logic for computing the expression types.\n+    // It heavily relies on Type's << operator (where \"X << a_mst\" means\n+    // \"X has all properties listed in a\").\n+    switch (nodetype) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r826213528",
      "id" : 826213528,
      "in_reply_to_id" : 798076142,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII584xPwSY",
      "original_commit_id" : "3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c",
      "original_line" : 82,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/script/miniscript.cpp",
      "position" : 82,
      "pull_request_review_id" : 909164036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826213528/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T17:33:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826213528",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased. This is now ready for review.\r\n\r\nThere are still refactorings to the fuzz targets that have not landed in the Miniscript repo yet, i'll either add them here eventually or we'll open them as followup PRs. See https://github.com/sipa/miniscript/issues/98 for details.\r\n\r\nChanges since last push:\r\n- Fixed the `CHECKMULTISIG`stack size calculation bug (thanks Sanket!)\r\n- `Choose` was renamed to `operator|`\r\n- The modifications to `script.h` were split from the type system commit to make it only introduce `miniscript.h`\r\n- Some leftovers (from previous iterations of concatenating Scripts) were removed from `vector.h`",
      "created_at" : "2022-03-17T13:52:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1070950895",
      "id" : 1070950895,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584_1Wnv",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1070950895/reactions"
      },
      "updated_at" : "2022-03-17T13:52:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1070950895",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r829141763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829141763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, and added a unit test reproducing this.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-03-17T13:53:06Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{Choose(subs[0]->ops.sat, subs[1]->ops.sat)};\n+                const auto dsat{Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ops.dsat, sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: {\n+                const auto sat{Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[2]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: {\n+                const auto sat{Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[1]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r829141763",
      "id" : 829141763,
      "in_reply_to_id" : 816580292,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xa7MD",
      "original_commit_id" : "65c79db36818acc193e21c4b5bb6bf7dbf8ff764",
      "original_line" : 705,
      "original_position" : 164,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 913177245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829141763/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-17T13:53:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829141763",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK 2da94a4c6f55f7a3621f4a6f70902c52f735c868\r\n\r\nI've been running the miniscript_decode fuzzer for awhile and it looks good. looking forward to testing the smarter fuzzers after this is merged.",
      "created_at" : "2022-03-19T15:33:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1073030377",
      "id" : 1073030377,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584_9STp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1073030377/reactions"
      },
      "updated_at" : "2022-03-19T15:33:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1073030377",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/45598?v=4",
         "events_url" : "https://api.github.com/users/jb55/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jb55/followers",
         "following_url" : "https://api.github.com/users/jb55/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jb55/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jb55",
         "id" : 45598,
         "login" : "jb55",
         "node_id" : "MDQ6VXNlcjQ1NTk4",
         "organizations_url" : "https://api.github.com/users/jb55/orgs",
         "received_events_url" : "https://api.github.com/users/jb55/received_events",
         "repos_url" : "https://api.github.com/users/jb55/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jb55/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jb55/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jb55"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r841677970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/841677970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FYI: we require gcc 8.1 according to `doc/dependencies.md`. There's no need to work around gcc 4.8 bugs.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-04T12:25:50Z",
      "diff_hunk" : "@@ -0,0 +1,348 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/standard.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r841677970",
      "id" : 841677970,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII584yKvyS",
      "original_commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/script/miniscript.cpp",
      "position" : 20,
      "pull_request_review_id" : 930278735,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/841677970/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-04T12:25:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/841677970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Light code review ACK 2da94a4c6f55f7a3621f4a6f70902c52f735c868 (mostly reviewed the changes to the existing code and build system) ",
      "created_at" : "2022-04-04T13:37:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1087568959",
      "id" : 1087568959,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII585A0vw_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1087568959/reactions"
      },
      "updated_at" : "2022-04-04T13:37:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1087568959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r842822788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/842822788"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'll address than in #24148 .",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-05T14:00:52Z",
      "diff_hunk" : "@@ -0,0 +1,348 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/standard.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r842822788",
      "id" : 842822788,
      "in_reply_to_id" : 841677970,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII584yPHSE",
      "original_commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/script/miniscript.cpp",
      "position" : 20,
      "pull_request_review_id" : 931913599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/842822788/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-05T14:00:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/842822788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r842875582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/842875582"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See https://github.com/sipa/miniscript/pull/112",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-05T14:45:45Z",
      "diff_hunk" : "@@ -0,0 +1,348 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/standard.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r842875582",
      "id" : 842875582,
      "in_reply_to_id" : 841677970,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII584yPUK-",
      "original_commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/script/miniscript.cpp",
      "position" : 20,
      "pull_request_review_id" : 931990469,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/842875582/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-05T14:45:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/842875582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reviewers, before the integration into output descriptors, i've made a follow-up PR with the final updates and cleanups we made in the Miniscript repo.\r\nhttps://github.com/bitcoin/bitcoin/pull/24860",
      "created_at" : "2022-04-15T09:01:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1099979606",
      "id" : 1099979606,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII585BkFtW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1099979606/reactions"
      },
      "updated_at" : "2022-04-15T09:01:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1099979606",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r856688398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/856688398"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: I think this can be improved as `1 + BuildScript(n_keys).size() + BuildScript(k).size()`\r\n\r\nThe current formulation is correct but internally relies on the reasoning that k and n cannot be greater than 20. ",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-23T00:44:05Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.\n+        (!(e << \"z\"_mst) || !(e << \"o\"_mst)) && // z conflicts with o\n+        (!(e << \"n\"_mst) || !(e << \"z\"_mst)) && // n conflicts with z\n+        (!(e << \"n\"_mst) || !(e << \"W\"_mst)) && // n conflicts with W\n+        (!(e << \"V\"_mst) || !(e << \"d\"_mst)) && // V conflicts with d\n+        (!(e << \"K\"_mst) ||  (e << \"u\"_mst)) && // K implies u\n+        (!(e << \"V\"_mst) || !(e << \"u\"_mst)) && // V conflicts with u\n+        (!(e << \"e\"_mst) || !(e << \"f\"_mst)) && // e conflicts with f\n+        (!(e << \"e\"_mst) ||  (e << \"d\"_mst)) && // e implies d\n+        (!(e << \"V\"_mst) || !(e << \"e\"_mst)) && // V conflicts with e\n+        (!(e << \"d\"_mst) || !(e << \"f\"_mst)) && // d conflicts with f\n+        (!(e << \"V\"_mst) ||  (e << \"f\"_mst)) && // V implies f\n+        (!(e << \"K\"_mst) ||  (e << \"s\"_mst)) && // K implies s\n+        (!(e << \"z\"_mst) ||  (e << \"m\"_mst)); // z implies m\n+    assert(ok);\n+    return e;\n+}\n+\n+Type ComputeType(Fragment nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys) {\n+    // Sanity check on data\n+    if (nodetype == Fragment::SHA256 || nodetype == Fragment::HASH256) {\n+        assert(data_size == 32);\n+    } else if (nodetype == Fragment::RIPEMD160 || nodetype == Fragment::HASH160) {\n+        assert(data_size == 20);\n+    } else {\n+        assert(data_size == 0);\n+    }\n+    // Sanity check on k\n+    if (nodetype == Fragment::OLDER || nodetype == Fragment::AFTER) {\n+        assert(k >= 1 && k < 0x80000000UL);\n+    } else if (nodetype == Fragment::MULTI) {\n+        assert(k >= 1 && k <= n_keys);\n+    } else if (nodetype == Fragment::THRESH) {\n+        assert(k >= 1 && k <= n_subs);\n+    } else {\n+        assert(k == 0);\n+    }\n+    // Sanity check on subs\n+    if (nodetype == Fragment::AND_V || nodetype == Fragment::AND_B || nodetype == Fragment::OR_B ||\n+        nodetype == Fragment::OR_C || nodetype == Fragment::OR_I || nodetype == Fragment::OR_D) {\n+        assert(n_subs == 2);\n+    } else if (nodetype == Fragment::ANDOR) {\n+        assert(n_subs == 3);\n+    } else if (nodetype == Fragment::WRAP_A || nodetype == Fragment::WRAP_S || nodetype == Fragment::WRAP_C ||\n+               nodetype == Fragment::WRAP_D || nodetype == Fragment::WRAP_V || nodetype == Fragment::WRAP_J ||\n+               nodetype == Fragment::WRAP_N) {\n+        assert(n_subs == 1);\n+    } else if (nodetype != Fragment::THRESH) {\n+        assert(n_subs == 0);\n+    }\n+    // Sanity check on keys\n+    if (nodetype == Fragment::PK_K || nodetype == Fragment::PK_H) {\n+        assert(n_keys == 1);\n+    } else if (nodetype == Fragment::MULTI) {\n+        assert(n_keys >= 1 && n_keys <= 20);\n+    } else {\n+        assert(n_keys == 0);\n+    }\n+\n+    // Below is the per-nodetype logic for computing the expression types.\n+    // It heavily relies on Type's << operator (where \"X << a_mst\" means\n+    // \"X has all properties listed in a\").\n+    switch (nodetype) {\n+        case Fragment::PK_K: return \"Konudemsxk\"_mst;\n+        case Fragment::PK_H: return \"Knudemsxk\"_mst;\n+        case Fragment::OLDER: return\n+            \"g\"_mst.If(k & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) |\n+            \"h\"_mst.If(!(k & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG)) |\n+            \"Bzfmxk\"_mst;\n+        case Fragment::AFTER: return\n+            \"i\"_mst.If(k >= LOCKTIME_THRESHOLD) |\n+            \"j\"_mst.If(k < LOCKTIME_THRESHOLD) |\n+            \"Bzfmxk\"_mst;\n+        case Fragment::SHA256: return \"Bonudmk\"_mst;\n+        case Fragment::RIPEMD160: return \"Bonudmk\"_mst;\n+        case Fragment::HASH256: return \"Bonudmk\"_mst;\n+        case Fragment::HASH160: return \"Bonudmk\"_mst;\n+        case Fragment::JUST_1: return \"Bzufmxk\"_mst;\n+        case Fragment::JUST_0: return \"Bzudemsxk\"_mst;\n+        case Fragment::WRAP_A: return\n+            \"W\"_mst.If(x << \"B\"_mst) | // W=B_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"udfems\"_mst) | // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"x\"_mst; // x\n+        case Fragment::WRAP_S: return\n+            \"W\"_mst.If(x << \"Bo\"_mst) | // W=B_x*o_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"udfemsx\"_mst); // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x, x=x_x\n+        case Fragment::WRAP_C: return\n+            \"B\"_mst.If(x << \"K\"_mst) | // B=K_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"ondfem\"_mst) | // o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x\n+            \"us\"_mst; // u, s\n+        case Fragment::WRAP_D: return\n+            \"B\"_mst.If(x << \"Vz\"_mst) | // B=V_x*z_x\n+            \"o\"_mst.If(x << \"z\"_mst) | // o=z_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"ms\"_mst) | // m=m_x, s=s_x\n+            \"nudx\"_mst; // n, u, d, x\n+        case Fragment::WRAP_V: return\n+            \"V\"_mst.If(x << \"B\"_mst) | // V=B_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"zonms\"_mst) | // z=z_x, o=o_x, n=n_x, m=m_x, s=s_x\n+            \"fx\"_mst; // f, x\n+        case Fragment::WRAP_J: return\n+            \"B\"_mst.If(x << \"Bn\"_mst) | // B=B_x*n_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"oums\"_mst) | // o=o_x, u=u_x, m=m_x, s=s_x\n+            \"ndx\"_mst; // n, d, x\n+        case Fragment::WRAP_N: return\n+            (x & \"ghijk\"_mst) | // g=g_x, h=h_x, i=i_x, j=j_x, k=k_x\n+            (x & \"Bzondfems\"_mst) | // B=B_x, z=z_x, o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"ux\"_mst; // u, x\n+        case Fragment::AND_V: return\n+            (y & \"KVB\"_mst).If(x << \"V\"_mst) | // B=V_x*B_y, V=V_x*V_y, K=V_x*K_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"dmz\"_mst) | // d=d_x*d_y, m=m_x*m_y, z=z_x*z_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"f\"_mst.If((y << \"f\"_mst) || (x << \"s\"_mst)) | // f=f_y+s_x\n+            (y & \"ux\"_mst) | // u=u_y, x=x_y\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            \"k\"_mst.If(((x & y) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*!(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case Fragment::AND_B: return\n+            (x & \"B\"_mst).If(y << \"W\"_mst) | // B=B_x*W_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            (x & y & \"e\"_mst).If((x & y) << \"s\"_mst) | // e=e_x*e_y*s_x*s_y\n+            (x & y & \"dzm\"_mst) | // d=d_x*d_y, z=z_x*z_y, m=m_x*m_y\n+            \"f\"_mst.If(((x & y) << \"f\"_mst) || (x << \"sf\"_mst) || (y << \"sf\"_mst)) | // f=f_x*f_y + f_x*s_x + f_y*s_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"ux\"_mst | // u, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            \"k\"_mst.If(((x & y) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*!(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case Fragment::OR_B: return\n+            \"B\"_mst.If(x << \"Bd\"_mst && y << \"Wd\"_mst) | // B=B_x*d_x*W_x*d_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst && (x & y) << \"e\"_mst) | // m=m_x*m_y*e_x*e_y*(s_x+s_y)\n+            (x & y & \"zse\"_mst) | // z=z_x*z_y, s=s_x*s_y, e=e_x*e_y\n+            \"dux\"_mst | // d, u, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case Fragment::OR_D: return\n+            (y & \"B\"_mst).If(x << \"Bdu\"_mst) | // B=B_y*B_x*d_x*u_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x+s_y)\n+            (x & y & \"zes\"_mst) | // z=z_x*z_y, e=e_x*e_y, s=s_x*s_y\n+            (y & \"ufd\"_mst) | // u=u_y, f=f_y, d=d_y\n+            \"x\"_mst | // x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case Fragment::OR_C: return\n+            (y & \"V\"_mst).If(x << \"Bdu\"_mst) | // V=V_y*B_x*u_x*d_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x+s_y)\n+            (x & y & \"zs\"_mst) | // z=z_x*z_y, s=s_x*s_y\n+            \"fx\"_mst | // f, x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case Fragment::OR_I: return\n+            (x & y & \"VBKufs\"_mst) | // V=V_x*V_y, B=B_x*B_y, K=K_x*K_y, u=u_x*u_y, f=f_x*f_y, s=s_x*s_y\n+            \"o\"_mst.If((x & y) << \"z\"_mst) | // o=z_x*z_y\n+            ((x | y) & \"e\"_mst).If((x | y) << \"f\"_mst) | // e=e_x*f_y+f_x*e_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst) | // m=m_x*m_y*(s_x+s_y)\n+            ((x | y) & \"d\"_mst) | // d=d_x+d_y\n+            \"x\"_mst | // x\n+            ((x | y) & \"ghij\"_mst) | // g=g_x+g_y, h=h_x+h_y, i=i_x+i_y, j=j_x+j_y\n+            (x & y & \"k\"_mst); // k=k_x*k_y\n+        case Fragment::ANDOR: return\n+            (y & z & \"BKV\"_mst).If(x << \"Bdu\"_mst) | // B=B_x*d_x*u_x*B_y*B_z, K=B_x*d_x*u_x*K_y*K_z, V=B_x*d_x*u_x*V_y*V_z\n+            (x & y & z & \"z\"_mst) | // z=z_x*z_y*z_z\n+            ((x | (y & z)) & \"o\"_mst).If((x | (y & z)) << \"z\"_mst) | // o=o_x*z_y*z_z+z_x*o_y*o_z\n+            (y & z & \"u\"_mst) | // u=u_y*u_z\n+            (z & \"f\"_mst).If((x << \"s\"_mst) || (y << \"f\"_mst)) | // f=(s_x+f_y)*f_z\n+            (z & \"d\"_mst) | // d=d_z\n+            (x & z & \"e\"_mst).If(x << \"s\"_mst || y << \"f\"_mst) | // e=e_x*e_z*(s_x+f_y)\n+            (x & y & z & \"m\"_mst).If(x << \"e\"_mst && (x | y | z) << \"s\"_mst) | // m=m_x*m_y*m_z*e_x*(s_x+s_y+s_z)\n+            (z & (x | y) & \"s\"_mst) | // s=s_z*(s_x+s_y)\n+            \"x\"_mst | // x\n+            ((x | y | z) & \"ghij\"_mst) | // g=g_x+g_y+g_z, h=h_x+h_y+h_z, i=i_x+i_y+i_z, j=j_x+j_y_j_z\n+            \"k\"_mst.If(((x & y & z) << \"k\"_mst) &&\n+                !(((x << \"g\"_mst) && (y << \"h\"_mst)) ||\n+                ((x << \"h\"_mst) && (y << \"g\"_mst)) ||\n+                ((x << \"i\"_mst) && (y << \"j\"_mst)) ||\n+                ((x << \"j\"_mst) && (y << \"i\"_mst)))); // k=k_x*k_y*k_z* !(g_x*h_y + h_x*g_y + i_x*j_y + j_x*i_y)\n+        case Fragment::MULTI: return \"Bnudemsk\"_mst;\n+        case Fragment::THRESH: {\n+            bool all_e = true;\n+            bool all_m = true;\n+            uint32_t args = 0;\n+            uint32_t num_s = 0;\n+            Type acc_tl = \"k\"_mst;\n+            for (size_t i = 0; i < sub_types.size(); ++i) {\n+                Type t = sub_types[i];\n+                if (!(t << (i ? \"Wdu\"_mst : \"Bdu\"_mst))) return \"\"_mst; // Require Bdu, Wdu, Wdu, ...\n+                if (!(t << \"e\"_mst)) all_e = false;\n+                if (!(t << \"m\"_mst)) all_m = false;\n+                if (t << \"s\"_mst) num_s += 1;\n+                args += (t << \"z\"_mst) ? 0 : (t << \"o\"_mst) ? 1 : 2;\n+                acc_tl = ((acc_tl | t) & \"ghij\"_mst) |\n+                    // Thresh contains a combination of timelocks if it has threshold > 1 and\n+                    // it contains two different children that have different types of timelocks\n+                    // Note how if any of the children don't have \"k\", the parent also does not have \"k\"\n+                    \"k\"_mst.If(((acc_tl & t) << \"k\"_mst) && ((k <= 1) ||\n+                        ((k > 1) && !(((acc_tl << \"g\"_mst) && (t << \"h\"_mst)) ||\n+                        ((acc_tl << \"h\"_mst) && (t << \"g\"_mst)) ||\n+                        ((acc_tl << \"i\"_mst) && (t << \"j\"_mst)) ||\n+                        ((acc_tl << \"j\"_mst) && (t << \"i\"_mst))))));\n+            }\n+            return \"Bdu\"_mst |\n+                   \"z\"_mst.If(args == 0) | // z=all z\n+                   \"o\"_mst.If(args == 1) | // o=all z except one o\n+                   \"e\"_mst.If(all_e && num_s == n_subs) | // e=all e and all s\n+                   \"m\"_mst.If(all_e && all_m && num_s >= n_subs - k) | // m=all e, >=(n-k) s\n+                   \"s\"_mst.If(num_s >= n_subs - k + 1) |  // s= >=(n-k+1) s\n+                   acc_tl; // timelock info\n+            }\n+    }\n+    assert(false);\n+    return \"\"_mst;\n+}\n+\n+size_t ComputeScriptLen(Fragment nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys) {\n+    switch (nodetype) {\n+        case Fragment::JUST_1:\n+        case Fragment::JUST_0: return 1;\n+        case Fragment::PK_K: return 34;\n+        case Fragment::PK_H: return 3 + 21;\n+        case Fragment::OLDER:\n+        case Fragment::AFTER: return 1 + BuildScript(k).size();\n+        case Fragment::HASH256:\n+        case Fragment::SHA256: return 4 + 2 + 33;\n+        case Fragment::HASH160:\n+        case Fragment::RIPEMD160: return 4 + 2 + 21;\n+        case Fragment::MULTI: return 3 + (n_keys > 16) + (k > 16) + 34 * n_keys;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r856688398",
      "id" : 856688398,
      "line" : 264,
      "node_id" : "PRRC_kwDOABII584zEAcO",
      "original_commit_id" : "1ddaa66eae67b102f5e37d212d366a5dcad4aa26",
      "original_line" : 263,
      "original_position" : 263,
      "original_start_line" : null,
      "path" : "src/script/miniscript.cpp",
      "position" : 263,
      "pull_request_review_id" : 950733541,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/856688398/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-28T08:49:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/856688398",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860383117"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860383117"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Same comment as above for the opcodes",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-28T01:47:14Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: {\n+                const auto sat{(subs[0]->ss.sat + subs[1]->ss.sat) | (subs[0]->ss.dsat + subs[2]->ss.sat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[2]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: {\n+                const auto sat{(subs[0]->ss.dsat + subs[1]->ss.sat) | (subs[0]->ss.sat + subs[1]->ss.dsat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[1]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::OR_C: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {(subs[0]->ss.sat + 1) | (subs[1]->ss.sat + 1), (subs[0]->ss.dsat + 1) | (subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {k + 1, k + 1};\n+            case Fragment::WRAP_A:\n+            case Fragment::WRAP_N:\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C: return subs[0]->ss;\n+            case Fragment::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case Fragment::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case Fragment::THRESH: {\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    auto next_sats = Vector(sats[0] + sub->ss.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ss.dsat) | (sats[j - 1] + sub->ss.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ss.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};\n+    }\n+\n public:\n     //! Return the size of the script for this expression (faster than ToScript().size()).\n     size_t ScriptSize() const { return scriptlen; }\n \n+    //! Return the maximum number of ops needed to satisfy this script non-malleably.\n+    uint32_t GetOps() const { return ops.count + ops.sat.value; }\n+\n+    //! Check the ops limit of this script against the consensus limit.\n+    bool CheckOpsLimit() const { return GetOps() <= MAX_OPS_PER_SCRIPT; }\n+\n+    /** Return the maximum number of stack elements needed to satisfy this script non-malleably, including\n+     * the script push. */\n+    uint32_t GetStackSize() const { return ss.sat.value + 1; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860383117",
      "id" : 860383117,
      "line" : 741,
      "node_id" : "PRRC_kwDOABII584zSGeN",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 741,
      "original_position" : 200,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 200,
      "pull_request_review_id" : 950733541,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860383117/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-28T08:49:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860383117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860383140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860383140"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What should we do when there is a script that cannot be satisfied? For example, `thresh(1,0,a:0,a:pk(A))` is a valid miniscript that can never be satisfied. Should `GetOps` return `0` or some constant? \r\n \r\nMaybe something like? \r\n```c++\r\nuint32_t GetOps() const { return op.sat.valid ? ops.count + ops.sat.value : 0; }\r\n```\r\n\r\nThis is really a nit, as I don't see any useful miniscripts being constructed this way, but still good to check the validity of the variable before accessing it's value. \r\n",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-28T01:47:16Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: {\n+                const auto sat{(subs[0]->ss.sat + subs[1]->ss.sat) | (subs[0]->ss.dsat + subs[2]->ss.sat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[2]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: {\n+                const auto sat{(subs[0]->ss.dsat + subs[1]->ss.sat) | (subs[0]->ss.sat + subs[1]->ss.dsat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[1]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::OR_C: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {(subs[0]->ss.sat + 1) | (subs[1]->ss.sat + 1), (subs[0]->ss.dsat + 1) | (subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {k + 1, k + 1};\n+            case Fragment::WRAP_A:\n+            case Fragment::WRAP_N:\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C: return subs[0]->ss;\n+            case Fragment::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case Fragment::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case Fragment::THRESH: {\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    auto next_sats = Vector(sats[0] + sub->ss.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ss.dsat) | (sats[j - 1] + sub->ss.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ss.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};\n+    }\n+\n public:\n     //! Return the size of the script for this expression (faster than ToScript().size()).\n     size_t ScriptSize() const { return scriptlen; }\n \n+    //! Return the maximum number of ops needed to satisfy this script non-malleably.\n+    uint32_t GetOps() const { return ops.count + ops.sat.value; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860383140",
      "id" : 860383140,
      "line" : 734,
      "node_id" : "PRRC_kwDOABII584zSGek",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 734,
      "original_position" : 193,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 193,
      "pull_request_review_id" : 950733541,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860383140/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-28T08:49:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860383140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860626081"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860626081"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This should be {1, 0}. All hash types can be dis-satisfied with a random 32-byte pre-image.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-28T08:31:42Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860626081",
      "id" : 860626081,
      "line" : 689,
      "node_id" : "PRRC_kwDOABII584zTByh",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 689,
      "original_position" : 148,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 148,
      "pull_request_review_id" : 950733541,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860626081/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-28T08:49:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860626081",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860635731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860635731"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What's the purpose of return after an assert? Is this normal in c++? Same comment for the above function",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-28T08:42:00Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: {\n+                const auto sat{(subs[0]->ss.sat + subs[1]->ss.sat) | (subs[0]->ss.dsat + subs[2]->ss.sat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[2]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: {\n+                const auto sat{(subs[0]->ss.dsat + subs[1]->ss.sat) | (subs[0]->ss.sat + subs[1]->ss.dsat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[1]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::OR_C: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {(subs[0]->ss.sat + 1) | (subs[1]->ss.sat + 1), (subs[0]->ss.dsat + 1) | (subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {k + 1, k + 1};\n+            case Fragment::WRAP_A:\n+            case Fragment::WRAP_N:\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C: return subs[0]->ss;\n+            case Fragment::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case Fragment::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case Fragment::THRESH: {\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    auto next_sats = Vector(sats[0] + sub->ss.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ss.dsat) | (sats[j - 1] + sub->ss.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ss.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r860635731",
      "id" : 860635731,
      "line" : 726,
      "node_id" : "PRRC_kwDOABII584zTEJT",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 726,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 185,
      "pull_request_review_id" : 950733541,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860635731/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-28T08:49:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/860635731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862331864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862331864"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah it's not necessary, Marco mentioned it to me elsewhere. I can remove it in #24860 ",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-30T08:49:28Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};\n+            case Fragment::ANDOR: {\n+                const auto sat{(subs[0]->ss.sat + subs[1]->ss.sat) | (subs[0]->ss.dsat + subs[2]->ss.sat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[2]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case Fragment::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_B: {\n+                const auto sat{(subs[0]->ss.dsat + subs[1]->ss.sat) | (subs[0]->ss.sat + subs[1]->ss.dsat)};\n+                const auto dsat{subs[0]->ss.dsat + subs[1]->ss.dsat};\n+                return {sat, dsat};\n+            }\n+            case Fragment::OR_C: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case Fragment::OR_D: return {subs[0]->ss.sat | (subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case Fragment::OR_I: return {(subs[0]->ss.sat + 1) | (subs[1]->ss.sat + 1), (subs[0]->ss.dsat + 1) | (subs[1]->ss.dsat + 1)};\n+            case Fragment::MULTI: return {k + 1, k + 1};\n+            case Fragment::WRAP_A:\n+            case Fragment::WRAP_N:\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C: return subs[0]->ss;\n+            case Fragment::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case Fragment::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case Fragment::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case Fragment::THRESH: {\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    auto next_sats = Vector(sats[0] + sub->ss.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ss.dsat) | (sats[j - 1] + sub->ss.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ss.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862331864",
      "id" : 862331864,
      "in_reply_to_id" : 860635731,
      "line" : 726,
      "node_id" : "PRRC_kwDOABII584zZiPY",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 726,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 185,
      "pull_request_review_id" : 958471462,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862331864/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-30T08:49:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862331864",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862331895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862331895"
         }
      },
      "author_association" : "MEMBER",
      "body" : "But it's malleable, so we don't want to account for it.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-30T08:50:03Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862331895",
      "id" : 862331895,
      "in_reply_to_id" : 860626081,
      "line" : 689,
      "node_id" : "PRRC_kwDOABII584zZiP3",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 689,
      "original_position" : 148,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 148,
      "pull_request_review_id" : 958471493,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862331895/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-30T08:50:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862331895",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862397269"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862397269"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why be different while calculating stack size and opcodes? In calculating executed op code count, we count the correct opcodes when this expression is dissatisfied. But we don't do so while considering stack size?",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-04-30T21:22:10Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862397269",
      "id" : 862397269,
      "in_reply_to_id" : 860626081,
      "line" : 689,
      "node_id" : "PRRC_kwDOABII584zZyNV",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 689,
      "original_position" : 148,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 148,
      "pull_request_review_id" : 958521169,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862397269/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-30T21:22:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862397269",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862484711"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862484711"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The hashing fragments return `{4, 0, {}}` in CalcOps, and `{1, {}}` in CalcStackSize? In both cases, no value (`{}`) is returned for the dissatisfaction case, because the non-malleable signing algorithm will never use the dissatisfaction path.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-05-01T14:48:00Z",
      "diff_hunk" : "@@ -556,10 +601,148 @@ struct Node {\n         return res.has_value();\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_1: return {0, 0, {}};\n+            case Fragment::JUST_0: return {0, {}, 0};\n+            case Fragment::PK_K: return {0, 0, 0};\n+            case Fragment::PK_H: return {3, 0, 0};\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {1, 0, {}};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {4, 0, {}};\n+            case Fragment::AND_V: return {subs[0]->ops.count + subs[1]->ops.count, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case Fragment::AND_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat + subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_B: {\n+                const auto count{1 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{(subs[0]->ops.sat + subs[1]->ops.dsat) | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_D: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::OR_C: {\n+                const auto count{2 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | (subs[1]->ops.sat + subs[0]->ops.dsat)};\n+                return {count, sat, {}};\n+            }\n+            case Fragment::OR_I: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count};\n+                const auto sat{subs[0]->ops.sat | subs[1]->ops.sat};\n+                const auto dsat{subs[0]->ops.dsat | subs[1]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::ANDOR: {\n+                const auto count{3 + subs[0]->ops.count + subs[1]->ops.count + subs[2]->ops.count};\n+                const auto sat{(subs[1]->ops.sat + subs[0]->ops.sat) | (subs[0]->ops.dsat + subs[2]->ops.sat)};\n+                const auto dsat{subs[0]->ops.dsat + subs[2]->ops.dsat};\n+                return {count, sat, dsat};\n+            }\n+            case Fragment::MULTI: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case Fragment::WRAP_S:\n+            case Fragment::WRAP_C:\n+            case Fragment::WRAP_N: return {1 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_A: return {2 + subs[0]->ops.count, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case Fragment::WRAP_D: return {3 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_J: return {4 + subs[0]->ops.count, subs[0]->ops.sat, 0};\n+            case Fragment::WRAP_V: return {subs[0]->ops.count + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case Fragment::THRESH: {\n+                uint32_t count = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    count += sub->ops.count + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back((sats[j] + sub->ops.dsat) | (sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                assert(k <= sats.size());\n+                return {count, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case Fragment::JUST_0: return {{}, 0};\n+            case Fragment::JUST_1:\n+            case Fragment::OLDER:\n+            case Fragment::AFTER: return {0, {}};\n+            case Fragment::PK_K: return {1, 1};\n+            case Fragment::PK_H: return {2, 2};\n+            case Fragment::SHA256:\n+            case Fragment::RIPEMD160:\n+            case Fragment::HASH256:\n+            case Fragment::HASH160: return {1, {}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r862484711",
      "id" : 862484711,
      "in_reply_to_id" : 860626081,
      "line" : 689,
      "node_id" : "PRRC_kwDOABII584zaHjn",
      "original_commit_id" : "f8369996e76dbc41a12f7b7eea14a7e7990a81c1",
      "original_line" : 689,
      "original_position" : 148,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 148,
      "pull_request_review_id" : 958598869,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862484711/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-01T14:48:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/862484711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r873081915"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873081915"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Isn't it the other way around, where if `true` then the right hand's properties are a superset of the left's?",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-05-14T22:39:24Z",
      "diff_hunk" : "@@ -0,0 +1,1652 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This can be obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or by combining a V fragment under some conditions.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains an absolute time timelock\n+ * - \"j\" Whether the branch contains an absolute height timelock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r873081915",
      "id" : 873081915,
      "line" : 137,
      "node_id" : "PRRC_kwDOABII5840Ciw7",
      "original_commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "original_line" : 137,
      "original_position" : 137,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 137,
      "pull_request_review_id" : 973104889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873081915/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-14T22:39:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873081915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r873082324"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873082324"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Sorry of course right after posting I see that the order of `m_flags` and `x.m_flags` is switched up for this operator compared to the other operators, which makes the docstring correct so please disregard my previous comment. The inconsistent order is maybe a bit confusing but no problem.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-05-14T22:45:47Z",
      "diff_hunk" : "@@ -0,0 +1,1652 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This can be obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or by combining a V fragment under some conditions.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains an absolute time timelock\n+ * - \"j\" Whether the branch contains an absolute height timelock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r873082324",
      "id" : 873082324,
      "in_reply_to_id" : 873081915,
      "line" : 137,
      "node_id" : "PRRC_kwDOABII5840Ci3U",
      "original_commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "original_line" : 137,
      "original_position" : 137,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 137,
      "pull_request_review_id" : 973105144,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873082324/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-14T22:45:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873082324",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r873082346"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873082346"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, the comment is correct I believe.\n\n(x.m_flags & ~m_flags) is zero when every flag set in x.m_flags is also set in m_flags. In other words, where this's flags (=left hand) are a superset of x's flags.",
      "commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "created_at" : "2022-05-14T22:46:20Z",
      "diff_hunk" : "@@ -0,0 +1,1652 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This can be obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or by combining a V fragment under some conditions.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains an absolute time timelock\n+ * - \"j\" Whether the branch contains an absolute height timelock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r873082346",
      "id" : 873082346,
      "in_reply_to_id" : 873081915,
      "line" : 137,
      "node_id" : "PRRC_kwDOABII5840Ci3q",
      "original_commit_id" : "2da94a4c6f55f7a3621f4a6f70902c52f735c868",
      "original_line" : 137,
      "original_position" : 137,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 137,
      "pull_request_review_id" : 973105162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873082346/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-14T22:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/873082346",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
